/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _DrilldownMap = __webpack_require__(2);\n\nvar _DrilldownMap2 = _interopRequireDefault(_DrilldownMap);\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nwindow.Reportal = window.Reportal || {};\n_rReportalBase2.default.mixin(window.Reportal, {\n  DrilldownMap: _DrilldownMap2.default\n});\n\nexports.default = Reportal;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz8zNDc5Il0sIm5hbWVzIjpbIndpbmRvdyIsIlJlcG9ydGFsIiwibWl4aW4iLCJEcmlsbGRvd25NYXAiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBQSxPQUFPQyxRQUFQLEdBQWtCRCxPQUFPQyxRQUFQLElBQW1CLEVBQXJDO0FBQ0Esd0JBQWFDLEtBQWIsQ0FBbUJGLE9BQU9DLFFBQTFCLEVBQW1DO0FBQ2pDRTtBQURpQyxDQUFuQzs7a0JBSWVGLFEiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IERyaWxsZG93bk1hcCBmcm9tIFwiLi9EcmlsbGRvd25NYXBcIjtcbmltcG9ydCBSZXBvcnRhbEJhc2UgZnJvbSBcInItcmVwb3J0YWwtYmFzZVwiO1xuXG53aW5kb3cuUmVwb3J0YWwgPSB3aW5kb3cuUmVwb3J0YWwgfHwge31cblJlcG9ydGFsQmFzZS5taXhpbih3aW5kb3cuUmVwb3J0YWwse1xuICBEcmlsbGRvd25NYXBcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBSZXBvcnRhbFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21haW4uanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ReportalBase = function () {\n  function ReportalBase() {\n    _classCallCheck(this, ReportalBase);\n  }\n\n  _createClass(ReportalBase, null, [{\n    key: 'mixin',\n\n\n    /**\r\n     * Copies props from a source object to a target object.\r\n     *\r\n     * Note, this method uses a simple `for...in` strategy for enumerating\r\n     * properties.  To ensure only `ownProperties` are copied from source\r\n     * to target and that accessor implementations are copied, use `extend`.\r\n     *\r\n     * @method mixin\r\n     * @param {Object} target Target object to copy properties to.\r\n     * @param {Object} source Source object to copy properties from.\r\n     * @return {Object} Target object that was passed as first argument.\r\n     */\n    value: function mixin(target, source) {\n      for (var i in source) {\n        target[i] = source[i];\n      }\n      return target;\n    }\n  }, {\n    key: '_logger',\n    value: function _logger(level, args) {\n      // accept ['foo', 'bar'] and [['foo', 'bar']]\n      if (args.length === 1 && Array.isArray(args[0])) {\n        args = args[0];\n      }\n      // only accept logging functions\n      switch (level) {\n        case 'log':\n        case 'warn':\n        case 'error':\n          console[level].apply(console, args);\n          break;\n      }\n    }\n  }, {\n    key: '_log',\n    value: function _log() {\n      var args = Array.prototype.slice.call(arguments, 0);\n      this._logger('log', args);\n    }\n  }, {\n    key: '_warn',\n    value: function _warn() {\n      var args = Array.prototype.slice.call(arguments, 0);\n      this._logger('warn', args);\n    }\n  }, {\n    key: '_error',\n    value: function _error() {\n      var args = Array.prototype.slice.call(arguments, 0);\n      this._logger('error', args);\n    }\n\n    /**\r\n     * Creates a named event with `name`\r\n     * @param {String} name - name of the event\r\n     * @return {Event} Returns a created event\r\n     * */\n\n  }, {\n    key: 'newEvent',\n    value: function newEvent(name) {\n      var event = document.createEvent('Event');\n      event.initEvent(name, true, true);\n      return event;\n    }\n\n    /**\r\n     * Inspects if the current string might be converted to number and renders it as number. If string length is 0, returns `null`. If none applies returns the string as is.\r\n     * @param {String} str - value of the cell if not HTML contents\r\n     * @return {Number|null|String}\r\n     * */\n\n  }, {\n    key: 'isNumber',\n    value: function isNumber(str) {\n      if (!isNaN(parseFloat(str))) {\n        str = str.replace(/,/i, ''); // remove unnecessary comma as a delimiter for thousands from data.\n        return parseFloat(str);\n      } else if (str.length == 0) {\n        return null;\n      } else {\n        return str;\n      }\n    }\n\n    /**\r\n     * Creates an XHR wrapped in a Promise\r\n     * @param {!String} URL - url to send a `GET` request to\r\n     * @return {Promise} Returns a then-able promise with `XMLHttpRequest.responseText`\r\n     * */\n\n  }, {\n    key: 'promiseRequest',\n    value: function promiseRequest(URL) {\n      return new Promise(function (resolve, reject) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', URL, true);\n        xhr.onload = function () {\n          xhr.status == 200 ? resolve(xhr.responseText) : reject(Error(xhr.status + ': ' + xhr.statusText));\n        };\n        xhr.onerror = function () {\n          reject(Error(\"Network Error\"));\n        };\n        xhr.send();\n      });\n    }\n\n    /**\r\n     * Gets a variable listed in query string\r\n     * @param {!String} variable - variable name to get value for\r\n     * @param {String=} [query=window.location.search.substring(1)] - the query string to search variable for in\r\n     * @return {String} Returns value for the variable\r\n     * */\n\n  }, {\n    key: 'getQueryVariable',\n    value: function getQueryVariable(variable) {\n      var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.location.search.substring(1);\n\n      var vars = query.split(\"&\");\n      for (var i = 0; i < vars.length; i++) {\n        var pair = vars[i].split(\"=\");\n        if (pair[0].toLowerCase() == variable.toLowerCase()) {\n          return pair[1];\n        }\n      }\n      return null;\n    }\n  }]);\n\n  return ReportalBase;\n}();\n\nexports.default = ReportalBase;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItcmVwb3J0YWwtYmFzZS9zcmMvcmVwb3J0YWwtYmFzZS5qcz9kYTM1Il0sIm5hbWVzIjpbIlJlcG9ydGFsQmFzZSIsInRhcmdldCIsInNvdXJjZSIsImkiLCJsZXZlbCIsImFyZ3MiLCJsZW5ndGgiLCJBcnJheSIsImlzQXJyYXkiLCJjb25zb2xlIiwiYXBwbHkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJhcmd1bWVudHMiLCJfbG9nZ2VyIiwibmFtZSIsImV2ZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsInN0ciIsImlzTmFOIiwicGFyc2VGbG9hdCIsInJlcGxhY2UiLCJVUkwiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsIm9ubG9hZCIsInN0YXR1cyIsInJlc3BvbnNlVGV4dCIsIkVycm9yIiwic3RhdHVzVGV4dCIsIm9uZXJyb3IiLCJzZW5kIiwidmFyaWFibGUiLCJxdWVyeSIsIndpbmRvdyIsImxvY2F0aW9uIiwic2VhcmNoIiwic3Vic3RyaW5nIiwidmFycyIsInNwbGl0IiwicGFpciIsInRvTG93ZXJDYXNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0lBQU1BLFk7Ozs7Ozs7OztBQUVKOzs7Ozs7Ozs7Ozs7MEJBWWFDLE0sRUFBUUMsTSxFQUFRO0FBQzNCLFdBQUssSUFBSUMsQ0FBVCxJQUFjRCxNQUFkLEVBQXNCO0FBQ3BCRCxlQUFPRSxDQUFQLElBQVlELE9BQU9DLENBQVAsQ0FBWjtBQUNEO0FBQ0QsYUFBT0YsTUFBUDtBQUNEOzs7NEJBRWNHLEssRUFBT0MsSSxFQUFNO0FBQzFCO0FBQ0EsVUFBSUEsS0FBS0MsTUFBTCxLQUFnQixDQUFoQixJQUFxQkMsTUFBTUMsT0FBTixDQUFjSCxLQUFLLENBQUwsQ0FBZCxDQUF6QixFQUFpRDtBQUMvQ0EsZUFBT0EsS0FBSyxDQUFMLENBQVA7QUFDRDtBQUNEO0FBQ0Es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Ozs7a0JBR1kvQyxZIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBSZXBvcnRhbEJhc2Uge1xyXG5cclxuICAvKipcclxuICAgKiBDb3BpZXMgcHJvcHMgZnJvbSBhIHNvdXJjZSBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogTm90ZSwgdGhpcyBtZXRob2QgdXNlcyBhIHNpbXBsZSBgZm9yLi4uaW5gIHN0cmF0ZWd5IGZvciBlbnVtZXJhdGluZ1xyXG4gICAqIHByb3BlcnRpZXMuICBUbyBlbnN1cmUgb25seSBgb3duUHJvcGVydGllc2AgYXJlIGNvcGllZCBmcm9tIHNvdXJjZVxyXG4gICAqIHRvIHRhcmdldCBhbmQgdGhhdCBhY2Nlc3NvciBpbXBsZW1lbnRhdGlvbnMgYXJlIGNvcGllZCwgdXNlIGBleHRlbmRgLlxyXG4gICAqXHJcbiAgICogQG1ldGhvZCBtaXhpblxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGFyZ2V0IG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBTb3VyY2Ugb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxyXG4gICAqIEByZXR1cm4ge09iamVjdH0gVGFyZ2V0IG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgYXMgZmlyc3QgYXJndW1lbnQuXHJcbiAgICovXHJcbiAgc3RhdGljIG1peGluKHRhcmdldCwgc291cmNlKSB7XHJcbiAgICBmb3IgKHZhciBpIGluIHNvdXJjZSkge1xyXG4gICAgICB0YXJnZXRbaV0gPSBzb3VyY2VbaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIF9sb2dnZXIobGV2ZWwsIGFyZ3MpIHtcclxuICAgIC8vIGFjY2VwdCBbJ2ZvbycsICdiYXInXSBhbmQgW1snZm9vJywgJ2JhciddXVxyXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcclxuICAgICAgYXJncyA9IGFyZ3NbMF07XHJcbiAgICB9XHJcbiAgICAvLyBvbmx5IGFjY2VwdCBsb2dnaW5nIGZ1bmN0aW9uc1xyXG4gICAgc3dpdGNoKGxldmVsKSB7XHJcbiAgICAgIGNhc2UgJ2xvZyc6XHJcbiAgICAgIGNhc2UgJ3dhcm4nOlxyXG4gICAgICBjYXNlICdlcnJvcic6XHJcbiAgICAgICAgY29uc29sZVtsZXZlbF0uYXBwbHkoY29uc29sZSwgYXJncyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgX2xvZygpIHtcclxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcclxuICAgIHRoaXMuX2xvZ2dlcignbG9nJywgYXJncyk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgX3dhcm4oKSB7XHJcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XHJcbiAgICB0aGlzLl9sb2dnZXIoJ3dhcm4nLCBhcmdzKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBfZXJyb3IoKSB7XHJcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XHJcbiAgICB0aGlzLl9sb2dnZXIoJ2Vycm9yJywgYXJncyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmFtZWQgZXZlbnQgd2l0aCBgbmFtZWBcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICogQHJldHVybiB7RXZlbnR9IFJldHVybnMgYSBjcmVhdGVkIGV2ZW50XHJcbiAgICogKi9cclxuICBzdGF0aWMgbmV3RXZlbnQobmFtZSl7XHJcbiAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxuICAgIGV2ZW50LmluaXRFdmVudChuYW1lLCB0cnVlLCB0cnVlKTtcclxuICAgIHJldHVybiBldmVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluc3BlY3RzIGlmIHRoZSBjdXJyZW50IHN0cmluZyBtaWdodCBiZSBjb252ZXJ0ZWQgdG8gbnVtYmVyIGFuZCByZW5kZXJzIGl0IGFzIG51bWJlci4gSWYgc3RyaW5nIGxlbmd0aCBpcyAwLCByZXR1cm5zIGBudWxsYC4gSWYgbm9uZSBhcHBsaWVzIHJldHVybnMgdGhlIHN0cmluZyBhcyBpcy5cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gdmFsdWUgb2YgdGhlIGNlbGwgaWYgbm90IEhUTUwgY29udGVudHNcclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ8bnVsbHxTdHJpbmd9XHJcbiAgICogKi9cclxuICBzdGF0aWMgaXNOdW1iZXIoc3RyKXtcclxuICAgIGlmKCFpc05hTihwYXJzZUZsb2F0KHN0cikpKXtcclxuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLywvaSwnJyk7Ly8gcmVtb3ZlIHVubmVjZXNzYXJ5IGNvbW1hIGFzIGEgZGVsaW1pdGVyIGZvciB0aG91c2FuZHMgZnJvbSBkYXRhLlxyXG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIpO1xyXG4gICAgfSBlbHNlIGlmKHN0ci5sZW5ndGg9PTApe3JldHVybiBudWxsfSBlbHNlIHtyZXR1cm4gc3RyfVxyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gWEhSIHdyYXBwZWQgaW4gYSBQcm9taXNlXHJcbiAgICogQHBhcmFtIHshU3RyaW5nfSBVUkwgLSB1cmwgdG8gc2VuZCBhIGBHRVRgIHJlcXVlc3QgdG9cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXR1cm5zIGEgdGhlbi1hYmxlIHByb21pc2Ugd2l0aCBgWE1MSHR0cFJlcXVlc3QucmVzcG9uc2VUZXh0YFxyXG4gICAqICovXHJcbiAgc3RhdGljIHByb21pc2VSZXF1ZXN0KFVSTCl7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KT0+e1xyXG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgIHhoci5vcGVuKCdHRVQnLCBVUkwsIHRydWUpO1xyXG4gICAgICB4aHIub25sb2FkID0gKCk9Pnt4aHIuc3RhdHVzID09IDIwMD9yZXNvbHZlKHhoci5yZXNwb25zZVRleHQpOnJlamVjdChFcnJvcihgJHt4aHIuc3RhdHVzfTogJHt4aHIuc3RhdHVzVGV4dH1gKSk7fVxyXG4gICAgICB4aHIub25lcnJvciA9ICgpPT57cmVqZWN0KEVycm9yKFwiTmV0d29yayBFcnJvclwiKSk7fVxyXG4gICAgICB4aHIuc2VuZCgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGEgdmFyaWFibGUgbGlzdGVkIGluIHF1ZXJ5IHN0cmluZ1xyXG4gICAqIEBwYXJhbSB7IVN0cmluZ30gdmFyaWFibGUgLSB2YXJpYWJsZSBuYW1lIHRvIGdldCB2YWx1ZSBmb3JcclxuICAgKiBAcGFyYW0ge1N0cmluZz19IFtxdWVyeT13aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKV0gLSB0aGUgcXVlcnkgc3RyaW5nIHRvIHNlYXJjaCB2YXJpYWJsZSBmb3IgaW5cclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFJldHVybnMgdmFsdWUgZm9yIHRoZSB2YXJpYWJsZVxyXG4gICAqICovXHJcbiAgc3RhdGljIGdldFF1ZXJ5VmFyaWFibGUodmFyaWFibGUscXVlcnk9d2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpe1xyXG4gICAgdmFyIHZhcnMgPSBxdWVyeS5zcGxpdChcIiZcIik7XHJcbiAgICBmb3IgKHZhciBpPTA7aTx2YXJzLmxlbmd0aDtpKyspIHtcclxuICAgICAgdmFyIHBhaXIgPSB2YXJzW2ldLnNwbGl0KFwiPVwiKTtcclxuICAgICAgaWYoKHBhaXJbMF0pLnRvTG93ZXJDYXNlKCkgPT0gdmFyaWFibGUudG9Mb3dlckNhc2UoKSl7cmV0dXJuIHBhaXJbMV07fVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxufVxyXG5leHBvcnQgZGVmYXVsdCBSZXBvcnRhbEJhc2VcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yLXJlcG9ydGFsLWJhc2Uvc3JjL3JlcG9ydGFsLWJhc2UuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DrilldownMap = function () {\n\n  /**\n   * Creates a drilldown map\n   * @param {Object} hierarchy - a hierarchical object for a map to be built upon\n   * @param {String} containerID - id of the container the map will be drawn to\n   * @param {Function} mappointCallback - executed when a mappoint (city) is clicked\n   * @param {Array.<{from:Number, to:Number, color:String, name:String}>} dataClasses - color bands for conditional formatting\n   * @param {Object} options - options passed to HighMap to restyle/configure it\n   * */\n  function DrilldownMap() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        hierarchy = _ref.hierarchy,\n        _ref$initMap = _ref.initMap,\n        initMap = _ref$initMap === undefined ? \"custom/world-highres2\" : _ref$initMap,\n        containerID = _ref.containerID,\n        mappointCallback = _ref.mappointCallback,\n        _ref$dataClasses = _ref.dataClasses,\n        dataClasses = _ref$dataClasses === undefined ? [{\n      from: 80,\n      to: 100,\n      color: '#8bc34a',\n      name: 'Promoter'\n    }, {\n      from: 60,\n      to: 80,\n      color: '#ffc107',\n      name: 'Passive'\n    }, {\n      from: 0,\n      to: 60,\n      color: '#f44336',\n      name: 'Detractor'\n    }] : _ref$dataClasses,\n        _ref$options = _ref.options,\n        options = _ref$options === undefined ? {} : _ref$options;\n\n    _classCallCheck(this, DrilldownMap);\n\n    if (mappointCallback) {\n      if (typeof mappointCallback == 'function') {\n        this.mappointCallback = mappointCallback;\n      } else {\n        throw new TypeError(\"mappointCallback must be a function\");\n      }\n    }\n\n    var config = this.config = _rReportalBase2.default.mixin(options, { colorAxis: { dataClasses: dataClasses } });\n    if ((typeof Highcharts === \"undefined\" ? \"undefined\" : _typeof(Highcharts)) == undefined) {\n      throw new Error('Highcharts must be declared. Probably they are missing');\n    };\n    if (_typeof(Highcharts.maps) == undefined) {\n      throw new Error('HighMaps must be loaded. Probably they are missing');\n    };\n    this.constructor.addMapIDsToHierarchyLevel(hierarchy);\n    //\n    this.drawMap(hierarchy, containerID, initMap, config);\n  }\n\n  /***\n   * Creates custom geoJSON file\n   * @param {Object} mapData - initial map\n   * @param {Array}countriesList - list of countries IDs\n   * @param {String} mapName\n   * @returns {Object}\n   */\n\n\n  _createClass(DrilldownMap, [{\n    key: \"initMap\",\n\n\n    /**\n     * Get series for the first time map initialization\n     * @param {Object} curLVL - current level in hierarchy\n     * @param {Array} [series=[]] - series\n     * @returns {Array}\n     * */\n    value: function initMap(curLVL) {\n      var _this = this;\n\n      var series = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      curLVL.subcells.forEach(function (subcell) {\n        if (subcell.mapID) {\n          var seriesItem = _this.composeSeries(subcell);\n          series.push(seriesItem);\n        }\n      });\n      return series;\n    }\n\n    /***\n     * Updates initial hierarchy\n     * @param hierarchy\n     * @param parent - hierarchy level parent\n     */\n\n  }, {\n    key: \"getCoordinateSeries\",\n\n\n    /**\n     * Create a single mappoint series\n     * @param {Object} subcell\n     * @param {Object} mapData\n     * @param {Object} chart\n     * @returns {Object} series for map points\n     * */\n    value: function getCoordinateSeries(subcell, mapData, chart) {\n      chart.mapTransforms = mapData ? mapData[\"hc-transform\"] : Highcharts.maps[\"custom/world-highres2\"][\"hc-transform\"];\n      var pos = chart.fromLatLonToPoint({ lat: subcell.coordinates[0], lon: subcell.coordinates[1] });\n      var config = {\n        type: \"mappoint\", // or \"mapbubble,\n        name: subcell.text,\n        marker: {\n          lineColor: \"black\",\n          lineWidth: 1,\n          radius: 4,\n          symbol: \"circle\"\n        },\n        data: [{\n          color: DrilldownMap.getColor(subcell.value, this.config.colorAxis.dataClasses),\n          name: subcell.text,\n          value: subcell.value,\n          x: pos.x,\n          y: pos.y\n        }]\n      };\n      if (this.mappointCallback) {\n        config.events = {\n          click: this.mappointCallback\n        };\n      }\n      return config;\n    }\n\n    /***\n     * Creates a single series for Highmaps series option\n     * @param subcell\n     * @param mapData\n     * @param chart\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"composeSeries\",\n    value: function composeSeries(subcell, mapData, chart) {\n      if (!subcell.coordinates) {\n        mapData = mapData ? Highcharts.geojson(DrilldownMap.createCustomGeoJSON(mapData, subcell.mapID, subcell.text)) : Highcharts.geojson(DrilldownMap.createCustomGeoJSON(Highcharts.maps['custom/world-highres2'], subcell.mapID, subcell.text));\n        if (subcell.mapID) {\n          return {\n            name: subcell.text,\n            tooltip: {\n              pointFormat: 'NPS : {point.value}'\n            },\n            allAreas: false,\n            parent: subcell.parent.text,\n            mapData: mapData,\n            joinBy: ['hc-key', 'code'],\n            data: DrilldownMap.getSeriesData(subcell)\n          };\n        }\n      } else {\n        return this.getCoordinateSeries(subcell, mapData, chart);\n      }\n    }\n\n    /***\n     * Updates your map view after drilldown click\n     * @param {Object} curLVL\n     * @param {Object} chart\n     * @param {Object} e - drilldown event object\n     * @returns {Object} Returns curLVL\n     */\n\n  }, {\n    key: \"updateMap\",\n    value: function updateMap(curLVL, chart, e) {\n      var _this2 = this;\n\n      curLVL = curLVL.subcells.filter(function (el) {\n        return el.text == e.point.series.name;\n      })[0];\n      if (curLVL && curLVL.map) {\n        // if we have another map to load\n        var map = DrilldownMap.loadMap(curLVL.map);\n        map.then(function (mapData) {\n          _this2.addSeries(curLVL, chart, e, mapData);\n        });\n      } else if (curLVL && !curLVL.map) {\n        this.addSeries(curLVL, chart, e);\n      }\n      return curLVL;\n    }\n\n    /***\n     * Composes a series for your HighMaps options config\n     * @param {Object} curLVL\n     * @param {Object} chart\n     * @param {Object} e - drilldown event object\n     * @param {Object} mapData - mapData geoJSON\n     */\n\n  }, {\n    key: \"addSeries\",\n    value: function addSeries(curLVL, chart, e, mapData) {\n      var _this3 = this;\n\n      if (curLVL.subcells && curLVL.isGlobal) {\n        // if it's an end point\n        if (curLVL.subcells[0].coordinates) {\n          var seriesItem = this.composeSeries(curLVL, mapData, chart);\n          seriesItem.data.forEach(function (dataItem) {\n            dataItem.drilldown = null;\n            dataItem.value = null;\n          });\n          chart.addSingleSeriesAsDrilldown(e.point, seriesItem);\n        }\n        curLVL.subcells.forEach(function (subcell) {\n          if (!subcell.mapID && !subcell.coordinates) return;\n\n          var seriesItem = _this3.composeSeries(subcell, mapData, chart);\n          chart.addSingleSeriesAsDrilldown(e.point, seriesItem);\n        });\n        chart.applyDrilldown();\n      } else {\n        var _seriesItem = this.composeSeries(curLVL, mapData, chart);\n        _seriesItem.data.map(function (dataItem) {\n          dataItem.drilldown = null;\n          dataItem.value = null;\n        });\n        chart.addSeriesAsDrilldown(e.point, _seriesItem);\n      }\n    }\n\n    /***\n     * @param hierarchy\n     * @param containerID\n     * @param options\n     */\n\n  }, {\n    key: \"drawMap\",\n    value: function drawMap(hierarchy, containerID, initMap, options) {\n      var curLVL = hierarchy[0];\n      var self = this;\n      var config = {\n        lang: {\n          drillUpText: 'Back to {series.parent}'\n        },\n        tooltip: {\n          pointFormat: 'NPS : {point.value}'\n        },\n        title: {\n          text: 'Drilldown map'\n        },\n        legend: {\n          enabled: false\n        },\n        mapNavigation: {\n          enabled: true\n        },\n        subtitle: {\n          align: 'right',\n          text: \"Current level: \" + curLVL.text + \" <br> Region NPS: \" + curLVL.value\n        },\n        chart: {\n          events: {\n            drilldown: function drilldown(e) {\n              //TODO: add data promise;\n              var chart = e.target;\n              curLVL = self.updateMap(curLVL, chart, e);\n              chart.subtitle.update({ text: \"Current region: \" + curLVL.text + \"<br> Region NPS: \" + curLVL.value });\n            },\n            drillupall: function drillupall(e) {\n              curLVL = curLVL.parent;\n              if (curLVL) chart.subtitle.update({ text: \"Current level: \" + curLVL.text + \" <br> Region NPS: \" + curLVL.value });\n            }\n          }\n        },\n        series: this.initMap(curLVL, [{\n          mapData: Highcharts.maps[initMap]\n        }])\n      };\n      config = _rReportalBase2.default.mixin(config, options);\n      Highcharts.mapChart(containerID, config);\n    }\n  }], [{\n    key: \"createCustomGeoJSON\",\n    value: function createCustomGeoJSON(mapData, countriesList, mapName) {\n      var geojson = {\n        title: \"\",\n        version: \"0.1.0\",\n        type: \"FeatureCollection\",\n        copyright: \"Copyright (c) 2015 Highsoft AS, Based on data from Natural Earth\",\n        copyrightShort: \"Natural Earth\",\n        copyrightUrl: \"http://www.naturalearthdata.com\",\n        crs: {\n          type: \"name\",\n          properties: {\n            name: \"urn:ogc:def:crs:EPSG:54003\"\n          }\n        },\n        \"hc-transform\": {\n          default: {\n            crs: \"+proj=mill +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +R_A +datum=WGS84 +units=m +no_defs\",\n            scale: 1.72182781654e-05,\n            jsonres: 15.5,\n            jsonmarginX: -999,\n            jsonmarginY: 9851.0,\n            xoffset: -19495356.3693,\n            yoffset: 12635908.1982\n          }\n        },\n        features: DrilldownMap.getFeatures(countriesList, mapData) //[[]]\n      };\n\n      geojson.title = mapName;\n      return geojson;\n    }\n\n    /***\n     * Get array of features from geoJSON file\n     * @param {Array | String}countriesList - countries IDs\n     * @param {Object} mapData - your initial map\n     * @param {String} key for geojson features comparing\n     * @returns {Array} features list\n     */\n\n  }, {\n    key: \"getFeatures\",\n    value: function getFeatures(countriesList, mapData) {\n      var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"hc-key\";\n\n      if (typeof countriesList === 'string') {\n        return mapData.features.filter(function (feature) {\n          return feature.properties[key] === countriesList;\n        });\n      } else if (Array.isArray(countriesList)) {\n        return mapData.features.filter(function (feature) {\n          return countriesList.indexOf(feature.properties[key]) != -1;\n        });\n      }\n    }\n  }, {\n    key: \"addMapIDsToHierarchyLevel\",\n    value: function addMapIDsToHierarchyLevel(hierarchy) {\n      var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      hierarchy.forEach(function (subcell) {\n        subcell.parent = parent;\n        subcell.value = Math.random() * 100;\n        if (subcell.parent && subcell.parent != null && subcell.parent.map) {\n          subcell.map = subcell.parent.map;\n        }\n        if (subcell.subcells) {\n          DrilldownMap.addMapIDsToHierarchyLevel(subcell.subcells, subcell);\n        }\n        if (subcell.parent && subcell.mapID && !subcell.parent.map) {\n          if (!subcell.parent.mapID) subcell.parent.mapID = [];\n          subcell.parent.mapID = subcell.parent.mapID.concat(subcell.mapID);\n        }\n      });\n    }\n\n    /***\n     *Load map from HighMaps map collection\n     * @param source\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"loadMap\",\n    value: function loadMap(source) {\n      return new Promise(function (resolve, reject) {\n        jQuery.getScript('https://code.highcharts.com/mapdata/' + source + '.js', function () {\n          resolve(Highcharts.maps[source]);\n        });\n      });\n    }\n\n    /**\n     * Creates a single series data for HighMap series option\n     * @param {Object} level - a level in hierarchy\n     * @returns {Obejct}\n     */\n\n  }, {\n    key: \"getSeriesData\",\n    value: function getSeriesData(level) {\n      var drilldown = level.subcells ? level.text : null;\n      if (typeof level.mapID === 'string') {\n        return [{\n          'drilldown': drilldown,\n          'code': level.mapID,\n          'value': level.value\n        }];\n      } else if (Array.isArray(level.mapID)) {\n        return level.mapID.map(function (id) {\n          return {\n            'drilldown': drilldown,\n            'code': id,\n            'value': level.value\n          };\n        });\n      } else {\n        throw new Error(\"Data element is corrupted\");\n      }\n    }\n\n    /***\n     * Pick a color for mappoint\n     * @param val\n     * @param dataClasses\n     * @returns {String} point color\n     */\n\n  }, {\n    key: \"getColor\",\n    value: function getColor(val, dataClasses) {\n      var color = void 0;\n      dataClasses.forEach(function (dataClass) {\n        if (val >= dataClass.from && val < dataClass.to) {\n          color = dataClass.color;\n        }\n      });\n      return color;\n    }\n  }]);\n\n  return DrilldownMap;\n}();\n\nexports.default = DrilldownMap;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvRHJpbGxkb3duTWFwLmpzP2UwMjkiXSwibmFtZXMiOlsiRHJpbGxkb3duTWFwIiwiaGllcmFyY2h5IiwiaW5pdE1hcCIsImNvbnRhaW5lcklEIiwibWFwcG9pbnRDYWxsYmFjayIsImRhdGFDbGFzc2VzIiwiZnJvbSIsInRvIiwiY29sb3IiLCJuYW1lIiwib3B0aW9ucyIsIlR5cGVFcnJvciIsImNvbmZpZyIsIm1peGluIiwiY29sb3JBeGlzIiwiSGlnaGNoYXJ0cyIsInVuZGVmaW5lZCIsIkVycm9yIiwibWFwcyIsImNvbnN0cnVjdG9yIiwiYWRkTWFwSURzVG9IaWVyYXJjaHlMZXZlbCIsImRyYXdNYXAiLCJjdXJMVkwiLCJzZXJpZXMiLCJzdWJjZWxscyIsImZvckVhY2giLCJzdWJjZWxsIiwibWFwSUQiLCJzZXJpZXNJdGVtIiwiY29tcG9zZVNlcmllcyIsInB1c2giLCJtYXBEYXRhIiwiY2hhcnQiLCJtYXBUcmFuc2Zvcm1zIiwicG9zIiwiZnJvbUxhdExvblRvUG9pbnQiLCJsYXQiLCJjb29yZGluYXRlcyIsImxvbiIsInR5cGUiLCJ0ZXh0IiwibWFya2VyIiwibGluZUNvbG9yIiwibGluZVdpZHRoIiwicmFkaXVzIiwic3ltYm9sIiwiZGF0YSIsImdldENvbG9yIiwidmFsdWUiLCJ4IiwieSIsImV2ZW50cyIsImNsaWNrIiwiZ2VvanNvbiIsImNyZWF0ZUN1c3RvbUdlb0pTT04iLCJ0b29sdGlwIiwicG9pbnRGb3JtYXQiLCJhbGxBcmVhcyIsInBhcmVudCIsImpvaW5CeSIsImdldFNlcmllc0RhdGEiLCJnZXRDb29yZGluYXRlU2VyaWVzIiwiZSIsImZpbHRlciIsImVsIiwicG9pbnQiLCJtYXAiLCJsb2FkTWFwIiwidGhlbiIsImFkZFNlcmllcyIsImlzR2xvYmFsIiwiZGF0YUl0ZW0iLCJkcmlsbGRvd24iLCJhZGRTaW5nbGVTZXJpZXNBc0RyaWxsZG93biIsImFwcGx5RHJpbGxkb3duIiwiYWRkU2VyaWVzQXNEcmlsbGRvd24iLCJzZWxmIiwibGFuZyIsImRyaWxsVXBUZXh0IiwidGl0bGUiLCJsZWdlbmQiLCJlbmFibGVkIiwibWFwTmF2aWdhdGlvbiIsInN1YnRpdGxlIiwiYWxpZ24iLCJ0YXJnZXQiLCJ1cGRhdGVNYXAiLCJ1cGRhdGUiLCJkcmlsbHVwYWxsIiwibWFwQ2hhcnQiLCJjb3VudHJpZXNMaXN0IiwibWFwTmFtZSIsInZlcnNpb24iLCJjb3B5cmlnaHQiLCJjb3B5cmlnaHRTaG9ydCIsImNvcHlyaWdodFVybCIsImNycyIsInByb3BlcnRpZXMiLCJkZWZhdWx0Iiwic2NhbGUiLCJqc29ucmVzIiwianNvbm1hcmdpblgiLCJqc29ubWFyZ2luWSIsInhvZmZzZXQiLCJ5b2Zmc2V0IiwiZmVhdHVyZXMiLCJnZXRGZWF0dXJlcyIsImtleSIsImZlYXR1cmUiLCJBcnJheSIsImlzQXJyYXkiLCJpbmRleE9mIiwiTWF0aCIsInJhbmRvbSIsImNvbmNhdCIsInNvdXJjZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwialF1ZXJ5IiwiZ2V0U2NyaXB0IiwibGV2ZWwiLCJpZCIsInZhbCIsImRhdGFDbGFzcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztJQUVNQSxZOztBQUVKOzs7Ozs7OztBQVFBLDBCQWVtQjtBQUFBLG1GQUFILEVBQUc7QUFBQSxRQWZOQyxTQWVNLFFBZk5BLFNBZU07QUFBQSw0QkFmS0MsT0FlTDtBQUFBLFFBZktBLE9BZUwsZ0NBZmEsdUJBZWI7QUFBQSxRQWZzQ0MsV0FldEMsUUFmc0NBLFdBZXRDO0FBQUEsUUFmbURDLGdCQWVuRCxRQWZtREEsZ0JBZW5EO0FBQUEsZ0NBZnFFQyxXQWVyRTtBQUFBLFFBZnFFQSxXQWVyRSxvQ0FmbUYsQ0FBQztBQUNyR0MsWUFBTSxFQUQrRjtBQUVyR0MsVUFBSSxHQUZpRztBQUdyR0MsYUFBTyxTQUg4RjtBQUlyR0MsWUFBTTtBQUorRixLQUFELEVBS3BHO0FBQ0FILFlBQU0sRUFETjtBQUVBQyxVQUFJLEVBRko7QUFH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WixDQUFnQixjQUFLO0FBQzFCLGlCQUFPO0FBQ0wseUJBQWFNLFNBRFI7QUFFTCxvQkFBUWtELEVBRkg7QUFHTCxxQkFBU0QsTUFBTXpFO0FBSFYsV0FBUDtBQUtELFNBTk0sQ0FBUDtBQU9ELE9BUk0sTUFRQTtBQUNMLGNBQU0sSUFBSS9CLEtBQUosQ0FBVSwyQkFBVixDQUFOO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7OzZCQU1nQjBHLEcsRUFBS3RILFcsRUFBWTtBQUMvQixVQUFJRyxjQUFKO0FBQ0FILGtCQUFZb0IsT0FBWixDQUFvQixxQkFBWTtBQUM5QixZQUFHa0csT0FBT0MsVUFBVXRILElBQWpCLElBQXlCcUgsTUFBTUMsVUFBVXJILEVBQTVDLEVBQWdEO0FBQzlDQyxrQkFBUW9ILFVBQVVwSCxLQUFsQjtBQUNEO0FBQ0YsT0FKRDtBQUtBLGFBQU9BLEtBQVA7QUFDRDs7Ozs7O2tCQXlLWVIsWSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlcG9ydGFsQmFzZSBmcm9tIFwici1yZXBvcnRhbC1iYXNlXCI7XG5cbmNsYXNzIERyaWxsZG93bk1hcCB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBkcmlsbGRvd24gbWFwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoaWVyYXJjaHkgLSBhIGhpZXJhcmNoaWNhbCBvYmplY3QgZm9yIGEgbWFwIHRvIGJlIGJ1aWx0IHVwb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRhaW5lcklEIC0gaWQgb2YgdGhlIGNvbnRhaW5lciB0aGUgbWFwIHdpbGwgYmUgZHJhd24gdG9cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWFwcG9pbnRDYWxsYmFjayAtIGV4ZWN1dGVkIHdoZW4gYSBtYXBwb2ludCAoY2l0eSkgaXMgY2xpY2tlZFxuICAgKiBAcGFyYW0ge0FycmF5Ljx7ZnJvbTpOdW1iZXIsIHRvOk51bWJlciwgY29sb3I6U3RyaW5nLCBuYW1lOlN0cmluZ30+fSBkYXRhQ2xhc3NlcyAtIGNvbG9yIGJhbmRzIGZvciBjb25kaXRpb25hbCBmb3JtYXR0aW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBwYXNzZWQgdG8gSGlnaE1hcCB0byByZXN0eWxlL2NvbmZpZ3VyZSBpdFxuICAgKiAqL1xuICBjb25zdHJ1Y3Rvcih7aGllcmFyY2h5LCBpbml0TWFwPVwiY3VzdG9tL3dvcmxkLWhpZ2hyZXMyXCIsIGNvbnRhaW5lcklELCBtYXBwb2ludENhbGxiYWNrLCBkYXRhQ2xhc3NlcyA9IFt7XG4gICAgZnJvbTogODAsXG4gICAgdG86IDEwMCxcbiAgICBjb2xvcjogJyM4YmMzNGEnLFxuICAgIG5hbWU6ICdQcm9tb3RlcidcbiAgfSx7XG4gICAgZnJvbTogNjAsXG4gICAgdG86IDgwLFxuICAgIGNvbG9yOiAnI2ZmYzEwNycsXG4gICAgbmFtZTogJ1Bhc3NpdmUnXG4gIH0se1xuICAgIGZyb206IDAsXG4gICAgdG86IDYwLFxuICAgIGNvbG9yOiAnI2Y0NDMzNicsXG4gICAgbmFtZTogJ0RldHJhY3RvcidcbiAgfV0sIG9wdGlvbnM9e319PXt9KXtcblxuICAgIGlmKG1hcHBvaW50Q2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgbWFwcG9pbnRDYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMubWFwcG9pbnRDYWxsYmFjayA9IG1hcHBvaW50Q2FsbGJhY2tcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJtYXBwb2ludENhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvblwiKVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZyA9IFJlcG9ydGFsQmFzZS5taXhpbihvcHRpb25zLCB7Y29sb3JBeGlzOntkYXRhQ2xhc3Nlc319KTtcbiAgICBpZih0eXBlb2YgSGlnaGNoYXJ0cyA9PSB1bmRlZmluZWQpe3Rocm93IG5ldyBFcnJvcignSGlnaGNoYXJ0cyBtdXN0IGJlIGRlY2xhcmVkLiBQcm9iYWJseSB0aGV5IGFyZSBtaXNzaW5nJyl9O1xuICAgIGlmKHR5cGVvZiBIaWdoY2hhcnRzLm1hcHMgPT0gdW5kZWZpbmVkKXt0aHJvdyBuZXcgRXJyb3IoJ0hpZ2hNYXBzIG11c3QgYmUgbG9hZGVkLiBQcm9iYWJseSB0aGV5IGFyZSBtaXNzaW5nJyl9O1xuICAgIHRoaXMuY29uc3RydWN0b3IuYWRkTWFwSURzVG9IaWVyYXJjaHlMZXZlbChoaWVyYXJjaHkpO1xuICAgIC8vXG4gICAgdGhpcy5kcmF3TWFwKGhpZXJhcmNoeSwgY29udGFpbmVySUQsIGluaXRNYXAsIGNvbmZpZyk7XG4gIH1cblxuICAvKioqXG4gICAqIENyZWF0ZXMgY3VzdG9tIGdlb0pTT04gZmlsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwRGF0YSAtIGluaXRpYWwgbWFwXG4gICAqIEBwYXJhbSB7QXJyYXl9Y291bnRyaWVzTGlzdCAtIGxpc3Qgb2YgY291bnRyaWVzIElEc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWFwTmFtZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUN1c3RvbUdlb0pTT04obWFwRGF0YSwgY291bnRyaWVzTGlzdCwgbWFwTmFtZSkge1xuICAgIGxldCBnZW9qc29uID0ge1xuICAgICAgdGl0bGU6XCJcIixcbiAgICAgIHZlcnNpb246XCIwLjEuMFwiLFxuICAgICAgdHlwZTpcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gICAgICBjb3B5cmlnaHQ6XCJDb3B5cmlnaHQgKGMpIDIwMTUgSGlnaHNvZnQgQVMsIEJhc2VkIG9uIGRhdGEgZnJvbSBOYXR1cmFsIEVhcnRoXCIsXG4gICAgICBjb3B5cmlnaHRTaG9ydDpcIk5hdHVyYWwgRWFydGhcIixcbiAgICAgIGNvcHlyaWdodFVybDpcImh0dHA6Ly93d3cubmF0dXJhbGVhcnRoZGF0YS5jb21cIixcbiAgICAgIGNyczp7XG4gICAgICAgIHR5cGU6XCJuYW1lXCIsXG4gICAgICAgIHByb3BlcnRpZXM6e1xuICAgICAgICAgIG5hbWU6XCJ1cm46b2djOmRlZjpjcnM6RVBTRzo1NDAwM1wiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImhjLXRyYW5zZm9ybVwiOntcbiAgICAgICAgZGVmYXVsdDp7XG4gICAgICAgICAgY3JzOlwiK3Byb2o9bWlsbCArbGF0XzA9MCArbG9uXzA9MCAreF8wPTAgK3lfMD0wICtSX0EgK2RhdHVtPVdHUzg0ICt1bml0cz1tICtub19kZWZzXCIsXG4gICAgICAgICAgc2NhbGU6MS43MjE4Mjc4MTY1NGUtMDUsXG4gICAgICAgICAganNvbnJlczoxNS41LFxuICAgICAgICAgIGpzb25tYXJnaW5YOi05OTksXG4gICAgICAgICAganNvbm1hcmdpblk6OTg1MS4wLFxuICAgICAgICAgIHhvZmZzZXQ6LTE5NDk1MzU2LjM2OTMsXG4gICAgICAgICAgeW9mZnNldDoxMjYzNTkwOC4xOTgyXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmZWF0dXJlczogRHJpbGxkb3duTWFwLmdldEZlYXR1cmVzKGNvdW50cmllc0xpc3QsbWFwRGF0YSkvL1tbXV1cbiAgICB9O1xuXG4gICAgZ2VvanNvbi50aXRsZSA9IG1hcE5hbWU7XG4gICAgcmV0dXJuIGdlb2pzb247XG4gIH1cblxuICAvKioqXG4gICAqIEdldCBhcnJheSBvZiBmZWF0dXJlcyBmcm9tIGdlb0pTT04gZmlsZVxuICAgKiBAcGFyYW0ge0FycmF5IHwgU3RyaW5nfWNvdW50cmllc0xpc3QgLSBjb3VudHJpZXMgSURzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBEYXRhIC0geW91ciBpbml0aWFsIG1hcFxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IGZvciBnZW9qc29uIGZlYXR1cmVzIGNvbXBhcmluZ1xuICAgKiBAcmV0dXJucyB7QXJyYXl9IGZlYXR1cmVzIGxpc3RcbiAgICovXG4gIHN0YXRpYyBnZXRGZWF0dXJlcyhjb3VudHJpZXNMaXN0LG1hcERhdGEsa2V5PVwiaGMta2V5XCIpe1xuICAgIGlmICh0eXBlb2YgY291bnRyaWVzTGlzdCA9PT0gJ3N0cmluZycpe1xuICAgICAgcmV0dXJuIG1hcERhdGEuZmVhdHVyZXMuZmlsdGVyKGZlYXR1cmUgPT4gZmVhdHVyZS5wcm9wZXJ0aWVzW2tleV0gPT09IGNvdW50cmllc0xpc3QpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb3VudHJpZXNMaXN0KSl7XG4gICAgICByZXR1cm4gbWFwRGF0YS5mZWF0dXJlcy5maWx0ZXIoZmVhdHVyZSA9PiBjb3VudHJpZXNMaXN0LmluZGV4T2YoZmVhdHVyZS5wcm9wZXJ0aWVzW2tleV0pIT0tMSk7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogR2V0IHNlcmllcyBmb3IgdGhlIGZpcnN0IHRpbWUgbWFwIGluaXRpYWxpemF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjdXJMVkwgLSBjdXJyZW50IGxldmVsIGluIGhpZXJhcmNoeVxuICAgKiBAcGFyYW0ge0FycmF5fSBbc2VyaWVzPVtdXSAtIHNlcmllc1xuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqICovXG4gICBpbml0TWFwKGN1ckxWTCwgc2VyaWVzID0gW10pe1xuICAgIGN1ckxWTC5zdWJjZWxscy5mb3JFYWNoKCBzdWJjZWxsID0+IHtcbiAgICAgIGlmIChzdWJjZWxsLm1hcElEKSB7XG4gICAgICAgIGxldCBzZXJpZXNJdGVtID0gdGhpcy5jb21wb3NlU2VyaWVzKHN1YmNlbGwpO1xuICAgICAgICBzZXJpZXMucHVzaChzZXJpZXNJdGVtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VyaWVzO1xuICB9XG5cbiAgLyoqKlxuICAgKiBVcGRhdGVzIGluaXRpYWwgaGllcmFyY2h5XG4gICAqIEBwYXJhbSBoaWVyYXJjaHlcbiAgICogQHBhcmFtIHBhcmVudCAtIGhpZXJhcmNoeSBsZXZlbCBwYXJlbnRcbiAgICovXG4gIHN0YXRpYyBhZGRNYXBJRHNUb0hpZXJhcmNoeUxldmVsKGhpZXJhcmNoeSwgcGFyZW50ID0gbnVsbCkge1xuICAgIGhpZXJhcmNoeS5mb3JFYWNoKHN1YmNlbGwgPT4ge1xuICAgICAgc3ViY2VsbC5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICBzdWJjZWxsLnZhbHVlID0gTWF0aC5yYW5kb20oKSoxMDA7XG4gICAgICBpZihzdWJjZWxsLnBhcmVudCAmJiBzdWJjZWxsLnBhcmVudCE9bnVsbCAmJiBzdWJjZWxsLnBhcmVudC5tYXApe1xuICAgICAgICBzdWJjZWxsLm1hcCA9IHN1YmNlbGwucGFyZW50Lm1hcDtcbiAgICAgIH1cbiAgICAgIGlmIChzdWJjZWxsLnN1YmNlbGxzKSB7XG4gICAgICAgIERyaWxsZG93bk1hcC5hZGRNYXBJRHNUb0hpZXJhcmNoeUxldmVsKHN1YmNlbGwuc3ViY2VsbHMsIHN1YmNlbGwpO1xuICAgICAgfVxuICAgICAgaWYoc3ViY2VsbC5wYXJlbnQgJiYgc3ViY2VsbC5tYXBJRCAmJiAhc3ViY2VsbC5wYXJlbnQubWFwKXtcbiAgICAgICAgaWYoIXN1YmNlbGwucGFyZW50Lm1hcElEKVxuICAgICAgICAgIHN1YmNlbGwucGFyZW50Lm1hcElEID0gW107XG4gICAgICAgIHN1YmNlbGwucGFyZW50Lm1hcElEID0gc3ViY2VsbC5wYXJlbnQubWFwSUQuY29uY2F0KHN1YmNlbGwubWFwSUQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqKlxuICAgKkxvYWQgbWFwIGZyb20gSGlnaE1hcHMgbWFwIGNvbGxlY3Rpb25cbiAgICogQHBhcmFtIHNvdXJjZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIHN0YXRpYyBsb2FkTWFwKHNvdXJjZSl7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9PntcbiAgICAgIGpRdWVyeS5nZXRTY3JpcHQoJ2h0dHBzOi8vY29kZS5oaWdoY2hhcnRzLmNvbS9tYXBkYXRhLycgKyBzb3VyY2UgKyAnLmpzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXNvbHZlKEhpZ2hjaGFydHMubWFwc1tzb3VyY2VdKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzaW5nbGUgc2VyaWVzIGRhdGEgZm9yIEhpZ2hNYXAgc2VyaWVzIG9wdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gbGV2ZWwgLSBhIGxldmVsIGluIGhpZXJhcmNoeVxuICAgKiBAcmV0dXJucyB7T2JlamN0fVxuICAgKi9cbiAgc3RhdGljIGdldFNlcmllc0RhdGEobGV2ZWwpe1xuICAgIGxldCBkcmlsbGRvd24gPSBsZXZlbC5zdWJjZWxscyA/IGxldmVsLnRleHQgOiBudWxsO1xuICAgIGlmICh0eXBlb2YgbGV2ZWwubWFwSUQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgJ2RyaWxsZG93bic6IGRyaWxsZG93bixcbiAgICAgICAgJ2NvZGUnOiBsZXZlbC5tYXBJRCxcbiAgICAgICAgJ3ZhbHVlJzogbGV2ZWwudmFsdWVcbiAgICAgIH1dXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGxldmVsLm1hcElEKSl7XG4gICAgICByZXR1cm4gbGV2ZWwubWFwSUQubWFwKGlkPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICdkcmlsbGRvd24nOiBkcmlsbGRvd24sXG4gICAgICAgICAgJ2NvZGUnOiBpZCxcbiAgICAgICAgICAndmFsdWUnOiBsZXZlbC52YWx1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBlbGVtZW50IGlzIGNvcnJ1cHRlZFwiKTtcbiAgICB9XG4gIH1cblxuICAvKioqXG4gICAqIFBpY2sgYSBjb2xvciBmb3IgbWFwcG9pbnRcbiAgICogQHBhcmFtIHZhbFxuICAgKiBAcGFyYW0gZGF0YUNsYXNzZXNcbiAgICogQHJldHVybnMge1N0cmluZ30gcG9pbnQgY29sb3JcbiAgICovXG4gIHN0YXRpYyBnZXRDb2xvcih2YWwsIGRhdGFDbGFzc2VzKXtcbiAgICBsZXQgY29sb3I7XG4gICAgZGF0YUNsYXNzZXMuZm9yRWFjaChkYXRhQ2xhc3MgPT57XG4gICAgICBpZih2YWwgPj0gZGF0YUNsYXNzLmZyb20gJiYgdmFsIDwgZGF0YUNsYXNzLnRvKSB7XG4gICAgICAgIGNvbG9yID0gZGF0YUNsYXNzLmNvbG9yO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzaW5nbGUgbWFwcG9pbnQgc2VyaWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdWJjZWxsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBEYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFydFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBzZXJpZXMgZm9yIG1hcCBwb2ludHNcbiAgICogKi9cbiAgZ2V0Q29vcmRpbmF0ZVNlcmllcyhzdWJjZWxsLG1hcERhdGEsY2hhcnQpe1xuICAgIGNoYXJ0Lm1hcFRyYW5zZm9ybXMgPSBtYXBEYXRhID8gIG1hcERhdGFbXCJoYy10cmFuc2Zvcm1cIl0gOiBIaWdoY2hhcnRzLm1hcHNbXCJjdXN0b20vd29ybGQtaGlnaHJlczJcIl1bXCJoYy10cmFuc2Zvcm1cIl07XG4gICAgbGV0IHBvcyA9IGNoYXJ0LmZyb21MYXRMb25Ub1BvaW50KHsgbGF0OiBzdWJjZWxsLmNvb3JkaW5hdGVzWzBdLCBsb246IHN1YmNlbGwuY29vcmRpbmF0ZXNbMV0gfSk7XG4gICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgIHR5cGU6IFwibWFwcG9pbnRcIiwgLy8gb3IgXCJtYXBidWJibGUsXG4gICAgICBuYW1lOiBzdWJjZWxsLnRleHQsXG4gICAgICBtYXJrZXI6IHtcbiAgICAgICAgbGluZUNvbG9yOiBcImJsYWNrXCIsXG4gICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgcmFkaXVzOiA0LFxuICAgICAgICBzeW1ib2w6IFwiY2lyY2xlXCIsXG4gICAgICB9LFxuICAgICAgZGF0YTogW3tcbiAgICAgICAgY29sb3I6IERyaWxsZG93bk1hcC5nZXRDb2xvcihzdWJjZWxsLnZhbHVlLCB0aGlzLmNvbmZpZy5jb2xvckF4aXMuZGF0YUNsYXNzZXMpLFxuICAgICAgICBuYW1lOiBzdWJjZWxsLnRleHQsXG4gICAgICAgIHZhbHVlOiBzdWJjZWxsLnZhbHVlLFxuICAgICAgICB4OiBwb3MueCxcbiAgICAgICAgeTogcG9zLnlcbiAgICAgIH1dXG4gICAgfTtcbiAgICBpZih0aGlzLm1hcHBvaW50Q2FsbGJhY2spe1xuICAgICAgY29uZmlnLmV2ZW50cyA9IHtcbiAgICAgICAgY2xpY2s6IHRoaXMubWFwcG9pbnRDYWxsYmFja1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29uZmlnXG4gIH1cblxuICAvKioqXG4gICAqIENyZWF0ZXMgYSBzaW5nbGUgc2VyaWVzIGZvciBIaWdobWFwcyBzZXJpZXMgb3B0aW9uXG4gICAqIEBwYXJhbSBzdWJjZWxsXG4gICAqIEBwYXJhbSBtYXBEYXRhXG4gICAqIEBwYXJhbSBjaGFydFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgY29tcG9zZVNlcmllcyhzdWJjZWxsLG1hcERhdGEsY2hhcnQpe1xuICAgIGlmKCFzdWJjZWxsLmNvb3JkaW5hdGVzKSB7XG4gICAgICBtYXBEYXRhID0gbWFwRGF0YSA/IEhpZ2hjaGFydHMuZ2VvanNvbihEcmlsbGRvd25NYXAuY3JlYXRlQ3VzdG9tR2VvSlNPTihtYXBEYXRhLCBzdWJjZWxsLm1hcElELCBzdWJjZWxsLnRleHQpKSA6IEhpZ2hjaGFydHMuZ2VvanNvbihEcmlsbGRvd25NYXAuY3JlYXRlQ3VzdG9tR2VvSlNPTihIaWdoY2hhcnRzLm1hcHNbJ2N1c3RvbS93b3JsZC1oaWdocmVzMiddLCBzdWJjZWxsLm1hcElELCBzdWJjZWxsLnRleHQpKTtcbiAgICAgIGlmIChzdWJjZWxsLm1hcElEKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogc3ViY2VsbC50ZXh0LFxuICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIHBvaW50Rm9ybWF0OiAnTlBTIDoge3BvaW50LnZhbHVlfSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFsbEFyZWFzOiBmYWxzZSxcbiAgICAgICAgICBwYXJlbnQ6IHN1YmNlbGwucGFyZW50LnRleHQsXG4gICAgICAgICAgbWFwRGF0YSxcbiAgICAgICAgICBqb2luQnk6IFsnaGMta2V5JywgJ2NvZGUnXSxcbiAgICAgICAgICBkYXRhOiBEcmlsbGRvd25NYXAuZ2V0U2VyaWVzRGF0YShzdWJjZWxsKSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge3JldHVybiB0aGlzLmdldENvb3JkaW5hdGVTZXJpZXMoc3ViY2VsbCxtYXBEYXRhLGNoYXJ0KX1cbiAgfVxuXG4gIC8qKipcbiAgICogVXBkYXRlcyB5b3VyIG1hcCB2aWV3IGFmdGVyIGRyaWxsZG93biBjbGlja1xuICAgKiBAcGFyYW0ge09iamVjdH0gY3VyTFZMXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFydFxuICAgKiBAcGFyYW0ge09iamVjdH0gZSAtIGRyaWxsZG93biBldmVudCBvYmplY3RcbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBjdXJMVkxcbiAgICovXG4gIHVwZGF0ZU1hcChjdXJMVkwsIGNoYXJ0LCBlKXtcbiAgICBjdXJMVkwgPSBjdXJMVkwuc3ViY2VsbHMuZmlsdGVyKCBlbCA9PiBlbC50ZXh0ID09IGUucG9pbnQuc2VyaWVzLm5hbWUpWzBdO1xuICAgIGlmKGN1ckxWTCAmJiBjdXJMVkwubWFwKXsvLyBpZiB3ZSBoYXZlIGFub3RoZXIgbWFwIHRvIGxvYWRcbiAgICAgIGxldCBtYXAgPSBEcmlsbGRvd25NYXAubG9hZE1hcChjdXJMVkwubWFwKTtcbiAgICAgIG1hcC50aGVuKG1hcERhdGE9PntcbiAgICAgICAgdGhpcy5hZGRTZXJpZXMoY3VyTFZMLGNoYXJ0LGUsbWFwRGF0YSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZihjdXJMVkwgJiYgIWN1ckxWTC5tYXApe1xuICAgICAgdGhpcy5hZGRTZXJpZXMoY3VyTFZMLGNoYXJ0LGUpO1xuICAgIH1cbiAgICByZXR1cm4gY3VyTFZMO1xuICB9XG5cbiAgLyoqKlxuICAgKiBDb21wb3NlcyBhIHNlcmllcyBmb3IgeW91ciBIaWdoTWFwcyBvcHRpb25zIGNvbmZpZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gY3VyTFZMXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFydFxuICAgKiBAcGFyYW0ge09iamVjdH0gZSAtIGRyaWxsZG93biBldmVudCBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcERhdGEgLSBtYXBEYXRhIGdlb0pTT05cbiAgICovXG4gICBhZGRTZXJpZXMoY3VyTFZMLGNoYXJ0LGUsbWFwRGF0YSl7XG4gICAgaWYgKGN1ckxWTC5zdWJjZWxscyAmJiBjdXJMVkwuaXNHbG9iYWwpIHsgLy8gaWYgaXQncyBhbiBlbmQgcG9pbnRcbiAgICAgIGlmKGN1ckxWTC5zdWJjZWxsc1swXS5jb29yZGluYXRlcyl7XG4gICAgICAgIGxldCBzZXJpZXNJdGVtID0gdGhpcy5jb21wb3NlU2VyaWVzKGN1ckxWTCxtYXBEYXRhLCBjaGFydCk7XG4gICAgICAgIHNlcmllc0l0ZW0uZGF0YS5mb3JFYWNoKGRhdGFJdGVtID0+IHtcbiAgICAgICAgICBkYXRhSXRlbS5kcmlsbGRvd24gPSBudWxsO1xuICAgICAgICAgIGRhdGFJdGVtLnZhbHVlID0gbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgY2hhcnQuYWRkU2luZ2xlU2VyaWVzQXNEcmlsbGRvd24oZS5wb2ludCwgc2VyaWVzSXRlbSk7XG4gICAgICB9XG4gICAgICBjdXJMVkwuc3ViY2VsbHMuZm9yRWFjaChzdWJjZWxsID0+IHtcbiAgICAgICAgaWYoIXN1YmNlbGwubWFwSUQgJiYgIXN1YmNlbGwuY29vcmRpbmF0ZXMpIHJldHVybjtcblxuICAgICAgICBsZXQgc2VyaWVzSXRlbSA9IHRoaXMuY29tcG9zZVNlcmllcyhzdWJjZWxsLG1hcERhdGEsIGNoYXJ0KTtcbiAgICAgICAgY2hhcnQuYWRkU2luZ2xlU2VyaWVzQXNEcmlsbGRvd24oZS5wb2ludCwgc2VyaWVzSXRlbSk7XG4gICAgICB9KTtcbiAgICAgIGNoYXJ0LmFwcGx5RHJpbGxkb3duKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBzZXJpZXNJdGVtID0gdGhpcy5jb21wb3NlU2VyaWVzKGN1ckxWTCwgbWFwRGF0YSwgY2hhcnQpO1xuICAgICAgc2VyaWVzSXRlbS5kYXRhLm1hcChkYXRhSXRlbSA9PiB7XG4gICAgICAgIGRhdGFJdGVtLmRyaWxsZG93biA9IG51bGw7XG4gICAgICAgIGRhdGFJdGVtLnZhbHVlID0gbnVsbFxuICAgICAgfSk7XG4gICAgICBjaGFydC5hZGRTZXJpZXNBc0RyaWxsZG93bihlLnBvaW50LCBzZXJpZXNJdGVtKTtcbiAgICB9XG4gIH1cblxuICAvKioqXG4gICAqIEBwYXJhbSBoaWVyYXJjaHlcbiAgICogQHBhcmFtIGNvbnRhaW5lcklEXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBkcmF3TWFwKGhpZXJhcmNoeSwgY29udGFpbmVySUQsIGluaXRNYXAsIG9wdGlvbnMpe1xuICAgIGxldCBjdXJMVkwgPSBoaWVyYXJjaHlbMF07XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBjb25maWcgPSB7XG4gICAgICBsYW5nOiB7XG4gICAgICAgIGRyaWxsVXBUZXh0OiAnQmFjayB0byB7c2VyaWVzLnBhcmVudH0nXG4gICAgICB9LFxuICAgICAgdG9vbHRpcDoge1xuICAgICAgICBwb2ludEZvcm1hdDogJ05QUyA6IHtwb2ludC52YWx1ZX0nXG4gICAgICB9LFxuICAgICAgdGl0bGU6IHtcbiAgICAgICAgdGV4dDogJ0RyaWxsZG93biBtYXAnXG4gICAgICB9LFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgbWFwTmF2aWdhdGlvbjoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIHN1YnRpdGxlOntcbiAgICAgICAgYWxpZ246ICdyaWdodCcsXG4gICAgICAgIHRleHQ6IGBDdXJyZW50IGxldmVsOiAke2N1ckxWTC50ZXh0fSA8YnI+IFJlZ2lvbiBOUFM6ICR7Y3VyTFZMLnZhbHVlfWBcbiAgICAgIH0sXG4gICAgICBjaGFydDp7XG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIGRyaWxsZG93bjogZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAvL1RPRE86IGFkZCBkYXRhIHByb21pc2U7XG4gICAgICAgICAgICBsZXQgY2hhcnQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgIGN1ckxWTCA9IHNlbGYudXBkYXRlTWFwKGN1ckxWTCwgY2hhcnQsIGUpO1xuICAgICAgICAgICAgY2hhcnQuc3VidGl0bGUudXBkYXRlKHt0ZXh0OiBgQ3VycmVudCByZWdpb246ICR7Y3VyTFZMLnRleHR9PGJyPiBSZWdpb24gTlBTOiAke2N1ckxWTC52YWx1ZX1gfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkcmlsbHVwYWxsOiBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgIGN1ckxWTCA9IGN1ckxWTC5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoY3VyTFZMKVxuICAgICAgICAgICAgICBjaGFydC5zdWJ0aXRsZS51cGRhdGUoe3RleHQ6IGBDdXJyZW50IGxldmVsOiAke2N1ckxWTC50ZXh0fSA8YnI+IFJlZ2lvbiBOUFM6ICR7Y3VyTFZMLnZhbHVlfWB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXJpZXM6IHRoaXMuaW5pdE1hcChjdXJMVkwsW3tcbiAgICAgICAgbWFwRGF0YTogSGlnaGNoYXJ0cy5tYXBzW2luaXRNYXBdXG4gICAgICB9XSlcbiAgICB9O1xuICAgIGNvbmZpZyA9IFJlcG9ydGFsQmFzZS5taXhpbihjb25maWcsb3B0aW9ucyk7XG4gICAgSGlnaGNoYXJ0cy5tYXBDaGFydCggY29udGFpbmVySUQsIGNvbmZpZyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRHJpbGxkb3duTWFwO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0RyaWxsZG93bk1hcC5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }
/******/ ]);