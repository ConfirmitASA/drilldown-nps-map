{"version":3,"sources":["webpack:///drilldown-nps-map.bundle.js","webpack:///webpack/bootstrap 716e597abd2d79e91fd3","webpack:///./src/main.js","webpack:///./~/r-reportal-base/src/reportal-base.js","webpack:///./~/r-aggregated-table/src/table-data.js","webpack:///./~/r-aggregated-table/src/aggregated-table-row-meta.js","webpack:///./~/r-aggregated-table/src/aggregated-table.js","webpack:///./~/r-aggregated-table/src/main.js","webpack:///./~/r-async-hierarchy-table/src/main.js","webpack:///./~/r-sort-table/src/sort-order.js","webpack:///./~/r-sort-table/src/sort-table.js","webpack:///./~/r-sort-table/src/table-columns.js","webpack:///./~/r-table-columns/src/main.js","webpack:///./~/r-table-columns/src/table-columns.js","webpack:///./~/r-table-floating-header/src/table-floating-header.js","webpack:///./src/DrilldownMap.js","webpack:///./src/map-hierarchy.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_DrilldownMap","_DrilldownMap2","_rReportalBase","_rReportalBase2","window","Reportal","mixin","DrilldownMap","ReportalBase","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","this","source","level","args","Array","isArray","console","apply","slice","arguments","_logger","name","event","document","createEvent","initEvent","str","isNaN","parseFloat","replace","URL","Promise","resolve","reject","xhr","XMLHttpRequest","open","onload","e","status","responseText","Error","statusText","onerror","send","variable","query","undefined","location","search","substring","vars","split","pair","toLowerCase","_typeof","Symbol","iterator","constructor","TableData","multidimensional","blocks","parentNode","querySelectorAll","forEach","blockCell","classList","add","cell","rowIndex","columnIndex","isNumber","textContent","trim","options","_this","_options$excludeBlock","excludeBlock","excludeColumns","excludeRows","_options$direction","direction","_options$multidimensi","data","tagName","rows","tempArray","splice","sort","a","b","reverse","row","contains","push","cells","children","temp_excludeColumns","index","rowSpan","prepareDataCell","realIndex","AggregatedTableRowMeta","_ref","_ref$id","nameCell","_ref$block","block","firstInBlock","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","_tableData","_tableData2","_rTableColumns","_rTableColumns2","_sortTable","_sortTable2","_tableFloatingHeader","_tableFloatingHeader2","AggregatedTable","_TableData","defaultHeaderRow","rowheaderColumnIndex","dataStripDirection","sorting","floatingHeader","getPrototypeOf","refSource","header","detectMultidimensional","getData","reorderFunction","reorderRows","addEventListener","columns","fragment","createDocumentFragment","dimensionalDataIterator","dataDimension","repositionBlockCell","item","appendChild","querySelector","items","blockRowItem","filter","blockRow","indexOf","newFirstRow","insertBefore","firstElementChild","remove","callback","dimension","_aggregatedTable","_aggregatedTable2","_aggregatedTableRowMeta","_aggregatedTableRowMeta2","AsyncHierarchyTable","hierarchyID","hierarchyControlID","pageStateID","languageCode","path","origin","getQueryVariable","encode","IsPreview","HierarchyControlId","hierarchyItemChildren","promiseRequest","join","then","response","JSON","parse","parentID","tableID","NodeId","Text","tableResult","host","createElement","innerHTML","table","excludedRows","toEncode","encodeURIComponent","stringify","SortOrder","sortCallback","_options$defaultSorti","defaultSorting","_options$sortCallback","sortCallbackScope","sortOrder","refCell","getCell","column","className","_this2","_this3","_toArray","arr","from","_tableColumns","_tableColumns2","_sortOrder","_sortOrder2","SortTable","_ref$sortOrder","_options$defaultHeade","included","excluded","_options$data","_sortEvent","newEvent","sortableColumns","defineSortableColumns","src","listenForSort","getHeader","so","sortDimension","dispatchEvent","sortable","delegatedTarget","clickedColumn","getIndex","getDirection","sorter","lesser","regex","test","tempEl1","tempEl2","TableColumns","thead","refThead","computeColumns","defaultHeaderRowIndex","headerRows","headerRowIndex","_ret","getDefaultHeaderRow","rowsLength","abstr","_loop","r","augmentIndex","rs","rowA","colSpan","v","keys","map","k","theadCells","getHeaderCells","refTheadCells","realColumnIndex","title","TableFloatingHeader","wrapTable","cloneHeader","visible","_meta","lastScrollY","sourceTHEAD","ticking","requestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","msRequestAnimationFrame","resizeFixed","scrollFixed","requestTick","_resizeCallback","bind","pageYOffset","_scrollCallback","tableOffsetTop","offsetTop","tableOffsetBottom","offsetHeight","style","display","wrapper","cloneNode","child","nodeName","removeChild","initialHeader","clonedHeader","headerWidth","offsetWidth","widths","width","calcOffsetHeight","offset","setVisibility","top","_rAsyncHierarchyTable","_rAsyncHierarchyTable2","_mapHierarchy","_mapHierarchy2","_rAggregatedTable","_rAggregatedTable2","_MapHierarchy","config","rowheaders","hierarchy","_config$initMap","initMap","containerID","_config$pageStateId","mappointCallback","valueColumn","fullParentLevelInfo","colorFn","pageStateId","normals","_config$normalsSepara","normalsSeparator","_config$options","declareGlobals","typeCheck","parseTableData","drawMap","defaults","prop","opts","Highcharts","maps","localName","cb","flatHierarchy","aggregatedTable","rowHeadersAreValid","rowHeader","_data","dataItem","curLVL","series","subcells","subcell","mapID","seriesItem","composeSeries","_this4","drilldown","text","code","getPrimaryValue","mapData","chart","_this5","mapTransforms","pos","fromLatLonToPoint","lat","coordinates","lon","type","marker","lineColor","lineWidth","radius","symbol","color","computeColor","x","y","events","click","getCoordinateSeries","geojson","createCustomGeoJSON","dataLabels","enabled","formatter","point","tooltip","pointFormat","getTooltip","allAreas","parent","joinBy","getSeriesData","_this6","mapName","loadMap","addSeries","_this7","addSingleSeriesAsDrilldown","applyDrilldown","addSeriesAsDrilldown","lang","drillUpText","legend","plotOptions","states","normal","animation","mouseOver","el","setState","mouseOut","mapNavigation","buttons","zoomIn","verticalAlign","zoomOut","subtitle","align","floating","drillUpButton","position","relativeTo","getLevelByName","showLoading","fetchChildTable","lvl","updateMap","update","hideLoading","drillupall","showInLegend","mapChart","get","countriesList","version","copyright","copyrightShort","copyrightUrl","crs","properties","hc-transform","scale","jsonres","jsonmarginX","jsonmarginY","xoffset","yoffset","features","getFeatures","feature","jQuery","getScript","MapHierarchy","processHierarchy","addMapIDsToHierarchyLevel","orphans","toNormalize","normalize","o","separator","parser","stringArray","val","numberArray","string","number","boolean","concat"],"mappings":"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","file":"drilldown-nps-map.bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _DrilldownMap = __webpack_require__(13);\n\t\n\tvar _DrilldownMap2 = _interopRequireDefault(_DrilldownMap);\n\t\n\tvar _rReportalBase = __webpack_require__(1);\n\t\n\tvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\twindow.Reportal = window.Reportal || {};\n\t_rReportalBase2.default.mixin(window.Reportal, {\n\t  DrilldownMap: _DrilldownMap2.default,\n\t  ReportalBase: _rReportalBase2.default\n\t});\n\t\n\texports.default = _DrilldownMap2.default;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar ReportalBase = function () {\n\t  function ReportalBase() {\n\t    _classCallCheck(this, ReportalBase);\n\t  }\n\t\n\t  _createClass(ReportalBase, null, [{\n\t    key: 'mixin',\n\t\n\t\n\t    /**\n\t     * Copies props from a source object to a target object.\n\t     *\n\t     * Note, this method uses a simple `for...in` strategy for enumerating\n\t     * properties.  To ensure only `ownProperties` are copied from source\n\t     * to target and that accessor implementations are copied, use `extend`.\n\t     *\n\t     * @method mixin\n\t     * @param {Object} target Target object to copy properties to.\n\t     * @param {Object} source Source object to copy properties from.\n\t     * @return {Object} Target object that was passed as first argument.\n\t     */\n\t    value: function mixin(target, source) {\n\t      for (var i in source) {\n\t        target[i] = source[i];\n\t      }\n\t      return target;\n\t    }\n\t  }, {\n\t    key: '_logger',\n\t    value: function _logger(level, args) {\n\t      // accept ['foo', 'bar'] and [['foo', 'bar']]\n\t      if (args.length === 1 && Array.isArray(args[0])) {\n\t        args = args[0];\n\t      }\n\t      // only accept logging functions\n\t      switch (level) {\n\t        case 'log':\n\t        case 'warn':\n\t        case 'error':\n\t          console[level].apply(console, args);\n\t          break;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_log',\n\t    value: function _log() {\n\t      var args = Array.prototype.slice.call(arguments, 0);\n\t      this._logger('log', args);\n\t    }\n\t  }, {\n\t    key: '_warn',\n\t    value: function _warn() {\n\t      var args = Array.prototype.slice.call(arguments, 0);\n\t      this._logger('warn', args);\n\t    }\n\t  }, {\n\t    key: '_error',\n\t    value: function _error() {\n\t      var args = Array.prototype.slice.call(arguments, 0);\n\t      this._logger('error', args);\n\t    }\n\t\n\t    /**\n\t     * Creates a named event with `name`\n\t     * @param {String} name - name of the event\n\t     * @return {Event} Returns a created event\n\t     * */\n\t\n\t  }, {\n\t    key: 'newEvent',\n\t    value: function newEvent(name) {\n\t      var event = document.createEvent('Event');\n\t      event.initEvent(name, true, true);\n\t      return event;\n\t    }\n\t\n\t    /**\n\t     * Inspects if the current string might be converted to number and renders it as number. If string length is 0, returns `null`. If none applies returns the string as is.\n\t     * @param {String} str - value of the cell if not HTML contents\n\t     * @return {Number|null|String}\n\t     * */\n\t\n\t  }, {\n\t    key: 'isNumber',\n\t    value: function isNumber(str) {\n\t      if (!isNaN(parseFloat(str))) {\n\t        str = str.replace(/,/i, ''); // remove unnecessary comma as a delimiter for thousands from data.\n\t        return parseFloat(str);\n\t      } else if (str.length == 0) {\n\t        return null;\n\t      } else {\n\t        return str;\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Creates an XHR wrapped in a Promise\n\t     * @param {!String} URL - url to send a `GET` request to\n\t     * @return {Promise} Returns a then-able promise with `XMLHttpRequest.responseText`\n\t     * */\n\t\n\t  }, {\n\t    key: 'promiseRequest',\n\t    value: function promiseRequest(URL) {\n\t      return new Promise(function (resolve, reject) {\n\t        var xhr = new XMLHttpRequest();\n\t        xhr.open('GET', URL, true);\n\t        xhr.onload = function (e) {\n\t          xhr.status == 200 ? resolve(xhr.responseText) : reject(Error(xhr.status + ': ' + xhr.statusText));\n\t        };\n\t        xhr.onerror = function (e) {\n\t          reject(e);\n\t        };\n\t        xhr.send();\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Gets a variable listed in query string\n\t     * @param {!String} variable - variable name to get value for\n\t     * @param {String=} [query=window.location.search.substring(1)] - the query string to search variable for in\n\t     * @return {String} Returns value for the variable\n\t     * */\n\t\n\t  }, {\n\t    key: 'getQueryVariable',\n\t    value: function getQueryVariable(variable) {\n\t      var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.location.search.substring(1);\n\t\n\t      var vars = query.split(\"&\");\n\t      for (var i = 0; i < vars.length; i++) {\n\t        var pair = vars[i].split(\"=\");\n\t        if (pair[0].toLowerCase() == variable.toLowerCase()) {\n\t          return pair[1];\n\t        }\n\t      }\n\t      return null;\n\t    }\n\t  }]);\n\t\n\t  return ReportalBase;\n\t}();\n\t\n\texports.default = ReportalBase;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\r\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by IvanP on 21.09.2016.\r\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\t\n\t\n\tvar _rReportalBase = __webpack_require__(1);\n\t\n\tvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t//import TableDataRowMeta from \"./TableDataRowMeta\";\n\t\n\t/**\r\n\t * A base class for stripping data from HTML tables\r\n\t * */\n\tvar TableData = function () {\n\t  function TableData() {\n\t    _classCallCheck(this, TableData);\n\t  }\n\t\n\t  _createClass(TableData, null, [{\n\t    key: 'detectMultidimensional',\n\t\n\t    /**\r\n\t     * Detects if the dataset is multi-dimentional and sets classes on items: a rowspanning cell gets a `.blockCell` and the row containing it a `.firstInBlock`\r\n\t     * __Doesn't work with `Horizontal Percents` enabled!__\r\n\t     * @param {HTMLTableElement} source - source table\r\n\t     * @return {Boolean} Returns if the data in table is multi-dimentional\r\n\t     * */\n\t    value: function detectMultidimensional(source) {\n\t      var multidimensional = false;\n\t      var blocks = source.parentNode.querySelectorAll('table#' + source.id + '>tbody>tr>td:nth-child(1)[rowspan]');\n\t      if (blocks.length > 0) {\n\t        multidimensional = true;\n\t        [].slice.call(blocks).forEach(function (blockCell) {\n\t          blockCell.classList.add('blockCell');\n\t          blockCell.parentNode.classList.add('firstInBlock');\n\t        });\n\t      }\n\t      return multidimensional;\n\t    }\n\t\n\t    /**\r\n\t     * Extracts data from a given cell. Override in an inherited class if you need to add any metadata to it.\r\n\t     * @param {HTMLTableCellElement} cell - cell element to have data stripped off it\r\n\t     * @param {HTMLTableCellElement} rowIndex - index of the row it's in\r\n\t     * @param {HTMLTableCellElement} columnIndex - index of the column it's in\r\n\t     * @returns {?String|?Number} Returns a `String`, a `Number` or a `null` (if data is absent in the cell or its text content boils down to an empty string - i.e. there are no characters in the cell, only HTML tags)\r\n\t     * */\n\t\n\t  }, {\n\t    key: 'prepareDataCell',\n\t    value: function prepareDataCell(cell, rowIndex, columnIndex) {\n\t      return _rReportalBase2.default.isNumber(cell.textContent.trim());\n\t      /*return {\r\n\t          cell,\r\n\t          data: ReportalBase.isNumber(cell.textContent.trim()),\r\n\t          rowIndex,\r\n\t          columnIndex\r\n\t        }*/\n\t    }\n\t\n\t    /**\r\n\t     * A universal data-extraction function. It strips data from a table's body. Data can be stripped by rows (horizontally) or by columns (vertically) which is controlled by `direction`. It accounts for a spanning block cell and may exclude it.\r\n\t     * @param {Object} options - options to configure the way data is stripped off the table\r\n\t     * @param {HTMLTableElement} options.source - source table that will be an input for data stripping\r\n\t     * @param {String=} options.direction='row' - direction in which data stripping will occur: `row` strips across rows and presents an array where each array item is an array of cell values. `column` strips values verticaly in a column, the resulting array will contain arrays (per column) with values resembling normalized data for cells in the column\r\n\t     * @param {Boolean=} [options.excludeBlock=true] - if table contains block cells that rowspan across several rows, we might need to exclude those from actual data\r\n\t     * @param {Array|Number} [options.excludeColumns] - if table contains columns that are not to be in data, then pass a single index or an array of cell indices (0-based). You need to count columns not by headers but by the cells in rows.\r\n\t     * @param {Array|Number} [options.excludeRows] - if table contains rows that are not to be in data, then pass a single index or an array of row indices (0-based). You need to count only rows that contain data, not the table-header rows.\r\n\t     * @param {Boolean=} options.multidimensional=false - whether the table has aggregating cells that aggregate rowheaders. Result of {@link TableData#detectMultidimensional} may be passed here to automatically calculate if it has aggregating cells.\r\n\t     * @returns {Array} returns data array.\r\n\t     * */\n\t\n\t  }, {\n\t    key: 'getData',\n\t    value: function getData(options) {\n\t      var _this = this;\n\t\n\t      var source = options.source,\n\t          _options$excludeBlock = options.excludeBlock,\n\t          excludeBlock = _options$excludeBlock === undefined ? true : _options$excludeBlock,\n\t          excludeColumns = options.excludeColumns,\n\t          excludeRows = options.excludeRows,\n\t          _options$direction = options.direction,\n\t          direction = _options$direction === undefined ? 'row' : _options$direction,\n\t          _options$multidimensi = options.multidimensional,\n\t          multidimensional = _options$multidimensi === undefined ? false : _options$multidimensi;\n\t\n\t      var data = [];\n\t      if (source && source.tagName == 'TABLE') {\n\t        (function () {\n\t          var rows = [].slice.call(source.parentNode.querySelectorAll('table#' + source.id + '>tbody>tr'));\n\t          if (rows.length > 0) {\n\t            (function () {\n\t              var tempArray = [];\n\t              // account for a negative row number (`-1`) meaning last row\n\t              if ((typeof excludeRows === 'undefined' ? 'undefined' : _typeof(excludeRows)) != undefined) {\n\t                if (typeof excludeRows == 'number') {\n\t                  // for non-block rows in multidimensional\n\t                  if (excludeRows < 0) {\n\t                    // account for a negative column number (e.g.`-1`) meaning last column\n\t                    excludeRows = rows.length + excludeRows;\n\t                  }\n\t                  rows.splice(excludeRows, 1);\n\t                }\n\t                if (Array.isArray(excludeRows)) {\n\t                  excludeRows.sort(function (a, b) {\n\t                    return a > b ? 1 : -1;\n\t                  }).reverse(); //sort to splice from the end of the array\n\t                  excludeRows.forEach(function (i) {\n\t                    if (i >= 0) {\n\t                      rows.splice(i, 1);\n\t                    } else {\n\t                      rows.splice(rows.length + i, 1);\n\t                    }\n\t                  });\n\t                }\n\t              }\n\t              rows.forEach(function (row, rowIndex) {\n\t                if (multidimensional) {\n\t                  // we need to check if the `tempArray` is not empty and push it to the `data` array, because we've encountered a new block, so the old block has to be pushed to data. Then we need to create a new block array and push there\n\t                  if (row.classList.contains('firstInBlock')) {\n\t                    if (Array.isArray(tempArray) && tempArray.length > 0) {\n\t                      data.push(tempArray);\n\t                    }\n\t                    tempArray = [];\n\t                  }\n\t                }\n\t\n\t                if (direction == 'row' && !Array.isArray(tempArray[tempArray.length])) {\n\t                  // if a row in an array doesn't exist create it\n\t                  tempArray[tempArray.length] = [];\n\t                }\n\t\n\t                // calculate which cells to exclude\n\t                var cells = [].slice.call(row.children);\n\t                var temp_excludeColumns = excludeColumns;\n\t                if ((typeof temp_excludeColumns === 'undefined' ? 'undefined' : _typeof(temp_excludeColumns)) != undefined) {\n\t                  if (typeof temp_excludeColumns == 'number') {\n\t                    // for non-block rows in multidimensional\n\t                    if (multidimensional && !row.classList.contains('firstInBlock') && !temp_excludeColumns < 0) {\n\t                      temp_excludeColumns = temp_excludeColumns + 1;\n\t                    }\n\t                    if (temp_excludeColumns < 0) {\n\t                      // account for a negative column number (e.g.`-1`) meaning last column\n\t                      temp_excludeColumns = cells.length + temp_excludeColumns;\n\t                    }\n\t                    cells.splice(temp_excludeColumns, 1);\n\t                  }\n\t                  if (Array.isArray(temp_excludeColumns)) {\n\t                    temp_excludeColumns.sort(function (a, b) {\n\t                      return a > b ? 1 : -1;\n\t                    }).reverse();\n\t                    temp_excludeColumns.forEach(function (i) {\n\t                      if (i >= 0) {\n\t                        cells.splice(multidimensional && !row.classList.contains('firstInBlock') ? i + 1 : i, 1);\n\t                      } else {\n\t                        cells.splice(cells.length + i, 1);\n\t                      }\n\t                    });\n\t                  }\n\t                }\n\t\n\t                cells.forEach(function (cell, index) {\n\t\n\t                  // we want to run this every row because number of cells in each row may differ and we want to exclude the last one\n\t                  if (typeof direction == 'string' && direction == 'row') {\n\t                    //if we strip data horizontally by row\n\t                    if (!(multidimensional && excludeBlock && cell.rowSpan > 1)) {\n\t                      // if it's a block cell we'd exclude it from data\n\t                      tempArray[tempArray.length - 1].push(_this.prepareDataCell(cell, rowIndex, index));\n\t                    }\n\t                  } else if (typeof direction == 'string' && direction == 'column') {\n\t                    //if we strip data vertically by column\n\t                    var realIndex = index;\n\t                    if (!(multidimensional && excludeBlock && cell.rowSpan > 1)) {\n\t                      //exclude block cell\n\t                      realIndex += !row.classList.contains('firstInBlock') ? 0 : -1; // offset cell that follows block cell one position back\n\t                      if (!Array.isArray(tempArray[realIndex])) {\n\t                        //create column array for current column if not available\n\t                        tempArray[realIndex] = [];\n\t                      }\n\t                      tempArray[realIndex].push(_this.prepareDataCell(cell, rowIndex, realIndex));\n\t                    }\n\t                  } else {\n\t                    throw new TypeError('direction has tobe a String==`row | column`, not a ${direction}');\n\t                  }\n\t                });\n\t              });\n\t              //we need to push the last block Array because there'll be no `.firstInBlock` anymore to do that\n\t              if (multidimensional && Array.isArray(tempArray) && tempArray.length > 0) {\n\t                data.push(tempArray);\n\t              } else {\n\t                data = tempArray;\n\t              }\n\t            })();\n\t          } else {\n\t            throw new Error('table#' + source.id + '\\'s body must contain rows');\n\t          }\n\t        })();\n\t      } else {\n\t        throw new TypeError('source must be defined and be a table');\n\t      }\n\t      return data;\n\t    }\n\t  }]);\n\t\n\t  return TableData;\n\t}();\n\t\n\texports.default = TableData;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\r\n\t * Created by IvanP on 17.08.2016.\r\n\t */\n\t/**\r\n\t * @property {HTMLTableRowElement} row - reference to the `<tr>` element\r\n\t * @property {?String} id - internal Reportal id for the rowheader in the row\r\n\t * @property {!HTMLTableCellElement} nameCell - reference to the `<td>` element that contains the rowheader label/name\r\n\t * @property {String} [name=nameCell.textContent] - label of the rowheader.\r\n\t * @property {?Object} [block=null] - the block the row belongs to\r\n\t * @property {Boolean} firstInBlock - this `row` is first in the `block`, which means it contains the first cell as a block cell\r\n\t * */\n\tvar AggregatedTableRowMeta =\n\t/**\r\n\t * Builds a prototype for each row of an Aggregated Table\r\n\t * @param {HTMLTableRowElement} row - reference to the `<tr>` element\r\n\t * @param {?String} id - internal Reportal id for the rowheader in the row\r\n\t * @param {!HTMLTableCellElement} nameCell - reference to the `<td>` element that contains the rowheader label/name\r\n\t * @param {String=} [name=nameCell.textContent] - label of the rowheader.\r\n\t * @param {?Object} [block=null] - the block the row belongs to\r\n\t * */\n\tfunction AggregatedTableRowMeta() {\n\t  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n\t      row = _ref.row,\n\t      _ref$id = _ref.id,\n\t      id = _ref$id === undefined ? null : _ref$id,\n\t      nameCell = _ref.nameCell,\n\t      name = _ref.name,\n\t      _ref$block = _ref.block,\n\t      block = _ref$block === undefined ? null : _ref$block;\n\t\n\t  _classCallCheck(this, AggregatedTableRowMeta);\n\t\n\t  /*** @property {HTMLTableRowElement} row - reference to the `<tr>` element*/\n\t  this.row = row;\n\t  this.id = id;\n\t  this.nameCell = nameCell;\n\t  this.name = name || nameCell.textContent.trim();\n\t  this.block = block;\n\t  this.firstInBlock = block != null && this.row.rowIndex === this.block.cell.parentNode.rowIndex;\n\t}\n\t/*get firstInBlock(){\r\n\t  return this._firstInBlock;\r\n\t}\r\n\tset firstInBlock(val){\r\n\t  this._firstInBlock = val;\r\n\t  val?this.row.classList.add('firstInBlock'):this.row.classList.remove('firstInBlock');\r\n\t}*/\n\t;\n\t\n\texports.default = AggregatedTableRowMeta;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _tableData = __webpack_require__(2);\n\t\n\tvar _tableData2 = _interopRequireDefault(_tableData);\n\t\n\tvar _rReportalBase = __webpack_require__(1);\n\t\n\tvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\t\n\tvar _rTableColumns = __webpack_require__(10);\n\t\n\tvar _rTableColumns2 = _interopRequireDefault(_rTableColumns);\n\t\n\tvar _sortTable = __webpack_require__(8);\n\t\n\tvar _sortTable2 = _interopRequireDefault(_sortTable);\n\t\n\tvar _tableFloatingHeader = __webpack_require__(12);\n\t\n\tvar _tableFloatingHeader2 = _interopRequireDefault(_tableFloatingHeader);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\r\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by IvanP on 27.09.2016.\r\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\t\n\tvar styles = __webpack_require__(16);\n\tvar aggregatedTableCSS = __webpack_require__(15);\n\t\n\t/**\r\n\t * A base class for aggregated tables. Multidimensional property of data is automatically calculated, thus removed from params.\r\n\t * @extends TableData\r\n\t * */\n\t\n\tvar AggregatedTable = function (_TableData) {\n\t  _inherits(AggregatedTable, _TableData);\n\t\n\t  /*\r\n\t   * @param {Object} options - options to configure the way data is stripped off the table\r\n\t   * @param {HTMLTableElement} options.source - source table that will be an input for data stripping\r\n\t   * @param {HTMLTableElement} [options.refSource] - a reference to a floating header, if any\r\n\t   * @param {Number} [options.rowheaderColumnIndex=0] - 0-based index of the column that we need to check against to see if it's a multidimentional table\r\n\t   * @param {Number|Object=} [options.defaultHeaderRow=-1] - index of the row in `thead` (incremented from 0) that will have sorting enabled for columns. If `-1` then last row.\r\n\t   * @param {String=} options.dataStripDirection='row' - direction in which data stripping will occur: `row` strips across rows and presents an array where each array item is an array of cell values. `column` strips values verticaly in a column, the resulting array will contain arrays (per column) with values resembling normalized data for cells in the column\r\n\t   * @param {Boolean=} [options.excludeBlock=true] - if table contains block cells that rowspan across several rows, we might need to exclude those from actual data\r\n\t   * @param {Array|Number} [options.excludeColumns] - if table contains columns that are not to be in data, then pass a single index or an array of cell indices (0-based). You need to count columns not by headers but by the cells in rows.\r\n\t   * @param {Array|Number} [options.excludeRows] - if table contains rows that are not to be in data, then pass a single index or an array of row indices (0-based). You need to count only rows that contain data, not the table-header rows.\r\n\t   * @param {SortTable} options.sorting - sorting options, see {@link SortTable}. If you want to leave all options default but enable sorting, pass an empty object(`.., sorting:{}`), or sorting won't be applied.\r\n\t   * @param {SortTable} options.floatingHeader - floating header, see {@link SortTable}. If you want to leave all options default but enable sorting, pass an empty object(`.., sorting:{}`), or sorting won't be applied.\r\n\t   * */\n\t  function AggregatedTable(options) {\n\t    _classCallCheck(this, AggregatedTable);\n\t\n\t    var source = options.source,\n\t        rowheaderColumnIndex = options.rowheaderColumnIndex,\n\t        defaultHeaderRow = options.defaultHeaderRow,\n\t        dataStripDirection = options.dataStripDirection,\n\t        excludeBlock = options.excludeBlock,\n\t        excludeColumns = options.excludeColumns,\n\t        excludeRows = options.excludeRows,\n\t        sorting = options.sorting,\n\t        floatingHeader = options.floatingHeader;\n\t\n\t    /**\r\n\t     *  The source table\r\n\t     *  @type {HTMLTableElement}\r\n\t     *  @memberOf AggregatedTable\r\n\t     *  */\n\t    var _this = _possibleConstructorReturn(this, (AggregatedTable.__proto__ || Object.getPrototypeOf(AggregatedTable)).call(this));\n\t\n\t    _this.source = source;\n\t    var refSource = void 0;\n\t    if (floatingHeader && (typeof floatingHeader === \"undefined\" ? \"undefined\" : _typeof(floatingHeader)) == 'object') {\n\t      _this.floatingHeader = new _tableFloatingHeader2.default(source);\n\t      /**\r\n\t       *  The floating header\r\n\t       *  @type {HTMLTableElement}\r\n\t       *  @memberOf AggregatedTable\r\n\t       *  */\n\t      _this.refSource = refSource = _this.floatingHeader.header;\n\t    }\n\t\n\t    /**\r\n\t     *  Whether data is monodimensional or multidimensional\r\n\t     *  @type {Boolean}\r\n\t     *  @memberOf AggregatedTable\r\n\t     *  */\n\t\n\t    _this.multidimensional = _this.constructor.detectMultidimensional(source);\n\t\n\t    /**\r\n\t     *  data Array\r\n\t     *  @type {Array.<{cell:HTMLTableCellElement, data:?String|?Number, columnIndex:Number}>}\r\n\t     *  @memberOf AggregatedTable\r\n\t     *  */\n\t    _this.data = _this.constructor.getData({ source: source, refSource: refSource, defaultHeaderRow: defaultHeaderRow, excludeBlock: excludeBlock, excludeColumns: excludeColumns, excludeRows: excludeRows, direction: dataStripDirection, multidimensional: _this.multidimensional });\n\t\n\t    if (sorting && (typeof sorting === \"undefined\" ? \"undefined\" : _typeof(sorting)) == 'object') {\n\t      (function () {\n\t        var reorderFunction = function reorderFunction(e) {\n\t          return _this.constructor.reorderRows(_this.data, _this.source, _this.multidimensional);\n\t        };\n\t        [source, refSource].forEach(function (target) {\n\t          if (target) {\n\t            target.addEventListener('reportal-table-sort', reorderFunction);\n\t          }\n\t        });\n\t\n\t        sorting.source = source;\n\t        sorting.refSource = refSource;\n\t        sorting.defaultHeaderRow = defaultHeaderRow;\n\t        sorting.data = _this.data;\n\t        sorting.multidimensional = _this.multidimensional;\n\t\n\t        /**\r\n\t         *  sorting object. See {@link SortTable}\r\n\t         *  @type {SortTable}\r\n\t         *  @memberOf AggregatedTable\r\n\t         *  */\n\t        _this.sorting = new _sortTable2.default(sorting);\n\t\n\t        // add listener to do reordering on sorting\n\t      })();\n\t    }\n\t\n\t    /**\r\n\t     * table columns array\r\n\t     * @type {Array.<{index:Number, title:String, colSpan:Number, cell: HTMLTableCellElement, ?refCell:HTMLTableCellElement}>}\r\n\t     * @memberOf AggregatedTable\r\n\t     * */\n\t    _this.columns = _this.sorting && _this.sorting.columns ? _this.sorting.columns : new _rTableColumns2.default({ source: source, refSource: refSource, defaultHeaderRow: defaultHeaderRow });\n\t    return _this;\n\t  }\n\t\n\t  /**\r\n\t   * Extracts data from a given cell. Override in an inherited class if you need to add any metadata to it.\r\n\t   * @param {HTMLTableCellElement} cell - cell element to have data stripped off it\r\n\t   * @param {HTMLTableCellElement} rowIndex - index of the row it's in\r\n\t   * @param {HTMLTableCellElement} columnIndex - index of the column it's in\r\n\t   * @returns {{cell:HTMLTableCellElement, ?data:String|Number, columnIndex:Number}} Returns an object `{cell:HTMLTableCellElement, data:?String|?Number, columnIndex:Number}` (if data is absent in the cell or its text content boils down to an empty string - i.e. there are no characters in the cell, only HTML tags) it returns null in `data`\r\n\t   * @override\r\n\t   * */\n\t\n\t\n\t  _createClass(AggregatedTable, null, [{\n\t    key: \"prepareDataCell\",\n\t    value: function prepareDataCell(cell, rowIndex, columnIndex) {\n\t      return {\n\t        cell: cell,\n\t        data: _rReportalBase2.default.isNumber(cell.textContent.trim()),\n\t        columnIndex: columnIndex,\n\t        rowIndex: rowIndex\n\t      };\n\t    }\n\t\n\t    /**\r\n\t     * This function takes care of repositioning rows in the table to match the `data` array in the way it was sorted and if the data is separated into blocks, then move the block piece to the first row in each data block.\r\n\t     * @param {Array} data - full sorted dataset. Instance of {@link TableData#getData}\r\n\t     * @param {HTMLTableElement} source - source table\r\n\t     * @param {Boolean} multidimensional\r\n\t     * */\n\t\n\t  }, {\n\t    key: \"reorderRows\",\n\t    value: function reorderRows(data, source, multidimensional) {\n\t      var fragment = document.createDocumentFragment();\n\t      AggregatedTable.dimensionalDataIterator(data, multidimensional, function (dataDimension) {\n\t        if (multidimensional) {\n\t          AggregatedTable.repositionBlockCell(dataDimension);\n\t        } // if multidimensional reposition aggregating block cell to the topmost row in sorted array\n\t        dataDimension.forEach(function (item) {\n\t          fragment.appendChild(item[0].cell.parentNode);\n\t        }); // add row to fragment in the array order, this doesn't account for column stripped data yet\n\t      });\n\t      source.querySelector('tbody').appendChild(fragment);\n\t    }\n\t\n\t    /*\r\n\t     * Repositions the rowspanning block cell from the initial row to the new sorted row\r\n\t     * @param {Array} items - dimension of data\r\n\t     * */\n\t\n\t  }, {\n\t    key: \"repositionBlockCell\",\n\t    value: function repositionBlockCell(items) {\n\t      var blockRowItem = items.filter(function (item) {\n\t        return item[0].cell.parentNode.classList.contains('firstInBlock');\n\t      })[0];\n\t      var blockRow = blockRowItem[0].cell.parentNode;\n\t      if (items.indexOf(blockRowItem) != 0) {\n\t        // if block row isn't first in dimension\n\t        var newFirstRow = items[0][0].cell.parentNode;\n\t        newFirstRow.insertBefore(blockRow.querySelector('.blockCell'), newFirstRow.firstElementChild); // move block cell\n\t        newFirstRow.classList.add('firstInBlock');\n\t        blockRow.classList.remove('firstInBlock');\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * allows to perform action on data based on its multidimensionality\r\n\t     * @param {Array} data - full dataset. Instance of {@link TableData#getData}\r\n\t     * @param {Boolean} multidimensional\r\n\t     * @param {!Function} callback - a function to be executed on a dimension of data. Callback is called with two attributes: `dimension` - the current iteration of data and `index` (optional) if it's multidimensional\r\n\t     * */\n\t\n\t  }, {\n\t    key: \"dimensionalDataIterator\",\n\t    value: function dimensionalDataIterator(data, multidimensional, callback) {\n\t      if (!callback || typeof callback != 'function') {\n\t        throw new TypeError('`callback` must be passed and be a function');\n\t      }\n\t      if (!multidimensional) {\n\t        return callback(data);\n\t      } else {\n\t        // if array has nested array blocks\n\t        data.forEach(function (dimension, index) {\n\t          callback(dimension, index);\n\t        });\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return AggregatedTable;\n\t}(_tableData2.default);\n\t\n\texports.default = AggregatedTable;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _tableData = __webpack_require__(2);\n\t\n\tvar _tableData2 = _interopRequireDefault(_tableData);\n\t\n\tvar _aggregatedTable = __webpack_require__(4);\n\t\n\tvar _aggregatedTable2 = _interopRequireDefault(_aggregatedTable);\n\t\n\tvar _rReportalBase = __webpack_require__(1);\n\t\n\tvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\t\n\tvar _aggregatedTableRowMeta = __webpack_require__(3);\n\t\n\tvar _aggregatedTableRowMeta2 = _interopRequireDefault(_aggregatedTableRowMeta);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\r\n\t * Created by IvanP on 07.09.2016.\r\n\t */\n\t\n\twindow.Reportal = window.Reportal || {};\n\t_rReportalBase2.default.mixin(window.Reportal, {\n\t  TableData: _tableData2.default,\n\t  AggregatedTable: _aggregatedTable2.default,\n\t  AggregatedTableRowMeta: _aggregatedTableRowMeta2.default\n\t});\n\t\n\texports.default = _aggregatedTable2.default;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\r\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by IvanP on 15.12.2016.\r\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\t\n\t\n\tvar _rReportalBase = __webpack_require__(1);\n\t\n\tvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\r\n\t * A class that provides utility static methods to load children of a level of hiererachy and a table per a given id\r\n\t * */\n\tvar AsyncHierarchyTable = function () {\n\t  function AsyncHierarchyTable() {\n\t    _classCallCheck(this, AsyncHierarchyTable);\n\t  }\n\t\n\t  _createClass(AsyncHierarchyTable, null, [{\n\t    key: 'fetchChildHierarchy',\n\t\n\t    /**\r\n\t     * Queries if each row might contain child rows by quering hierarchy for next level\r\n\t     * @param {!String} id - rowheader id for current row\r\n\t     * @param {!Number} hierarchyID - id of Hierarchy in Table Designer\r\n\t     * @param {!String} hierarchyControlID - id of the Reportal Hierarchy Component instance on the page\r\n\t     * @param {!String} pageStateID - Reportal state id\r\n\t     * @param {Number=} languageCode=9 - Language code (according to Confirmit table of language codes) of the language the hierarchy is going to be streamed in at the page load\r\n\t     * @returns {Array} array of child nodes of the `id` in hierarchy\r\n\t     * */\n\t    value: function fetchChildHierarchy(id, hierarchyID, hierarchyControlID, pageStateID) {\n\t      var languageCode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 9;\n\t\n\t      var path = [location.origin, 'reportal', 'Hierarchy', _rReportalBase2.default.getQueryVariable('ReportId'), hierarchyID, languageCode, 'GetChildNodes'];\n\t\n\t      var query = ['nodeId=' + id, 'info=' + AsyncHierarchyTable.encode({\n\t        IsPreview: _rReportalBase2.default.getQueryVariable('Preview') === 'true',\n\t        HierarchyControlId: hierarchyControlID\n\t      }), 'isRepBase=false', 'parameter=', 'PageStateId=' + pageStateID];\n\t\n\t      var hierarchyItemChildren = _rReportalBase2.default.promiseRequest([path.join('/'), '?', query.join('&')].join(''));\n\t      return hierarchyItemChildren.then(function (response) {\n\t        return Promise.resolve(JSON.parse(response));\n\t      });\n\t    }\n\t\n\t    /**\r\n\t     * Gets row nodes that are child to the parent row#`id`\r\n\t     * @param {!String} id - rowheader id for current row\r\n\t     * @param {?String} parentID - rowheader id for parent row\r\n\t     * @param {!String} tableID - Reportal Aggregated Table Component id\r\n\t     * @param {!String} pageStateID - Reportal state id\r\n\t     * @return {Promise} Returns a thenable promise which result is an `HTMLTableElement` with rows that are children to the row#`id`\r\n\t     * */\n\t\n\t  }, {\n\t    key: 'fetchChildTable',\n\t    value: function fetchChildTable(id, parentID, tableID, pageStateID) {\n\t      parentID = parentID != null ? parentID : id;\n\t      var path = [location.origin, 'reportal', 'Report', _rReportalBase2.default.getQueryVariable('ReportId'), 'Component', tableID];\n\t      var query = ['PageId=' + _rReportalBase2.default.getQueryVariable('PageId'), 'Preview=' + _rReportalBase2.default.getQueryVariable('Preview'), 'PageStateId=' + pageStateID, 'pageFilters=' + AsyncHierarchyTable.encode({}), 'customFilters=' + AsyncHierarchyTable.encode({}), 'persNodes=' + AsyncHierarchyTable.encode([{ NodeId: id, Text: null }]), // child node id\n\t      'origNodes=' + AsyncHierarchyTable.encode([{ NodeId: parentID, Text: null }]) // parent node id\n\t      ];\n\t      var tableResult = _rReportalBase2.default.promiseRequest([path.join('/'), '?', query.join('&')].join(''));\n\t      return tableResult.then(function (response) {\n\t        var host = document.createElement('span');\n\t        host.innerHTML = response;\n\t        return Promise.resolve(host.querySelector('table'));\n\t      });\n\t    }\n\t\n\t    /**\r\n\t     * Strips rows from the table received\r\n\t     * @param {HTMLTableElement} table - Aggregated table element\r\n\t     * @param {Array} excludedRows - rows excluded from insertion\r\n\t     * @return {Array} Returns an array of rows {HTMLTableRowElement}\r\n\t     * */\n\t\n\t  }, {\n\t    key: 'stripRowsFromResponseTable',\n\t    value: function stripRowsFromResponseTable(table, excludedRows) {\n\t      var rows = [].slice.call(table.querySelectorAll('tbody>tr'));\n\t      if (excludedRows && excludedRows.length > 0) {\n\t        excludedRows.reverse().forEach(function (index) {\n\t          rows.splice(index, 1);\n\t        });\n\t      }\n\t      return rows;\n\t    }\n\t\n\t    /**\r\n\t     * Does `JSON.stringify` and `encodeURIComponent` of anything passed to be added to the query string\r\n\t     * @param {String|Object|Array} toEncode - piece to be URLencoded\r\n\t     * @returns {String} Returns an encoded string\r\n\t     * */\n\t\n\t  }, {\n\t    key: 'encode',\n\t    value: function encode(toEncode) {\n\t      return encodeURIComponent(JSON.stringify(toEncode));\n\t    }\n\t  }]);\n\t\n\t  return AsyncHierarchyTable;\n\t}();\n\t\n\texports.default = AsyncHierarchyTable;\n\t\n\t\n\twindow.Reportal = window.Reportal || {};\n\t_rReportalBase2.default.mixin(window.Reportal, {\n\t  AsyncHierarchyTable: AsyncHierarchyTable\n\t});\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar SortOrder = function () {\n\t  /**\r\n\t   * Creates a `sortOrder` array\r\n\t   * @param {Object} options - configuration options\r\n\t   * @param {Object} options.columns - an array of columns from {@link TableColumns}\r\n\t   * @param {Function} options.sortCallback - function that performs sorting based on the `sortOrder`\r\n\t   * @param {Object} options.sortCallbackScope - scope in which sort callback needs to be executed\r\n\t   * @param {Object} [options.defaultSorting] - an array of objects that specify default sorting\r\n\t   * @param {Number} options.defaultSorting.column - column index\r\n\t   * @param {String} options.defaultSorting.direction - sort direction (`asc`|`desc`)\r\n\t   * @return {Array}\r\n\t   * */\n\t  function SortOrder(options) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, SortOrder);\n\t\n\t    var columns = options.columns,\n\t        sortCallback = options.sortCallback,\n\t        _options$defaultSorti = options.defaultSorting,\n\t        defaultSorting = _options$defaultSorti === undefined ? [] : _options$defaultSorti,\n\t        _options$sortCallback = options.sortCallbackScope,\n\t        sortCallbackScope = _options$sortCallback === undefined ? this : _options$sortCallback;\n\t\n\t\n\t    this.sortOrder = [];\n\t    if ((typeof columns === 'undefined' ? 'undefined' : _typeof(columns)) != undefined && columns != null) {\n\t      this.columns = columns;\n\t    } else {\n\t      throw new TypeError('SortOrder: columns must be specified');\n\t    }\n\t    this.sort = function () {\n\t      if (sortCallback && typeof sortCallback === 'function') {\n\t        sortCallback.call(sortCallbackScope, _this);\n\t      }\n\t    };\n\t    if (defaultSorting.length > 0) {\n\t      defaultSorting.forEach(function (item) {\n\t        return _this.add(item);\n\t      });\n\t      this.sort();\n\t    }\n\t  }\n\t\n\t  /**\r\n\t   * Returns an array containing a `cell` from the table and a reference cell (`refCell`) from the floating header if any\r\n\t   * @param {!Number} columnIndex - index of the column from the array of columns from {@link TableColumns}\r\n\t   * @return {{cell:HTMLTableCellElement, refCell:HTMLTableCellElement}}\r\n\t   * */\n\t\n\t\n\t  _createClass(SortOrder, [{\n\t    key: 'getCell',\n\t    value: function getCell(columnIndex) {\n\t      if (typeof columnIndex != 'undefined' && columnIndex != null) {\n\t        var cells = [];\n\t        if (this.columns[columnIndex].cell) {\n\t          cells.push(this.columns[columnIndex].cell);\n\t        }\n\t        if (this.columns[columnIndex].refCell) {\n\t          cells.push(this.columns[columnIndex].refCell);\n\t        }\n\t        return cells;\n\t      } else {\n\t        throw new TypeError('columnIndex parameter should not be null');\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Adds another column to be sorted\r\n\t     * @param {!Object} obj - object describing sorting\r\n\t     * @param {Number} obj.column - column index\r\n\t     * @param {String} obj.direction - sort direction (`asc`|`desc`)\r\n\t     * */\n\t\n\t  }, {\n\t    key: 'add',\n\t    value: function add(obj) {\n\t      this.getCell(obj.column).forEach(function (cell) {\n\t        //if(!cell.classList.contains('sorted')){ // this column is not sorted, there might be others that are.\n\t        ['sorted', obj.direction].forEach(function (className) {\n\t          return cell.classList.add(className);\n\t        });\n\t        //} else { //swaps sorting from asc to desc\n\t        //  ['asc','desc'].forEach(className=>cell.classList.toggle(className));\n\t        //}\n\t      });\n\t      this.sortOrder.push(obj);\n\t    }\n\t\n\t    /**\r\n\t     * Removes a column from `sortOrder`\r\n\t     * @param {Number} column - column index as reference to the item to be removed.\r\n\t     * @param {Number} index - index of item in `sortOrder` array to be removed\r\n\t     * */\n\t\n\t  }, {\n\t    key: 'remove',\n\t    value: function remove(column, index) {\n\t      var _this2 = this;\n\t\n\t      ['sorted', 'asc', 'desc'].forEach(function (className) {\n\t        _this2.getCell(column).forEach(function (cell) {\n\t          return cell.classList.remove(className);\n\t        });\n\t      });\n\t      this.sortOrder.splice(index, 1);\n\t    }\n\t  }, {\n\t    key: 'replace',\n\t\n\t\n\t    /**\r\n\t     * Replaces all items in `sortOrder`\r\n\t     * @param {!Object} obj - object describing sorting\r\n\t     * @param {Number} obj.column - column index\r\n\t     * @param {String} obj.direction - sort direction (`asc`|`desc`)\r\n\t     * */\n\t    value: function replace(obj) {\n\t      var _this3 = this;\n\t\n\t      if (this.sortOrder.length > 0) {\n\t        this.sortOrder.forEach(function (item, index) {\n\t          _this3.remove(item.column, index);\n\t        });\n\t      }\n\t      this.add(obj);\n\t      this.sort();\n\t    }\n\t  }]);\n\t\n\t  return SortOrder;\n\t}();\n\t\n\texports.default = SortOrder;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _rReportalBase = __webpack_require__(1);\n\t\n\tvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\t\n\tvar _tableColumns = __webpack_require__(9);\n\t\n\tvar _tableColumns2 = _interopRequireDefault(_tableColumns);\n\t\n\tvar _sortOrder = __webpack_require__(7);\n\t\n\tvar _sortOrder2 = _interopRequireDefault(_sortOrder);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\r\n\t * Event reporting that a table has been sorted\r\n\t * @event SortTable~reportal-table-sort\r\n\t */\n\t\n\t/**\r\n\t * Makes a table sortable, gives API for sorting. It sorts `data` array, but doesn't move rows in the `source` table, because of differences in implementation.\r\n\t *\r\n\t * > Note: It's important that every Array item that is going to be sortable was either a `String`, a `Number`, a `null`, or an `Object` that contained `data` property (which was of the previously named types)\r\n\t *\r\n\t * @param {Object} options - options passed to configure the Sorting\r\n\t * @param {HTMLTableElement} options.source - source table sorting will be applied to\r\n\t * @param {HTMLTableElement} [options.refSource] - the floating header if any, will reflect and trigger sorting on header when scrolled.\r\n\t * @param {Number} [options.defaultHeaderRow=-1] - index of the row in `thead` (incremented from 0) that will have sorting enabled for columns. If `-1` then last row.\r\n\t * @param {Array} [options.included] - Array of column indices (incremented from 0) that will have sorting enabled. If not specified, all columns will be sortable. Optionally `excluded` can be specified instead as a shorthand to pass only indices of columns to be excluded from sorting, assumning that others will be made sortable. It's important to count the column index in the defaultHeaderRow\r\n\t * @param {Array} [options.excluded] - Array of column indices (incremented from 0) that will be excluded from sorting. Can be used as a shorthand instead of `included`.\r\n\t * @param {Object} [options.defaultSorting] - an array of objects that specify default sorting\r\n\t * @param {Number} options.defaultSorting.column - column index\r\n\t * @param {String} options.defaultSorting.direction - sort direction (`asc`|`desc`)\r\n\t * @param {Array} options.data - data with information for rows to be sorted\r\n\t * @param {Boolean} [options.multidimensional=false] - if `data` is single-dimensional (contains rows with data to be sorted as immediate array items: `data [rowItem...]`), then it is `false`. If it has blocks of data as items (each block containing an array of rows to be sorted: data [block [rowItem...]...]), then set it to `true`. Currently it supports only a two-level aggregation max (data->block->rowItem).\r\n\t * @prop {HTMLTableElement} source - source table\r\n\t * @prop {Array} data - data array to be sorted\r\n\t * @prop {Boolean} multidimensional - if `data` is mono-dimensional (contains rows with data to be sorted as immediate array items: `data [rowItem...]`), then it is `false`. If it has blocks of data as items (each block containing an array of rows to be sorted: data [block [rowItem...]...]), then set it to `true`. Currently it supports only a two-level aggregation max (data->block->rowItem).\r\n\t * @prop {SortOrder} sortOrder - instance of {@link SortOrder}\r\n\t * @prop {TableColumns} columns - instance of {@link TableColumns} with a modified prototype (added `sortable:true` and `.sortable` to sortable columns)\r\n\t * @class SortTable\r\n\t * */\n\tvar SortTable = function () {\n\t  /**\r\n\t   *\r\n\t   *\r\n\t   *  */\n\t\n\t  function SortTable(options) {\n\t    var _ref,\n\t        _ref$sortOrder,\n\t        _this = this;\n\t\n\t    _classCallCheck(this, SortTable);\n\t\n\t    var source = options.source,\n\t        refSource = options.refSource,\n\t        _options$defaultHeade = options.defaultHeaderRow,\n\t        defaultHeaderRow = _options$defaultHeade === undefined ? -1 : _options$defaultHeade,\n\t        included = options.included,\n\t        excluded = options.excluded,\n\t        _options$defaultSorti = options.defaultSorting,\n\t        defaultSorting = _options$defaultSorti === undefined ? [] : _options$defaultSorti,\n\t        _options$data = options.data,\n\t        data = _options$data === undefined ? [] : _options$data,\n\t        _options$multidimensi = options.multidimensional,\n\t        multidimensional = _options$multidimensi === undefined ? false : _options$multidimensi;\n\t\n\t    this._sortEvent = _rReportalBase2.default.newEvent('reportal-table-sort');\n\t\n\t    if (source) {\n\t      this.source = source;\n\t    } else {\n\t      throw new Error('`source` table is not specified for SortTable');\n\t    }\n\t    this.data = data;\n\t    this.multidimensional = multidimensional;\n\t\n\t    //let tableColumns= new TableColumns({source, refSource, defaultHeaderRow});\n\t    var sortableColumns = SortTable.defineSortableColumns(new _tableColumns2.default({ source: source, refSource: refSource, defaultHeaderRow: defaultHeaderRow }), included, excluded);\n\t    this.columns = sortableColumns;\n\t    // setup sort order and do initial default sorting\n\t    this.sortOrder = (_ref = new _sortOrder2.default({ columns: sortableColumns, sortCallback: this.sort, sortCallbackScope: this, defaultSorting: defaultSorting }), _ref$sortOrder = _toArray(_ref.sortOrder), _ref);\n\t    [source, refSource].forEach(function (src) {\n\t      if (src) {\n\t        SortTable.listenForSort(_tableColumns2.default.getHeader(src), sortableColumns, _this.sortOrder);\n\t      }\n\t    }); // set up listeners for headers\n\t  }\n\t\n\t  /**\r\n\t   * Checks the table columns array against the `included`/`excluded` columns arrays and adds a `sortable:true` property and a `.sortable` class to the sortable ones\r\n\t   * @param {TableColumns} columns - an instance of {@link TableColumns}\r\n\t   * @param {Array} [included] - array of included columns indices\r\n\t   * @param {Array} [excluded] - array of excluded columns indices\r\n\t   * */\n\t\n\t\n\t  _createClass(SortTable, [{\n\t    key: \"sort\",\n\t\n\t\n\t    /**\r\n\t     * Performs channeling of sorting based on whether `this.data` is `multidimensional`\r\n\t     * @param {SortOrder} sortOrder - instance of {@link SortOrder} passed by the {@link SortOrder#sort} on initial sort\r\n\t     * @fires SortTable~reportal-table-sort\r\n\t     * */\n\t    value: function sort(sortOrder) {\n\t      var _this2 = this;\n\t\n\t      var so = sortOrder.sortOrder || this.sortOrder.sortOrder,\n\t          columns = this.columns;\n\t      if (so && so.length > 0) {\n\t        if (!this.multidimensional) {\n\t          SortTable.sortDimension(this.data, columns, so);\n\t        } else {\n\t          // if array has nested array blocks\n\t          this.data.forEach(function (dimension) {\n\t            SortTable.sortDimension(dimension, _this2.columns, so);\n\t          });\n\t        }\n\t        columns[so[0].column].cell.dispatchEvent(this._sortEvent);\n\t      }\n\t    }\n\t    /**\r\n\t     * Splits sorting into one-column or two-column. The precedence of columns in `sortOrder` is the factor defining sort priority\r\n\t     * @param {Array} data - array containing row items to be sorted\r\n\t     * @param {TableColumns} columns - array of table columns from {@link SortTable#defineSortableColumns}\r\n\t     * @param {SortOrder} sortOrder - instance of {@link SortOrder}\r\n\t     * */\n\t\n\t  }], [{\n\t    key: \"defineSortableColumns\",\n\t    value: function defineSortableColumns(columns, included, excluded) {\n\t      var sortableColumns = [].slice.call(columns);\n\t      sortableColumns.forEach(function (column, index) {\n\t        var sortable = !included && !excluded || included && included.indexOf(index) != -1 || excluded && excluded.indexOf(index) == -1;\n\t        if (sortable) {\n\t          column.cell.classList.add('sortable');\n\t          if (column.refCell) {\n\t            column.refCell.classList.add('sortable');\n\t          }\n\t          column.sortable = true;\n\t        }\n\t      });\n\t      return sortableColumns;\n\t    }\n\t\n\t    /**\r\n\t     * sets up listeners for column headers available for click\r\n\t     * @param {HTMLElement} delegatedTarget - element that will receive clicks and see if they are valid, `thead` is recommended to boil down to header clicks only\r\n\t     * @param {TableColumns} columns - array of table columns from {@link SortTable#defineSortableColumns}\r\n\t     * @param {SortOrder} sortOrder - instance of {@link SortOrder}\r\n\t     * @listens click\r\n\t     * */\n\t\n\t  }, {\n\t    key: \"listenForSort\",\n\t    value: function listenForSort(delegatedTarget, columns, sortOrder) {\n\t      delegatedTarget.addEventListener('click', function (e) {\n\t        // if it's a table cell, is in columns array and is sortable\n\t        var clickedColumn = void 0;\n\t        for (var i = 0; i < columns.length; i++) {\n\t          if (e.target == columns[i].cell || e.target == columns[i].refCell) {\n\t            clickedColumn = columns[i];break;\n\t          }\n\t        }\n\t        if ((e.target.tagName == 'TD' || e.target.tagName == 'TH') && clickedColumn.sortable) {\n\t          sortOrder.replace({ column: columns.indexOf(clickedColumn), direction: e.target.classList.contains('asc') ? 'desc' : 'asc' });\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: \"sortDimension\",\n\t    value: function sortDimension(data, columns, sortOrder) {\n\t      var getIndex = function getIndex(i) {\n\t        return columns[sortOrder[i].column].index;\n\t      };\n\t      var getDirection = function getDirection(i) {\n\t        return sortOrder[i].direction === 'desc' ? -1 : 1;\n\t      };\n\t      // TODO: add possibility to sort the data that was stripped by column.\n\t      data.sort(function (a, b) {\n\t        // sort rows\n\t        if (sortOrder.length == 1) {\n\t          //sort one column only\n\t          return SortTable.sorter(a[getIndex(0)], b[getIndex(0)], getDirection(0));\n\t        } else {\n\t          //sort against two columns\n\t          return SortTable.sorter(a[getIndex(0)], b[getIndex(0)], getDirection(0)) || SortTable.sorter(a[getIndex(1)], b[getIndex(1)], getDirection(1));\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\r\n\t     * Function that performs case insensitive sorting in the array. It can distinguish between numbers, numbers as strings, HTML and plain strings\r\n\t     * */\n\t\n\t  }, {\n\t    key: \"sorter\",\n\t    value: function sorter(a, b, lesser) {\n\t      var regex = /[<>]/g;\n\t      if (regex.test(a) || regex.test(b)) {\n\t        // if we need to sort elements that have HTML like links\n\t        var tempEl1 = document.createElement('span');tempEl1.innerHTML = a;\n\t        a = tempEl1.textContent.trim();\n\t        var tempEl2 = document.createElement('span');tempEl2.innerHTML = b;\n\t        b = tempEl2.textContent.trim();\n\t      }\n\t      if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) == 'object' && _typeof(a.data) != undefined) {\n\t        a = a.data;\n\t      }\n\t      if ((typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) == 'object' && _typeof(b.data) != undefined) {\n\t        b = b.data;\n\t      }\n\t      if (!isNaN(a) && !isNaN(b)) {\n\t        //they might be numbers or null\n\t        if (a === null) {\n\t          return 1;\n\t        } else if (b === null) {\n\t          return -1;\n\t        }\n\t        return a < b ? lesser : a > b ? -lesser : 0;\n\t      } else if (!isNaN(parseFloat(a)) && !isNaN(parseFloat(b))) {\n\t        // they might be number strings\n\t        return parseFloat(a) < parseFloat(b) ? lesser : parseFloat(a) > parseFloat(b) ? -lesser : 0;\n\t      } else {\n\t        //they might be simple strings\n\t        return a.toLowerCase() < b.toLowerCase() ? lesser : a.toLowerCase() > b.toLowerCase() ? -lesser : 0;\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return SortTable;\n\t}();\n\t\n\texports.default = SortTable;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\r\n\t * Created by IvanP on 09.09.2016.\r\n\t */\n\t\n\tvar TableColumns = function () {\n\t  /**\r\n\t   * Creates an array of objects corresponding to the cells of `defaultHeaderRow`, that contain `sortable` property, denoting the column is sortable,\r\n\t   * `index` of the column and reference to the `cell`. Adds `.sortable` to a sortable cell\r\n\t   * @param {Object} options - options passed to configure the Sorting\r\n\t   * @param {HTMLTableElement} options.source - source table sorting will be applied to\r\n\t   * @param {HTMLTableElement} options.refSource - floating header if any\r\n\t   * @param {Number|Object} [options.defaultHeaderRow=-1] - index of the row in `thead` (incremented from 0) that will have sorting enabled for columns. If `-1` then last row.\r\n\t   * @return {{index:Number, title:String, colSpan:Number, cell: HTMLTableCellElement, ?refCell:HTMLTableCellElement}} - an array of objects that have this structure\r\n\t   * */\n\t  function TableColumns(options) {\n\t    _classCallCheck(this, TableColumns);\n\t\n\t    var source = options.source,\n\t        refSource = options.refSource,\n\t        _options$defaultHeade = options.defaultHeaderRow,\n\t        defaultHeaderRow = _options$defaultHeade === undefined ? -1 : _options$defaultHeade;\n\t\n\t    var thead = void 0,\n\t        refThead = void 0;\n\t    if (source) {\n\t      thead = TableColumns.getHeader(source);\n\t    } else {\n\t      throw new TypeError('`source` table is not specified, cannot create TableColumns');\n\t    }\n\t    if (refSource) {\n\t      refThead = TableColumns.getHeader(refSource);\n\t    }\n\t    return TableColumns.computeColumns(thead, refThead, defaultHeaderRow);\n\t  }\n\t\n\t  /**\r\n\t   * Gets a header\r\n\t   * @param {HTMLTableElement} source - source table headers are created for\r\n\t   * */\n\t\n\t\n\t  _createClass(TableColumns, null, [{\n\t    key: 'getHeader',\n\t    value: function getHeader(source) {\n\t      if (source && source.tagName == 'TABLE') {\n\t        var header = source.querySelector(\"thead\");\n\t        if (header && header.children.length > 0) {\n\t          return header;\n\t        } else {\n\t          throw new TypeError('`source` table has no header or rows');\n\t        }\n\t      } else {\n\t        throw new TypeError('`source` is not specified or is not a table');\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Calculates defaultHeaderRow for a passed `thead`\r\n\t     * @param {!HTMLTableElement} thead - source table header\r\n\t     * @param {!Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n\t     * @return {{index:Number, row: HTMLTableRowElement}}\r\n\t     * */\n\t\n\t  }, {\n\t    key: 'getDefaultHeaderRow',\n\t    value: function getDefaultHeaderRow(thead, defaultHeaderRowIndex) {\n\t      // calculate default header row\n\t      var headerRows = thead.children,\n\t          headerRowIndex = defaultHeaderRowIndex == -1 ? headerRows.length + defaultHeaderRowIndex : defaultHeaderRowIndex;\n\t      return {\n\t        index: headerRowIndex,\n\t        row: headerRows.item(headerRowIndex)\n\t      };\n\t    }\n\t\n\t    /**\r\n\t     * Gets an array of header cell nodes from default header row\r\n\t     * @param {?HTMLTableElement} thead - source table header\r\n\t     * @param {!Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n\t     * @return {?Array} Returns an array of header cell nodes or null if `thead` is not specified\r\n\t     * */\n\t\n\t  }, {\n\t    key: 'getHeaderCells',\n\t    value: function getHeaderCells(thead, defaultHeaderRowIndex) {\n\t      if (thead) {\n\t        if (defaultHeaderRowIndex != null) {\n\t          var _ret = function () {\n\t            var defaultHeaderRow = TableColumns.getDefaultHeaderRow(thead, defaultHeaderRowIndex);\n\t            var headerRows = thead.children;\n\t            var rowsLength = headerRows.length;\n\t            var abstr = {};\n\t\n\t            var _loop = function _loop(r) {\n\t              var row = headerRows.item(r);\n\t              var augmentIndex = 0; // index that will account for colSpan of upper rows' cells\n\t              [].slice.call(row.children).forEach(function (cell, index) {\n\t                //iterate through cells\n\t                for (var rs = 0; rs <= cell.rowSpan - 1; rs++) {\n\t                  //spread cell across its rowspan\n\t                  var rowA = abstr[r + rs] = abstr[r + rs] || {}; //create row if not exists\n\t                  if (!rowA[augmentIndex]) {\n\t                    //insert cell into slot if not filled\n\t                    rowA[augmentIndex] = cell;\n\t                  } else {\n\t                    //if filled look for the next empty because rowspanned columns fill them in a linear way\n\t                    var i = 0;\n\t                    while (true) {\n\t                      if (!rowA[i]) {\n\t                        rowA[i] = cell;\n\t                        augmentIndex = i;\n\t                        break;\n\t                      }\n\t                      i++;\n\t                    }\n\t                  }\n\t                }\n\t                augmentIndex += cell.colSpan;\n\t              });\n\t            };\n\t\n\t            for (var r = 0; r < rowsLength; r++) {\n\t              _loop(r);\n\t            }\n\t            return {\n\t              v: Object.keys(abstr[defaultHeaderRow.index]).map(function (k) {\n\t                return abstr[defaultHeaderRow.index][k];\n\t              })\n\t            };\n\t          }();\n\t\n\t          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t        } else {\n\t          throw new TypeError('TableColumns.getHeaderCells: defaultHeaderRowIndex is not specified or is not a Number');\n\t        }\n\t      }\n\t      return null;\n\t    }\n\t\n\t    /**\r\n\t     * Gets an array of columns from the table\r\n\t     * @param {!HTMLTableElement} thead - source table header\r\n\t     * @param {!HTMLTableElement} refThead - reference table header from floating header if any\r\n\t     * @param {Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n\t     * @return {?Array} Returns an array of header cell nodes or null if `thead` is not specified\r\n\t     * */\n\t\n\t  }, {\n\t    key: 'computeColumns',\n\t    value: function computeColumns(thead, refThead, defaultHeaderRowIndex) {\n\t      var theadCells = TableColumns.getHeaderCells(thead, defaultHeaderRowIndex);\n\t      var refTheadCells = TableColumns.getHeaderCells(refThead, defaultHeaderRowIndex);\n\t      var realColumnIndex = 0;\n\t      return theadCells.map(function (cell, index) {\n\t        var obj = {\n\t          index: realColumnIndex,\n\t          title: cell.textContent,\n\t          cell: cell,\n\t          colSpan: cell.colSpan\n\t        };\n\t        if (refTheadCells != null) {\n\t          obj.refCell = refTheadCells[index];\n\t        }\n\t        // we need to increment the colspan only for columns that follow rowheader because the block is not in data.\n\t        realColumnIndex = realColumnIndex > 0 ? realColumnIndex + cell.colSpan : realColumnIndex + 1;\n\t        return obj;\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return TableColumns;\n\t}();\n\t\n\texports.default = TableColumns;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _tableColumns = __webpack_require__(11);\n\t\n\tvar _tableColumns2 = _interopRequireDefault(_tableColumns);\n\t\n\tvar _rReportalBase = __webpack_require__(1);\n\t\n\tvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\r\n\t * Created by IvanP on 07.09.2016.\r\n\t */\n\twindow.Reportal = window.Reportal || {};\n\t_rReportalBase2.default.mixin(window.Reportal, {\n\t  TableColumns: _tableColumns2.default\n\t});\n\t\n\texports.default = _tableColumns2.default;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\r\n\t * Created by IvanP on 09.09.2016.\r\n\t */\n\t\n\tvar TableColumns = function () {\n\t  /**\r\n\t   * Creates an array of objects corresponding to the cells of `defaultHeaderRow`.\r\n\t   * @param {Object} options - options passed to configure the Sorting\r\n\t   * @param {HTMLTableElement} options.source - source table sorting will be applied to\r\n\t   * @param {HTMLTableElement} options.refSource - floating header if any\r\n\t   * @param {Number|Object} [options.defaultHeaderRow=-1] - index of the row in `thead` (incremented from 0) that will have sorting enabled for columns. If `-1` then last row.\r\n\t   * @return {{index:Number, title:String, colSpan:Number, cell: HTMLTableCellElement, ?refCell:HTMLTableCellElement}} - an array of objects that have this structure\r\n\t   * */\n\t  function TableColumns(options) {\n\t    _classCallCheck(this, TableColumns);\n\t\n\t    var source = options.source,\n\t        refSource = options.refSource,\n\t        _options$defaultHeade = options.defaultHeaderRow,\n\t        defaultHeaderRow = _options$defaultHeade === undefined ? -1 : _options$defaultHeade;\n\t\n\t    var thead = void 0,\n\t        refThead = void 0;\n\t    if (source) {\n\t      thead = TableColumns.getHeader(source);\n\t    } else {\n\t      throw new TypeError('`source` table is not specified, cannot create TableColumns');\n\t    }\n\t    if (refSource) {\n\t      refThead = TableColumns.getHeader(refSource);\n\t    }\n\t    return TableColumns.computeColumns(thead, refThead, defaultHeaderRow);\n\t  }\n\t\n\t  /**\r\n\t   * Gets a header\r\n\t   * @param {HTMLTableElement} source - source table headers are created for\r\n\t   * */\n\t\n\t\n\t  _createClass(TableColumns, null, [{\n\t    key: 'getHeader',\n\t    value: function getHeader(source) {\n\t      if (source && source.tagName == 'TABLE') {\n\t        var header = source.querySelector(\"thead\");\n\t        if (header && header.children.length > 0) {\n\t          return header;\n\t        } else {\n\t          throw new TypeError('`source` table has no header or rows');\n\t        }\n\t      } else {\n\t        throw new TypeError('`source` is not specified or is not a table');\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Calculates defaultHeaderRow for a passed `thead`\r\n\t     * @param {!HTMLTableElement} thead - source table header\r\n\t     * @param {!Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n\t     * @return {{index:Number, row: HTMLTableRowElement}}\r\n\t     * */\n\t\n\t  }, {\n\t    key: 'getDefaultHeaderRow',\n\t    value: function getDefaultHeaderRow(thead, defaultHeaderRowIndex) {\n\t      // calculate default header row\n\t      var headerRows = thead.children,\n\t          headerRowIndex = defaultHeaderRowIndex == -1 ? headerRows.length + defaultHeaderRowIndex : defaultHeaderRowIndex;\n\t      return {\n\t        index: headerRowIndex,\n\t        row: headerRows.item(headerRowIndex)\n\t      };\n\t    }\n\t\n\t    /**\r\n\t     * Gets an array of header cell nodes from default header row\r\n\t     * @param {?HTMLTableElement} thead - source table header\r\n\t     * @param {!Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n\t     * @return {?Array} Returns an array of header cell nodes or null if `thead` is not specified\r\n\t     * */\n\t\n\t  }, {\n\t    key: 'getHeaderCells',\n\t    value: function getHeaderCells(thead, defaultHeaderRowIndex) {\n\t      if (thead) {\n\t        if (defaultHeaderRowIndex != null) {\n\t          var _ret = function () {\n\t            var defaultHeaderRow = TableColumns.getDefaultHeaderRow(thead, defaultHeaderRowIndex);\n\t            var headerRows = thead.children;\n\t            var rowsLength = headerRows.length;\n\t            var abstr = {};\n\t\n\t            var _loop = function _loop(r) {\n\t              var row = headerRows.item(r);\n\t              var augmentIndex = 0; // index that will account for colSpan of upper rows' cells\n\t              [].slice.call(row.children).forEach(function (cell, index) {\n\t                //iterate through cells\n\t                for (var rs = 0; rs <= cell.rowSpan - 1; rs++) {\n\t                  //spread cell across its rowspan\n\t                  var rowA = abstr[r + rs] = abstr[r + rs] || {}; //create row if not exists\n\t                  if (!rowA[augmentIndex]) {\n\t                    //insert cell into slot if not filled\n\t                    rowA[augmentIndex] = cell;\n\t                  } else {\n\t                    //if filled look for the next empty because rowspanned columns fill them in a linear way\n\t                    var i = 0;\n\t                    while (true) {\n\t                      if (!rowA[i]) {\n\t                        rowA[i] = cell;\n\t                        augmentIndex = i;\n\t                        break;\n\t                      }\n\t                      i++;\n\t                    }\n\t                  }\n\t                }\n\t                augmentIndex += cell.colSpan;\n\t              });\n\t            };\n\t\n\t            for (var r = 0; r < rowsLength; r++) {\n\t              _loop(r);\n\t            }\n\t            return {\n\t              v: Object.keys(abstr[defaultHeaderRow.index]).map(function (k) {\n\t                return abstr[defaultHeaderRow.index][k];\n\t              })\n\t            };\n\t          }();\n\t\n\t          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t        } else {\n\t          throw new TypeError('TableColumns.getHeaderCells: defaultHeaderRowIndex is not specified or is not a Number');\n\t        }\n\t      }\n\t      return null;\n\t    }\n\t\n\t    /**\r\n\t     * Gets an array of columns from the table\r\n\t     * @param {!HTMLTableElement} thead - source table header\r\n\t     * @param {!HTMLTableElement} refThead - reference table header from floating header if any\r\n\t     * @param {Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n\t     * @return {?Array} Returns an array of header cell nodes or null if `thead` is not specified\r\n\t     * */\n\t\n\t  }, {\n\t    key: 'computeColumns',\n\t    value: function computeColumns(thead, refThead, defaultHeaderRowIndex) {\n\t      var theadCells = TableColumns.getHeaderCells(thead, defaultHeaderRowIndex);\n\t      var refTheadCells = TableColumns.getHeaderCells(refThead, defaultHeaderRowIndex);\n\t      var realColumnIndex = 0;\n\t      return theadCells.map(function (cell, index) {\n\t        var obj = {\n\t          index: realColumnIndex,\n\t          title: cell.textContent,\n\t          cell: cell,\n\t          colSpan: cell.colSpan\n\t        };\n\t        if (refTheadCells != null) {\n\t          obj.refCell = refTheadCells[index];\n\t        }\n\t        // we need to increment the colspan only for columns that follow rowheader because the block is not in data.\n\t        realColumnIndex = realColumnIndex > 0 ? realColumnIndex + cell.colSpan : realColumnIndex + 1;\n\t        return obj;\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return TableColumns;\n\t}();\n\t\n\texports.default = TableColumns;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _rReportalBase = __webpack_require__(1);\n\t\n\tvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar TableFloatingHeaderStyle = __webpack_require__(17);\n\t\n\t/**\r\n\t * FixedHeader class enables a fixed header appear on tables that have `.reportal-fixed-header` class when the table header is scrolled under address bar.\r\n\t */\n\t\n\tvar TableFloatingHeader = function () {\n\t  /**\r\n\t   * @param {HTMLTableElement} source - source table that needs a cloned header\r\n\t   * */\n\t  function TableFloatingHeader(source) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, TableFloatingHeader);\n\t\n\t    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) == undefined || source.tagName != 'TABLE') {\n\t      throw new TypeError('`source` must be defined and must be a table');\n\t    }\n\t\n\t    TableFloatingHeader.wrapTable(source);\n\t\n\t    /**\r\n\t     *  The cloned floating header without TBODY\r\n\t     *  @type {HTMLTableElement}\r\n\t     *  @memberOf TableFloatingHeader\r\n\t     *  */\n\t    this.header = TableFloatingHeader.cloneHeader(source);\n\t\n\t    /**\r\n\t     *  The source table\r\n\t     *  @type {HTMLTableElement}\r\n\t     *  @memberOf TableFloatingHeader\r\n\t     *  */\n\t    this.source = source;\n\t    /**\r\n\t     *  Visibility status of the table\r\n\t     *  @type {Boolean}\r\n\t     *  @memberOf TableFloatingHeader\r\n\t     *  */\n\t    this.visible = false;\n\t\n\t    this._meta = {\n\t      lastScrollY: 0,\n\t      sourceTHEAD: source.querySelector('thead'),\n\t      ticking: false\n\t    };\n\t\n\t    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n\t\n\t    this.resizeFixed();\n\t\n\t    window.addEventListener(\"resize\", function () {\n\t      return _this.resizeFixed.call(_this);\n\t    }, false); // attach a resize listener to resize the header\n\t    window.addEventListener(\"scroll\", function () {\n\t      return _this.scrollFixed.call(_this);\n\t    }, false); // attach a resize listener to resize the header\n\t  }\n\t\n\t  /**\r\n\t   * calculates offset height of the table\r\n\t   * @param {HTMLTableElement} source - source table\r\n\t   * */\n\t\n\t\n\t  _createClass(TableFloatingHeader, [{\n\t    key: 'requestTick',\n\t\n\t\n\t    /**\r\n\t     * function that polls the callback\r\n\t     * @param {Function} callback - function that's going to be passed to `requestAnimationFrame` for execution\r\n\t     * */\n\t    value: function requestTick(callback) {\n\t      if (!this._meta.ticking) {\n\t        requestAnimationFrame(callback);\n\t        this._meta.ticking = true;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'resizeFixed',\n\t\n\t\n\t    /**\r\n\t     * Calculates widths for all columns in the fixed header based on the `source`\r\n\t     * */\n\t    value: function resizeFixed() {\n\t      this.requestTick(TableFloatingHeader._resizeCallback.bind(this));\n\t    }\n\t  }, {\n\t    key: 'scrollFixed',\n\t\n\t\n\t    /**\r\n\t     * Displays a fixed header when the table header is scrolled off the screen\r\n\t     * */\n\t    value: function scrollFixed() {\n\t      this._meta.lastScrollY = window.pageYOffset;\n\t      this.requestTick(TableFloatingHeader._scrollCallback.bind(this));\n\t    }\n\t  }], [{\n\t    key: 'calcOffsetHeight',\n\t    value: function calcOffsetHeight(source) {\n\t      this._meta.tableOffsetTop = source.parentNode.offsetTop;\n\t      this._meta.tableOffsetBottom = source.parentNode.offsetTop + source.offsetHeight - this._meta.sourceTHEAD.offsetHeight;\n\t    }\n\t\n\t    /**\r\n\t     * Event reporting that a header is visible\r\n\t     * @event TableFloatingHeader~reportal-fixed-header-visible\r\n\t     */\n\t\n\t    /**\r\n\t     * Event reporting that a header is hidden\r\n\t     * @event TableFloatingHeader~reportal-fixed-header-hidden\r\n\t     */\n\t\n\t    /**\r\n\t     * sets visibility of the table\r\n\t     * @param {HTMLTableElement} source - source table\r\n\t     * @param {HTMLTableElement} header - cloned table with header only\r\n\t     * @param {Boolean} visible - visibility status\r\n\t     * @fires TableFloatingHeader~reportal-fixed-header-visible\r\n\t     * @fires TableFloatingHeader~reportal-fixed-header-visible\r\n\t     * */\n\t\n\t  }, {\n\t    key: 'setVisibility',\n\t    value: function setVisibility(source, header, visible) {\n\t      if (visible) {\n\t        header.style.display = 'table';\n\t        source.dispatchEvent(_rReportalBase2.default.newEvent('reportal-fixed-header-visible'));\n\t      } else {\n\t        header.style.display = 'none';\n\t        source.dispatchEvent(_rReportalBase2.default.newEvent('reportal-fixed-header-hidden'));\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * wraps the `source` table into a `div.aggregatedTableContainer`\r\n\t     * */\n\t\n\t  }, {\n\t    key: 'wrapTable',\n\t    value: function wrapTable(source) {\n\t      var wrapper = document.createElement('div');\n\t      wrapper.classList.add('aggregatedTableContainer');\n\t      source.parentNode.appendChild(wrapper);\n\t      wrapper.appendChild(source);\n\t    }\n\t\n\t    /**\r\n\t     * clones header of `source` table and appends to wrapper\r\n\t     * */\n\t\n\t  }, {\n\t    key: 'cloneHeader',\n\t    value: function cloneHeader(source) {\n\t      var header = source.cloneNode(true);\n\t      header.classList.add('fixed');\n\t      source.parentNode.appendChild(header);\n\t      [].slice.call(header.children).forEach(function (child) {\n\t        if (child.nodeName == 'TBODY') {\n\t          header.removeChild(child);\n\t        }\n\t      });\n\t      return header;\n\t    }\n\t  }, {\n\t    key: '_resizeCallback',\n\t    value: function _resizeCallback() {\n\t      var initialHeader = this._meta.sourceTHEAD.querySelectorAll('tr>*'),\n\t          clonedHeader = this.header.querySelectorAll('thead>tr>*'),\n\t          headerWidth = this.source.offsetWidth + 'px',\n\t          widths = [];\n\t      // do reflow\n\t      for (var i = 0; i < initialHeader.length; i++) {\n\t        widths.push(initialHeader[i].offsetWidth);\n\t      }\n\t      //do repaint\n\t      for (var c = 0; c < clonedHeader.length; c++) {\n\t        clonedHeader[c].style.width = widths[c] + 'px';\n\t      }\n\t      this.header.style.width = headerWidth;\n\t\n\t      TableFloatingHeader.calcOffsetHeight.call(this, this.source); //recalc height of the table after reflow\n\t      this._meta.ticking = false;\n\t      this.scrollFixed(); // to compensate top offset in case after resize the table is less in height and top has changed\n\t    }\n\t  }, {\n\t    key: '_scrollCallback',\n\t    value: function _scrollCallback() {\n\t      var offset = this._meta.lastScrollY,\n\t          tableOffsetTop = this._meta.tableOffsetTop,\n\t          tableOffsetBottom = this._meta.tableOffsetBottom;\n\t      if ((offset < tableOffsetTop || offset > tableOffsetBottom) && this.visible) {\n\t        this.visible = false;\n\t        TableFloatingHeader.setVisibility(this.source, this.header, false);\n\t      } else if (offset >= tableOffsetTop && offset <= tableOffsetBottom) {\n\t        this.header.style.top = offset - tableOffsetTop + 'px';\n\t        if (!this.visible) {\n\t          this.visible = true;\n\t          TableFloatingHeader.setVisibility(this.source, this.header, true);\n\t        }\n\t      }\n\t      this._meta.ticking = false;\n\t    }\n\t  }]);\n\t\n\t  return TableFloatingHeader;\n\t}();\n\t\n\texports.default = TableFloatingHeader;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _rReportalBase = __webpack_require__(1);\n\t\n\tvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\t\n\tvar _rAsyncHierarchyTable = __webpack_require__(6);\n\t\n\tvar _rAsyncHierarchyTable2 = _interopRequireDefault(_rAsyncHierarchyTable);\n\t\n\tvar _mapHierarchy = __webpack_require__(14);\n\t\n\tvar _mapHierarchy2 = _interopRequireDefault(_mapHierarchy);\n\t\n\tvar _rAggregatedTable = __webpack_require__(5);\n\t\n\tvar _rAggregatedTable2 = _interopRequireDefault(_rAggregatedTable);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t__webpack_require__(19);\n\t\n\tvar DrilldownMap = function (_MapHierarchy) {\n\t  _inherits(DrilldownMap, _MapHierarchy);\n\t\n\t  /**\n\t   * Creates a drilldown map. It uses a color function `colorFn` that allows colorcode countries\n\t   * `colorFn` accepts two attributes: `value` and `target` and must return a color string based on those two attributes.\n\t   * Make sure hierarchy has `target` loaded from DBDesigner table into each hierarchy level, otherwise a default config `dataClasses` takes precedence on value\n\t   * Example:\n\t   *\n\t   *    {\n\t   *    //some constructor configuration above\n\t   *      colorFn: function(value,target){\n\t   *        return (value!=null && target!=null)? (value - target >= 0) ? \"#18BC9C\" : ((value >= 0.9*target) ? \"#FF4900\" : \"#E45335\") : undefined;\n\t   *      }\n\t   *     //some constructor configuration below\n\t   *    }\n\t   *\n\t   * @param {HTMLTableElement} source - a source drilldown table that contains the initial set of data(with reference group enabled and 1 child level)\n\t   * @param {String} tableID - id of the `source` table that is the initial source of data (from reportal backend)\n\t   * @param {Array} rowheaders - a rowheaders array for the loaded table\n\t   * @param {Object} hierarchy - a hierarchical object for a map to be built upon\n\t   * @param {String} [initMap=\"custom/world-highres2\"] - the initial map object that's going to be loaded to initialise the map\n\t   * @param {String} containerID - id of the container the map will be drawn to\n\t   * @param {Function} mappointCallback - executed when a mappoint (city) is clicked\n\t   * @param {Function} colorFn - A function that allows custom color coding computation based on value and target.\n\t   * @param {Number} [valueColumn=1] - Zero-based column index that contains primary value which will be used for map coloring.\n\t   * @param {Boolean} [fullParentLevelInfo=true] - Display full info of the parent level in right part of the map, rather than the parent level name and the primary value\n\t   * @param {String} [pageStateId=document.querySelector('#PageStateId').value] - PageStateId\n\t   * @param {Object} normals - an object where the keys are the names of columns taken from DBDesignerTable and values - their string types: `string`, `number`, `boolean`, `stringArray`, `numberArray`\n\t   * @param {String} [normalsSeparator=','] - delimiter between values in `stringArray` (`us-ca, us-tx, us-wy`) and `numberArray` (`-31.86,16.38`). They are served as a delimiter-separated string and the delimiter is `,` by default. If you use another one, make sure you specify it here\n\t   * @param {Object} [options={}] - options passed to HighMap to restyle/reconfigure it\n\t   * */\n\t  function DrilldownMap() {\n\t    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t    _classCallCheck(this, DrilldownMap);\n\t\n\t    var source = config.source,\n\t        rowheaders = config.rowheaders,\n\t        hierarchy = config.hierarchy,\n\t        _config$initMap = config.initMap,\n\t        initMap = _config$initMap === undefined ? \"custom/world-highres2\" : _config$initMap,\n\t        containerID = config.containerID,\n\t        mappointCallback = config.mappointCallback,\n\t        excludeColumns = config.excludeColumns,\n\t        excludeRows = config.excludeRows,\n\t        _config$valueColumn = config.valueColumn,\n\t        valueColumn = _config$valueColumn === undefined ? 1 : _config$valueColumn,\n\t        _config$fullParentLev = config.fullParentLevelInfo,\n\t        fullParentLevelInfo = _config$fullParentLev === undefined ? true : _config$fullParentLev,\n\t        _config$colorFn = config.colorFn,\n\t        colorFn = _config$colorFn === undefined ? function (value, target) {\n\t      return value !== null ? value >= 80 ? \"#4caf50\" : value < 80 && value >= 60 ? \"#ffc107\" : \"#ff5722\" : \"blue\";\n\t    } : _config$colorFn,\n\t        _config$pageStateId = config.pageStateId,\n\t        pageStateId = _config$pageStateId === undefined ? document.querySelector('#PageStateId') ? document.querySelector('#PageStateId').value : null : _config$pageStateId,\n\t        tableID = config.tableID,\n\t        normals = config.normals,\n\t        _config$normalsSepara = config.normalsSeparator,\n\t        normalsSeparator = _config$normalsSepara === undefined ? \",\" : _config$normalsSepara,\n\t        _config$options = config.options,\n\t        options = _config$options === undefined ? {} : _config$options;\n\t\n\t    var _this = _possibleConstructorReturn(this, (DrilldownMap.__proto__ || Object.getPrototypeOf(DrilldownMap)).call(this, hierarchy, normals, normalsSeparator));\n\t\n\t    _this.declareGlobals(config, {\n\t      initMap: 'custom/world-highres2',\n\t      valueColumn: 1,\n\t      fullParentLevelInfo: true,\n\t      colorFn: function colorFn(value, target) {\n\t        return value !== null ? value >= 80 ? '#4caf50' : value < 80 && value >= 60 ? '#ffc107' : '#ff5722' : 'blue';\n\t      },\n\t      pageStateId: document.querySelector('#PageStateId') ? document.querySelector('#PageStateId').value : null,\n\t      normalsSeparator: ',',\n\t      options: {}\n\t    }, _this.typeCheck(config));\n\t\n\t    _this.parseTableData();\n\t\n\t    _this.drawMap(rowheaders, containerID, initMap, options);\n\t    return _this;\n\t  }\n\t\n\t  _createClass(DrilldownMap, [{\n\t    key: \"declareGlobals\",\n\t    value: function declareGlobals(options, defaults, typeCheck) {\n\t      var _this2 = this;\n\t\n\t      Object.keys(options).forEach(function (key) {\n\t        var prop = options[key] || defaults[key];\n\t        if (typeCheck && typeCheck[key] && typeof typeCheck[key] === 'function') typeCheck[key](prop);\n\t        _this2[key] = prop;\n\t      });\n\t    }\n\t  }, {\n\t    key: \"typeCheck\",\n\t    value: function typeCheck(opts) {\n\t      if (typeof Highcharts === 'undefined') {\n\t        throw new Error('Highcharts must be declared. Probably they are missing');\n\t      }\n\t      if (typeof Highcharts.maps === 'undefined') {\n\t        throw new Error('HighMaps must be loaded. Probably they are missing');\n\t      }\n\t\n\t      return {\n\t        source: function source() {\n\t          if (!(opts.source && opts.source.localName === 'table')) throw new Error('source table must be specified');\n\t        },\n\t        mappointCallback: function mappointCallback() {\n\t          var cb = opts.mappointCallback;\n\t          if (cb && cb !== null && typeof cb !== 'function') throw new Error('mappointCallback must be a function');\n\t        }\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Parses table passed to it and adds data to `._data` in `hierarchy`\n\t     * @param {HTMLTableElement} source - source table for data\n\t     * @param {Number|Array} excludeRows - rows to be excluded from parsing\n\t     * @param {Array} rowheaders - array of `source` rowheaders\n\t     * @param {Object} flatHierarchy - flat hierarchy object\n\t     * */\n\t\n\t  }, {\n\t    key: \"parseTableData\",\n\t    value: function parseTableData() {\n\t      var source = this.source,\n\t          excludeRows = this.excludeRows,\n\t          rowheaders = this.rowheaders,\n\t          flatHierarchy = this.flatHierarchy,\n\t          excludeColumns = this.excludeColumns;\n\t\n\t      var aggregatedTable = new _rAggregatedTable2.default({ source: source, excludeColumns: excludeColumns, excludeRows: excludeRows });\n\t      if (DrilldownMap.rowHeadersAreValid) {\n\t        rowheaders.forEach(function (rowHeader, i) {\n\t          if (!flatHierarchy[rowHeader]._data) {\n\t            flatHierarchy[rowHeader]._data = aggregatedTable.data[i].map(function (dataItem, index) {\n\t              return {\n\t                value: dataItem.data,\n\t                title: index !== 0 ? aggregatedTable.columns[index].title : \"Region\"\n\t              };\n\t            });\n\t          }\n\t        });\n\t      } else {\n\t        throw new Error('rowheaders must be present to parse data');\n\t      }\n\t    }\n\t  }, {\n\t    key: \"initMap\",\n\t\n\t\n\t    /**\n\t     * Get series for the first time map initialization\n\t     * @param {Object} curLVL - current level in hierarchy\n\t     * @param {Array} [series=[]] - series\n\t     * @returns {Array}\n\t     * */\n\t    value: function initMap(curLVL) {\n\t      var _this3 = this;\n\t\n\t      var series = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t\n\t      curLVL.subcells.forEach(function (subcell) {\n\t        if (subcell.mapID) {\n\t          var seriesItem = _this3.composeSeries(subcell);\n\t          series.push(seriesItem);\n\t        }\n\t      });\n\t      return series;\n\t    }\n\t\n\t    /**\n\t     * Load map from HighMaps map collection\n\t     * @param {String} source\n\t     * @returns {Promise}\n\t     * */\n\t\n\t  }, {\n\t    key: \"getSeriesData\",\n\t\n\t\n\t    /**\n\t     * Creates a single series data for HighMap series option\n\t     * @param {Object} level - a level in hierarchy\n\t     * @returns {Object}\n\t     * */\n\t    value: function getSeriesData(level) {\n\t      var _this4 = this;\n\t\n\t      var drilldown = level.subcells ? level.text : null;\n\t      if (typeof level.mapID === 'string') {\n\t        return [{\n\t          drilldown: drilldown,\n\t          code: level.mapID,\n\t          value: DrilldownMap.getPrimaryValue(level, this.valueColumn),\n\t          data: level._data\n\t        }];\n\t      } else if (Array.isArray(level.mapID)) {\n\t        return level.mapID.map(function (mapID) {\n\t\n\t          return {\n\t            drilldown: drilldown,\n\t            code: mapID,\n\t            value: DrilldownMap.getPrimaryValue(level, _this4.valueColumn),\n\t            data: level._data\n\t          };\n\t        });\n\t      } else {\n\t        throw new Error(\"Data element is corrupted\");\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Executes `colorFn` passed by user to compute color by passing `value` and `target` to it\n\t     * @param {Function} colorFn - color function\n\t     * @param {Number} value - value to test\n\t     * @param {Number} target - target for the level\n\t     * */\n\t\n\t  }, {\n\t    key: \"getCoordinateSeries\",\n\t\n\t\n\t    /**\n\t     * Create a single mappoint series\n\t     * @param {Object} subcell - a single hierarchy element\n\t     * @param {Object} mapData\n\t     * @param {Object} chart - reference to chart object\n\t     * @returns {Object} series for map points\n\t     * */\n\t    value: function getCoordinateSeries(subcell, mapData, chart) {\n\t      var _this5 = this;\n\t\n\t      chart.mapTransforms = mapData ? mapData[\"hc-transform\"] : Highcharts.maps[\"custom/world-highres2\"][\"hc-transform\"];\n\t      var pos = chart.fromLatLonToPoint({ lat: subcell.coordinates[0], lon: subcell.coordinates[1] });\n\t      var config = {\n\t        type: \"mappoint\",\n\t        name: subcell.text,\n\t        marker: {\n\t          lineColor: \"black\",\n\t          lineWidth: 1,\n\t          radius: 4,\n\t          symbol: \"circle\"\n\t        },\n\t        data: [{\n\t          color: DrilldownMap.computeColor(this.colorFn, DrilldownMap.getPrimaryValue(subcell, this.valueColumn), subcell.target),\n\t          name: subcell.text,\n\t          value: subcell.value,\n\t          x: pos.x,\n\t          y: pos.y\n\t        }]\n\t      };\n\t      if (this.mappointCallback) {\n\t        (function () {\n\t          var self = _this5;\n\t          config.events = {\n\t            click: function click(e) {\n\t              self.mappointCallback.call(this, e);\n\t            }\n\t          };\n\t        })();\n\t      }\n\t      return config;\n\t    }\n\t\n\t    /**\n\t     * Creates a single series item for Highmaps series option\n\t     * @param {Object} subcell - a subcell\n\t     * @param {Object} mapData\n\t     * @param {Object} chart - reference to chart object\n\t     * @returns {Object} Returns series\n\t     * */\n\t\n\t  }, {\n\t    key: \"composeSeries\",\n\t    value: function composeSeries(subcell, mapData, chart) {\n\t      if (!subcell.coordinates) {\n\t        mapData = mapData ? Highcharts.geojson(DrilldownMap.createCustomGeoJSON(mapData, subcell.mapID, subcell.text)) : Highcharts.geojson(DrilldownMap.createCustomGeoJSON(Highcharts.maps['custom/world-highres2'], subcell.mapID, subcell.text));\n\t        if (subcell.mapID) {\n\t          var target = subcell.target;\n\t          if (!target || target === null) {\n\t            target = this.hierarchy[0].target;\n\t          }\n\t          return {\n\t            name: subcell.text,\n\t            dataLabels: {\n\t              enabled: true,\n\t              formatter: function formatter() {\n\t                if (this.series.data[0][\"hc-key\"] === this.point[\"hc-key\"]) return this.series.name;\n\t              }\n\t            },\n\t            tooltip: {\n\t              pointFormat: this.getTooltip()\n\t            },\n\t            color: DrilldownMap.computeColor(this.colorFn, DrilldownMap.getPrimaryValue(subcell, this.valueColumn), target),\n\t            allAreas: false,\n\t            parent: subcell.parent.text,\n\t            mapData: mapData,\n\t            joinBy: ['hc-key', 'code'],\n\t            data: this.getSeriesData(subcell)\n\t          };\n\t        }\n\t      } else {\n\t        return this.getCoordinateSeries(subcell, mapData, chart);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * get subcell by text rather than by id\n\t     * @param {Object} curLVL - current level\n\t     * @param {String} name - name of the subcell we're looking for\n\t     * @returns {Object} Returns a subcell which has that name\n\t     * */\n\t\n\t  }, {\n\t    key: \"updateMap\",\n\t\n\t\n\t    /**\n\t     * Updates your map view after drilldown click\n\t     * @param {Object} curLVL\n\t     * @param {Object} chart\n\t     * @param {Object} e - drilldown event object\n\t     * @returns {Object} Returns curLVL\n\t     * */\n\t    value: function updateMap(curLVL, chart, e) {\n\t      var _this6 = this;\n\t\n\t      if (curLVL && curLVL.mapName) {\n\t        // if we have another map to load\n\t        var map = DrilldownMap.loadMap(curLVL.mapName);\n\t        map.then(function (mapData) {\n\t          _this6.addSeries(curLVL, chart, e, mapData);\n\t        });\n\t      } else if (curLVL && !curLVL.mapName) {\n\t        this.addSeries(curLVL, chart, e);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Composes a series for your HighMaps options config\n\t     * @param {Object} curLVL\n\t     * @param {Object} chart\n\t     * @param {Object} e - drilldown event object\n\t     * @param {Object} mapData - mapData geoJSON\n\t     * */\n\t\n\t  }, {\n\t    key: \"addSeries\",\n\t    value: function addSeries(curLVL, chart, e, mapData) {\n\t      var _this7 = this;\n\t\n\t      if (curLVL.subcells) {\n\t        // if it's an end point\n\t        if (curLVL.subcells[0].coordinates) {\n\t          var seriesItem = this.composeSeries(curLVL, mapData, chart);\n\t          seriesItem.data.forEach(function (dataItem) {\n\t            dataItem.drilldown = null;\n\t            dataItem.value = null;\n\t          });\n\t          chart.addSingleSeriesAsDrilldown(e.point, seriesItem);\n\t        }\n\t        curLVL.subcells.forEach(function (subcell) {\n\t          if (!subcell.mapID && !subcell.coordinates) return;\n\t          var seriesItem = _this7.composeSeries(subcell, mapData, chart);\n\t          chart.addSingleSeriesAsDrilldown(e.point, seriesItem);\n\t        });\n\t        chart.applyDrilldown();\n\t      } else {\n\t        var _seriesItem = this.composeSeries(curLVL, mapData, chart);\n\t        _seriesItem.data.map(function (dataItem) {\n\t          dataItem.drilldown = null;\n\t          dataItem.value = null;\n\t        });\n\t        chart.addSeriesAsDrilldown(e.point, _seriesItem);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Generates chart subtitle returning region and main value of full info based on `fullParentLevelInfo`\n\t     * */\n\t\n\t  }, {\n\t    key: \"getTooltip\",\n\t\n\t\n\t    /**\n\t     * Generates a serialized dataset for a tooltip\n\t     * */\n\t    value: function getTooltip() {\n\t      var data = this.curLVL._data;\n\t      return data.map(function (item, index) {\n\t        return \"<span class=\\\"tooltip-level-label\\\">\" + item.title + \":</span><span class=\\\"tooltip-level-value\\\"> {point.data.\" + index + \".value}</span>\";\n\t      }).join(\"<br />\");\n\t    }\n\t\n\t    /**\n\t     * @param {Array} rowheaders - a rowheaders array\n\t     * @param {String} containerID - id of the container to render map to\n\t     * @param {String} initMap - the initial map object that's going to be loaded to initialise the map\n\t     * @param {Object} options - options passed to HighMap to restyle/reconfigure it\n\t     * */\n\t\n\t  }, {\n\t    key: \"drawMap\",\n\t    value: function drawMap(rowheaders, containerID, initMap, options) {\n\t      this.curLVL = this.flatHierarchy[rowheaders[0]];\n\t      var self = this;\n\t      var config = {\n\t        lang: {\n\t          drillUpText: '< to {series.parent}'\n\t        },\n\t        tooltip: {\n\t          pointFormat: self.getTooltip()\n\t        },\n\t        title: {\n\t          text: ''\n\t        },\n\t        legend: {\n\t          enabled: true\n\t        },\n\t        plotOptions: {\n\t          series: {\n\t            states: {\n\t              normal: {\n\t                animation: false\n\t              }\n\t            },\n\t            point: {\n\t              events: {\n\t                mouseOver: function mouseOver(e) {\n\t                  this.series.data.forEach(function (el) {\n\t                    return el.setState(\"hover\");\n\t                  });\n\t                },\n\t                mouseOut: function mouseOut(e) {\n\t                  this.series.data.forEach(function (el) {\n\t                    return el.setState();\n\t                  });\n\t                }\n\t              }\n\t            }\n\t          }\n\t        },\n\t        mapNavigation: {\n\t          enabled: true,\n\t          buttons: {\n\t            zoomIn: {\n\t              verticalAlign: \"bottom\"\n\t            },\n\t            zoomOut: {\n\t              verticalAlign: \"bottom\"\n\t            }\n\t          }\n\t        },\n\t        subtitle: {\n\t          align: 'right',\n\t          text: self.subtitle,\n\t          floating: true\n\t        },\n\t        drilldown: {\n\t          drillUpButton: {\n\t            position: {\n\t              align: \"left\",\n\t              y: 0\n\t            },\n\t            relativeTo: 'spacingBox'\n\t          }\n\t        },\n\t        chart: {\n\t          events: {\n\t            drilldown: function drilldown(e) {\n\t              //this == chart reference;\n\t              //console.log(CircularJSON.parse(CircularJSON.stringify(e.point)));\n\t              var chart = e.target;\n\t              self.curLVL = DrilldownMap.getLevelByName(self.curLVL, e.point.series.name);\n\t              var curLVL = self.curLVL;\n\t              if (curLVL) {\n\t                chart.showLoading('fetching data');\n\t                var table = _rAsyncHierarchyTable2.default.fetchChildTable(curLVL.id, curLVL.parent ? curLVL.parent.id : null, self.tableID, self.pageStateId).then(function (table) {\n\t                  // parse data loaded from table\n\t                  DrilldownMap.parseTableData({\n\t                    source: table,\n\t                    excludeRows: 0,\n\t                    rowheaders: curLVL.subcells.map(function (lvl) {\n\t                      return lvl.id;\n\t                    }),\n\t                    flatHierarchy: self.flatHierarchy\n\t                  });\n\t                  self.updateMap(curLVL, chart, e);\n\t                  chart.subtitle.update({ text: self.subtitle });\n\t                  chart.hideLoading();\n\t                });\n\t              }\n\t            },\n\t            drillupall: function drillupall(e) {\n\t              self.curLVL = self.curLVL.parent;\n\t              if (self.curLVL) {\n\t                e.target.subtitle.update({ text: self.subtitle });\n\t              }\n\t            }\n\t          }\n\t        },\n\t        series: self.initMap(self.curLVL, [{\n\t          showInLegend: false,\n\t          mapData: Highcharts.maps[initMap]\n\t        }])\n\t      };\n\t\n\t      Highcharts.mapChart(containerID, _rReportalBase2.default.mixin(config, options));\n\t    }\n\t  }, {\n\t    key: \"subtitle\",\n\t    get: function get() {\n\t      if (this.fullParentLevelInfo) {\n\t        return this.curLVL._data.map(function (item) {\n\t          return \"<span class=\\\"tooltip-level-label\\\">\" + item.title + \":</span><span class=\\\"tooltip-level-value\\\"> \" + item.value + \"</span>\";\n\t        }).join(\"<br />\");\n\t      } else {\n\t        return this.curLVL._data[0].title + \": \" + this.curLVL._data[0].value + \"<br> \" + this.curLVL._data[this.valueColumn].title + \": \" + this.curLVL._data[this.valueColumn].value;\n\t      }\n\t    }\n\t  }], [{\n\t    key: \"rowHeadersAreValid\",\n\t    value: function rowHeadersAreValid(rowheaders) {\n\t      return rowheaders && rowheaders !== null && rowheaders.length > 0;\n\t    }\n\t\n\t    /**\n\t     * Creates custom geoJSON file\n\t     * @param {Object} mapData - initial map\n\t     * @param {Array}countriesList - list of countries IDs\n\t     * @param {String} mapName\n\t     * @returns {Object}\n\t     * */\n\t\n\t  }, {\n\t    key: \"createCustomGeoJSON\",\n\t    value: function createCustomGeoJSON(mapData, countriesList, mapName) {\n\t      var geojson = {\n\t        title: \"\",\n\t        version: \"0.1.0\",\n\t        type: \"FeatureCollection\",\n\t        copyright: \"Copyright (c) 2015 Highsoft AS, Based on data from Natural Earth\",\n\t        copyrightShort: \"Natural Earth\",\n\t        copyrightUrl: \"http://www.naturalearthdata.com\",\n\t        crs: {\n\t          type: \"name\",\n\t          properties: {\n\t            name: \"urn:ogc:def:crs:EPSG:54003\"\n\t          }\n\t        },\n\t        \"hc-transform\": {\n\t          default: {\n\t            crs: \"+proj=mill +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +R_A +datum=WGS84 +units=m +no_defs\",\n\t            scale: 1.72182781654e-05,\n\t            jsonres: 15.5,\n\t            jsonmarginX: -999,\n\t            jsonmarginY: 9851.0,\n\t            xoffset: -19495356.3693,\n\t            yoffset: 12635908.1982\n\t          }\n\t        },\n\t        features: DrilldownMap.getFeatures(countriesList, mapData)\n\t      };\n\t\n\t      geojson.title = mapName;\n\t      return geojson;\n\t    }\n\t\n\t    /**\n\t     * Get array of features from geoJSON file\n\t     * @param {Array|String} countriesList - countries IDs\n\t     * @param {Object} mapData - your initial map\n\t     * @param {String} key for geojson features comparing\n\t     * @returns {Array} features list\n\t     * */\n\t\n\t  }, {\n\t    key: \"getFeatures\",\n\t    value: function getFeatures(countriesList, mapData) {\n\t      var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"hc-key\";\n\t\n\t      if (typeof countriesList === 'string') {\n\t        return mapData.features.filter(function (feature) {\n\t          return feature.properties[key] === countriesList;\n\t        });\n\t      } else if (Array.isArray(countriesList)) {\n\t        return mapData.features.filter(function (feature) {\n\t          return countriesList.indexOf(feature.properties[key]) !== -1;\n\t        });\n\t      }\n\t    }\n\t  }, {\n\t    key: \"loadMap\",\n\t    value: function loadMap(source) {\n\t      return new Promise(function (resolve, reject) {\n\t        jQuery.getScript('https://code.highcharts.com/mapdata/' + source + '.js', function () {\n\t          resolve(Highcharts.maps[source]);\n\t        });\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Gets the main value that the chart is built on\n\t     * @param {Object} level - level under examination\n\t     * @param {Number} valueColumn - Zero-based column index that contains primary value which will be used for map coloring\n\t     * @returns {Number} Returns primary value\n\t     * */\n\t\n\t  }, {\n\t    key: \"getPrimaryValue\",\n\t    value: function getPrimaryValue(level, valueColumn) {\n\t      return level._data[valueColumn].value;\n\t    }\n\t  }, {\n\t    key: \"computeColor\",\n\t    value: function computeColor(colorFn, value, target) {\n\t      if (colorFn) {\n\t        return colorFn(value, target);\n\t      } else {\n\t        return undefined;\n\t      }\n\t    }\n\t  }, {\n\t    key: \"getLevelByName\",\n\t    value: function getLevelByName(curLVL, name) {\n\t      return curLVL.subcells.filter(function (el) {\n\t        return el.text === name;\n\t      })[0];\n\t    }\n\t  }]);\n\t\n\t  return DrilldownMap;\n\t}(_mapHierarchy2.default);\n\t\n\texports.default = DrilldownMap;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Created by IvanP on 26.12.2016.\n\t */\n\tvar MapHierarchy = function () {\n\t  function MapHierarchy(hierarchy, normals, normalsSeparator) {\n\t    _classCallCheck(this, MapHierarchy);\n\t\n\t    this.flatHierarchy = hierarchy;\n\t    this.hierarchy = this.constructor.processHierarchy(this.flatHierarchy, normals, normalsSeparator);\n\t    this.constructor.addMapIDsToHierarchyLevel(this.hierarchy);\n\t  }\n\t\n\t  /**\n\t   * Processes hierarchy array by assigning parent-child relations and returning those that don't have a parent\n\t   * @param {Object} flatHierarchy - a flat hierarchy object with ids as keys\n\t   * @param {Object} [normals={}] - an object where keys myst coincide with column ids (thus be identical to keys in `item`). `normals` doesn't require for all keys from `item` to be present, only those that need to be normalised to a different type\n\t   * @param {String} [separator=','] - a separator array items are serialized with, by default it's a comma (`,`)\n\t   * */\n\t\n\t\n\t  _createClass(MapHierarchy, null, [{\n\t    key: 'processHierarchy',\n\t    value: function processHierarchy(flatHierarchy) {\n\t      var normals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t      var separator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ',';\n\t\n\t      var orphans = [],\n\t          toNormalize = Object.keys(normals).length > 0;\n\t      for (var key in flatHierarchy) {\n\t        var item = flatHierarchy[key];\n\t        if (toNormalize) MapHierarchy.normalize(item, normals);\n\t\n\t        // map item to parent\n\t        if (item.parent && item.parent != null && item.parent.length > 0) {\n\t          item.parent = flatHierarchy[item.parent];\n\t          item.parent.subcells = item.parent.subcells || [];\n\t          item.parent.subcells.push(item);\n\t        } else {\n\t          orphans.push(item);\n\t        }\n\t      }\n\t      return orphans;\n\t    }\n\t  }, {\n\t    key: 'composeFlatHierarchy',\n\t    value: function composeFlatHierarchy(hierarchy, normals) {\n\t      var o = {};\n\t      var toNormalize = normals.keys().length > 0;\n\t      hierarchy.forEach(function (item) {\n\t        if (toNormalize) MapHierarchy.normalize(item, normals);\n\t        o[item.id] = item;\n\t      });\n\t      return o;\n\t    }\n\t\n\t    /**\n\t     * normalizes a string value to a certain format.\n\t     * - `arrayString` - normalizes comma-separated items to an Array of Strings, i.e \"haha\", \"lala\" would be [\"haha\", \"lala\"]\n\t     * - `arrayNumber` - normalizes comma-separated items to an Array of Floats, i.e \"-13.41\", \"48.66\" would be [-13.41, 48.66]\n\t     * - `string` - returns the string as is\n\t     * - `number` - parses the string as a Float\n\t     * - `boolean` - parses the string as a Boolean, case insensitive\n\t     *\n\t     * @param {Object} item - item to match contents against `normals`\n\t     * @param {Object} [normals={}] - an object where keys myst coincide with column ids (thus be identical to keys in `item`). `normals` doesn't require for all keys from `item` to be present, only those that need to be normalised to a different type\n\t     * @param {String} [separator=','] - a separator array items are serialized with, by default it's a comma (`,`)\n\t     * */\n\t\n\t  }, {\n\t    key: 'normalize',\n\t    value: function normalize(item) {\n\t      var normals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t      var separator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ',';\n\t\n\t      var parser = {\n\t        stringArray: function stringArray(val) {\n\t          return val.split(separator);\n\t        },\n\t        numberArray: function numberArray(val) {\n\t          return val.split(separator).map(function (i) {\n\t            return parseFloat(i);\n\t          });\n\t        },\n\t        string: function string(val) {\n\t          return val.trim();\n\t        },\n\t        number: function number(val) {\n\t          return val != null && !isNaN(parseFloat(val)) ? parseFloat(val) : null;\n\t        },\n\t        boolean: function boolean(val) {\n\t          return val.toLowerCase() == \"true\" || val == \"1\";\n\t        }\n\t      };\n\t      for (var normal in normals) {\n\t        if (item[normal]) {\n\t          // property exists in object\n\t          if (item[normal].length > 0) {\n\t            item[normal] = parser[normals[normal]](item[normal]);\n\t          } else {\n\t            delete item[normal];\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Updates initial hierarchy\n\t     * @param hierarchy\n\t     * @param parent - hierarchy level parent\n\t     */\n\t\n\t  }, {\n\t    key: 'addMapIDsToHierarchyLevel',\n\t    value: function addMapIDsToHierarchyLevel(hierarchy) {\n\t      var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\n\t      hierarchy.forEach(function (subcell) {\n\t        if (subcell.parent && subcell.parent != null && subcell.parent.mapName) {\n\t          subcell.mapName = subcell.parent.mapName;\n\t        }\n\t        if (subcell.subcells) {\n\t          MapHierarchy.addMapIDsToHierarchyLevel(subcell.subcells, subcell);\n\t        }\n\t        if (subcell.parent && subcell.mapID && !subcell.parent.mapName) {\n\t          if (!subcell.parent.mapID) subcell.parent.mapID = [];\n\t          subcell.parent.mapID = subcell.parent.mapID.concat(subcell.mapID);\n\t        }\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return MapHierarchy;\n\t}();\n\t\n\texports.default = MapHierarchy;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 18 */,\n/* 19 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// drilldown-nps-map.bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 716e597abd2d79e91fd3","\nimport DrilldownMap from \"./DrilldownMap\";\nimport ReportalBase from \"r-reportal-base\";\n\nwindow.Reportal = window.Reportal || {};\nReportalBase.mixin(window.Reportal,{\n  DrilldownMap,\n  ReportalBase\n});\n\nexport default DrilldownMap\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js","class ReportalBase {\n\n  /**\n   * Copies props from a source object to a target object.\n   *\n   * Note, this method uses a simple `for...in` strategy for enumerating\n   * properties.  To ensure only `ownProperties` are copied from source\n   * to target and that accessor implementations are copied, use `extend`.\n   *\n   * @method mixin\n   * @param {Object} target Target object to copy properties to.\n   * @param {Object} source Source object to copy properties from.\n   * @return {Object} Target object that was passed as first argument.\n   */\n  static mixin(target, source) {\n    for (var i in source) {\n      target[i] = source[i];\n    }\n    return target;\n  }\n\n  static _logger(level, args) {\n    // accept ['foo', 'bar'] and [['foo', 'bar']]\n    if (args.length === 1 && Array.isArray(args[0])) {\n      args = args[0];\n    }\n    // only accept logging functions\n    switch(level) {\n      case 'log':\n      case 'warn':\n      case 'error':\n        console[level].apply(console, args);\n        break;\n    }\n  }\n\n  static _log() {\n    var args = Array.prototype.slice.call(arguments, 0);\n    this._logger('log', args);\n  }\n\n  static _warn() {\n    var args = Array.prototype.slice.call(arguments, 0);\n    this._logger('warn', args);\n  }\n\n  static _error() {\n    var args = Array.prototype.slice.call(arguments, 0);\n    this._logger('error', args);\n  }\n\n  /**\n   * Creates a named event with `name`\n   * @param {String} name - name of the event\n   * @return {Event} Returns a created event\n   * */\n  static newEvent(name){\n    var event = document.createEvent('Event');\n    event.initEvent(name, true, true);\n    return event;\n  }\n\n  /**\n   * Inspects if the current string might be converted to number and renders it as number. If string length is 0, returns `null`. If none applies returns the string as is.\n   * @param {String} str - value of the cell if not HTML contents\n   * @return {Number|null|String}\n   * */\n  static isNumber(str){\n    if(!isNaN(parseFloat(str))){\n      str = str.replace(/,/i,'');// remove unnecessary comma as a delimiter for thousands from data.\n      return parseFloat(str);\n    } else if(str.length==0){return null} else {return str}\n  }\n\n\n  /**\n   * Creates an XHR wrapped in a Promise\n   * @param {!String} URL - url to send a `GET` request to\n   * @return {Promise} Returns a then-able promise with `XMLHttpRequest.responseText`\n   * */\n  static promiseRequest(URL){\n    return new Promise((resolve,reject)=>{\n      let xhr = new XMLHttpRequest();\n      xhr.open('GET', URL, true);\n      xhr.onload = e=>{xhr.status == 200?resolve(xhr.responseText):reject(Error(`${xhr.status}: ${xhr.statusText}`));}\n      xhr.onerror = e=>{reject(e)}\n      xhr.send();\n    });\n  }\n\n  /**\n   * Gets a variable listed in query string\n   * @param {!String} variable - variable name to get value for\n   * @param {String=} [query=window.location.search.substring(1)] - the query string to search variable for in\n   * @return {String} Returns value for the variable\n   * */\n  static getQueryVariable(variable,query=window.location.search.substring(1)){\n    var vars = query.split(\"&\");\n    for (var i=0;i<vars.length;i++) {\n      var pair = vars[i].split(\"=\");\n      if((pair[0]).toLowerCase() == variable.toLowerCase()){return pair[1];}\n    }\n    return null;\n  }\n\n}\nexport default ReportalBase\n\n\n\n// WEBPACK FOOTER //\n// ./~/r-reportal-base/src/reportal-base.js","/**\r\n * Created by IvanP on 21.09.2016.\r\n */\r\nimport ReportalBase from \"r-reportal-base\";\r\n//import TableDataRowMeta from \"./TableDataRowMeta\";\r\n\r\n/**\r\n * A base class for stripping data from HTML tables\r\n * */\r\nclass TableData {\r\n  /**\r\n   * Detects if the dataset is multi-dimentional and sets classes on items: a rowspanning cell gets a `.blockCell` and the row containing it a `.firstInBlock`\r\n   * __Doesn't work with `Horizontal Percents` enabled!__\r\n   * @param {HTMLTableElement} source - source table\r\n   * @return {Boolean} Returns if the data in table is multi-dimentional\r\n   * */\r\n  static detectMultidimensional(source){\r\n    let multidimensional = false;\r\n    let blocks = source.parentNode.querySelectorAll(`table#${source.id}>tbody>tr>td:nth-child(1)[rowspan]`);\r\n    if(blocks.length>0){\r\n      multidimensional = true;\r\n      [].slice.call(blocks).forEach(blockCell=>{\r\n        blockCell.classList.add('blockCell');\r\n        blockCell.parentNode.classList.add('firstInBlock');\r\n      });\r\n    }\r\n    return multidimensional\r\n  }\r\n\r\n  /**\r\n   * Extracts data from a given cell. Override in an inherited class if you need to add any metadata to it.\r\n   * @param {HTMLTableCellElement} cell - cell element to have data stripped off it\r\n   * @param {HTMLTableCellElement} rowIndex - index of the row it's in\r\n   * @param {HTMLTableCellElement} columnIndex - index of the column it's in\r\n   * @returns {?String|?Number} Returns a `String`, a `Number` or a `null` (if data is absent in the cell or its text content boils down to an empty string - i.e. there are no characters in the cell, only HTML tags)\r\n   * */\r\n  static prepareDataCell(cell, rowIndex, columnIndex){\r\n   return ReportalBase.isNumber(cell.textContent.trim());\r\n    /*return {\r\n        cell,\r\n        data: ReportalBase.isNumber(cell.textContent.trim()),\r\n        rowIndex,\r\n        columnIndex\r\n      }*/\r\n  }\r\n\r\n  /**\r\n   * A universal data-extraction function. It strips data from a table's body. Data can be stripped by rows (horizontally) or by columns (vertically) which is controlled by `direction`. It accounts for a spanning block cell and may exclude it.\r\n   * @param {Object} options - options to configure the way data is stripped off the table\r\n   * @param {HTMLTableElement} options.source - source table that will be an input for data stripping\r\n   * @param {String=} options.direction='row' - direction in which data stripping will occur: `row` strips across rows and presents an array where each array item is an array of cell values. `column` strips values verticaly in a column, the resulting array will contain arrays (per column) with values resembling normalized data for cells in the column\r\n   * @param {Boolean=} [options.excludeBlock=true] - if table contains block cells that rowspan across several rows, we might need to exclude those from actual data\r\n   * @param {Array|Number} [options.excludeColumns] - if table contains columns that are not to be in data, then pass a single index or an array of cell indices (0-based). You need to count columns not by headers but by the cells in rows.\r\n   * @param {Array|Number} [options.excludeRows] - if table contains rows that are not to be in data, then pass a single index or an array of row indices (0-based). You need to count only rows that contain data, not the table-header rows.\r\n   * @param {Boolean=} options.multidimensional=false - whether the table has aggregating cells that aggregate rowheaders. Result of {@link TableData#detectMultidimensional} may be passed here to automatically calculate if it has aggregating cells.\r\n   * @returns {Array} returns data array.\r\n   * */\r\n  static getData(options){\r\n    let {source,excludeBlock=true,excludeColumns,excludeRows,direction='row',multidimensional=false}=options;\r\n    let data = [];\r\n    if(source && source.tagName == 'TABLE'){\r\n      let rows = [].slice.call(source.parentNode.querySelectorAll(`table#${source.id}>tbody>tr`));\r\n      if(rows.length>0){\r\n        let tempArray=[];\r\n        // account for a negative row number (`-1`) meaning last row\r\n        if(typeof excludeRows != undefined){\r\n          if(typeof excludeRows == 'number'){\r\n            // for non-block rows in multidimensional\r\n            if(excludeRows<0){ // account for a negative column number (e.g.`-1`) meaning last column\r\n              excludeRows= rows.length+excludeRows;\r\n            }\r\n            rows.splice(excludeRows,1);\r\n          }\r\n          if(Array.isArray(excludeRows)){\r\n            excludeRows.sort((a,b)=>{return a>b?1:-1}).reverse(); //sort to splice from the end of the array\r\n            excludeRows.forEach(i=>{\r\n              if(i>=0){\r\n                rows.splice(i,1);\r\n              } else {\r\n                rows.splice(rows.length+i,1);\r\n              }\r\n            });\r\n\r\n          }\r\n        }\r\n        rows.forEach((row,rowIndex)=>{\r\n          if(multidimensional){\r\n            // we need to check if the `tempArray` is not empty and push it to the `data` array, because we've encountered a new block, so the old block has to be pushed to data. Then we need to create a new block array and push there\r\n            if(row.classList.contains('firstInBlock')){\r\n              if(Array.isArray(tempArray) && tempArray.length>0){data.push(tempArray);}\r\n              tempArray = [];\r\n            }\r\n          }\r\n\r\n          if (direction=='row' && !Array.isArray(tempArray[tempArray.length])) { // if a row in an array doesn't exist create it\r\n            tempArray[tempArray.length] = [];\r\n          }\r\n\r\n          // calculate which cells to exclude\r\n          let cells = [].slice.call(row.children);\r\n          let temp_excludeColumns = excludeColumns;\r\n          if(typeof temp_excludeColumns != undefined){\r\n            if(typeof temp_excludeColumns == 'number'){\r\n              // for non-block rows in multidimensional\r\n              if(multidimensional && !row.classList.contains('firstInBlock') && !temp_excludeColumns<0){\r\n                temp_excludeColumns=temp_excludeColumns+1;\r\n              }\r\n              if(temp_excludeColumns<0){ // account for a negative column number (e.g.`-1`) meaning last column\r\n                temp_excludeColumns= cells.length+temp_excludeColumns;\r\n              }\r\n              cells.splice(temp_excludeColumns,1);\r\n            }\r\n            if(Array.isArray(temp_excludeColumns)){\r\n              temp_excludeColumns.sort((a,b)=>{return a>b?1:-1}).reverse();\r\n              temp_excludeColumns.forEach(i=>{\r\n                if(i>=0){\r\n                  cells.splice(multidimensional && !row.classList.contains('firstInBlock')?i+1:i,1);\r\n                } else {\r\n                  cells.splice(cells.length+i,1);\r\n                }\r\n              });\r\n            }\r\n          }\r\n\r\n          cells.forEach((cell, index) => {\r\n\r\n            // we want to run this every row because number of cells in each row may differ and we want to exclude the last one\r\n            if (typeof direction == 'string' && direction == 'row') { //if we strip data horizontally by row\r\n              if(!(multidimensional && excludeBlock && cell.rowSpan>1)){ // if it's a block cell we'd exclude it from data\r\n                tempArray[tempArray.length-1].push(this.prepareDataCell(cell,rowIndex,index));\r\n              }\r\n            } else if (typeof direction == 'string' && direction == 'column') { //if we strip data vertically by column\r\n              let realIndex = index;\r\n              if(!(multidimensional && excludeBlock && cell.rowSpan>1)){ //exclude block cell\r\n                realIndex += !row.classList.contains('firstInBlock')? 0 : -1; // offset cell that follows block cell one position back\r\n                if (!Array.isArray(tempArray[realIndex])) { //create column array for current column if not available\r\n                  tempArray[realIndex] = [];\r\n                }\r\n                tempArray[realIndex].push(this.prepareDataCell(cell,rowIndex,realIndex));\r\n              }\r\n            } else {\r\n              throw new TypeError('direction has tobe a String==`row | column`, not a ${direction}')\r\n            }\r\n          });\r\n        });\r\n        //we need to push the last block Array because there'll be no `.firstInBlock` anymore to do that\r\n        if(multidimensional && Array.isArray(tempArray) && tempArray.length>0){\r\n          data.push(tempArray)\r\n        } else {\r\n          data = tempArray;\r\n        }\r\n      } else {\r\n        throw new Error(`table#${source.id}'s body must contain rows`);\r\n      }\r\n    } else {\r\n      throw new TypeError('source must be defined and be a table');\r\n    }\r\n    return data;\r\n  }\r\n\r\n}\r\n\r\nexport default TableData\r\n\n\n\n// WEBPACK FOOTER //\n// ./~/r-aggregated-table/src/table-data.js","/**\r\n * Created by IvanP on 17.08.2016.\r\n */\r\n/**\r\n * @property {HTMLTableRowElement} row - reference to the `<tr>` element\r\n * @property {?String} id - internal Reportal id for the rowheader in the row\r\n * @property {!HTMLTableCellElement} nameCell - reference to the `<td>` element that contains the rowheader label/name\r\n * @property {String} [name=nameCell.textContent] - label of the rowheader.\r\n * @property {?Object} [block=null] - the block the row belongs to\r\n * @property {Boolean} firstInBlock - this `row` is first in the `block`, which means it contains the first cell as a block cell\r\n * */\r\nclass AggregatedTableRowMeta {\r\n  /**\r\n   * Builds a prototype for each row of an Aggregated Table\r\n   * @param {HTMLTableRowElement} row - reference to the `<tr>` element\r\n   * @param {?String} id - internal Reportal id for the rowheader in the row\r\n   * @param {!HTMLTableCellElement} nameCell - reference to the `<td>` element that contains the rowheader label/name\r\n   * @param {String=} [name=nameCell.textContent] - label of the rowheader.\r\n   * @param {?Object} [block=null] - the block the row belongs to\r\n   * */\r\n  constructor({row, id=null, nameCell, name, block=null}={}){\r\n    /*** @property {HTMLTableRowElement} row - reference to the `<tr>` element*/\r\n    this.row = row;\r\n    this.id = id;\r\n    this.nameCell = nameCell;\r\n    this.name = name || nameCell.textContent.trim();\r\n    this.block = block;\r\n    this.firstInBlock = block!=null && this.row.rowIndex === this.block.cell.parentNode.rowIndex;\r\n  }\r\n  /*get firstInBlock(){\r\n    return this._firstInBlock;\r\n  }\r\n  set firstInBlock(val){\r\n    this._firstInBlock = val;\r\n    val?this.row.classList.add('firstInBlock'):this.row.classList.remove('firstInBlock');\r\n  }*/\r\n}\r\nexport default AggregatedTableRowMeta\r\n\n\n\n// WEBPACK FOOTER //\n// ./~/r-aggregated-table/src/aggregated-table-row-meta.js","/**\r\n * Created by IvanP on 27.09.2016.\r\n */\r\n\r\nimport TableData from './table-data';\r\nimport ReportalBase from \"r-reportal-base\";\r\nimport TableColumns from \"r-table-columns\";\r\nimport SortTable from \"r-sort-table/src/sort-table\";\r\nimport TableFloatingHeader from \"r-table-floating-header/src/table-floating-header\";\r\n\r\nlet styles = require('r-sort-table/src/sort-table-styles.css');\r\nlet aggregatedTableCSS = require('./aggregated-table.css');\r\n\r\n/**\r\n * A base class for aggregated tables. Multidimensional property of data is automatically calculated, thus removed from params.\r\n * @extends TableData\r\n * */\r\nclass AggregatedTable extends TableData {\r\n  /*\r\n   * @param {Object} options - options to configure the way data is stripped off the table\r\n   * @param {HTMLTableElement} options.source - source table that will be an input for data stripping\r\n   * @param {HTMLTableElement} [options.refSource] - a reference to a floating header, if any\r\n   * @param {Number} [options.rowheaderColumnIndex=0] - 0-based index of the column that we need to check against to see if it's a multidimentional table\r\n   * @param {Number|Object=} [options.defaultHeaderRow=-1] - index of the row in `thead` (incremented from 0) that will have sorting enabled for columns. If `-1` then last row.\r\n   * @param {String=} options.dataStripDirection='row' - direction in which data stripping will occur: `row` strips across rows and presents an array where each array item is an array of cell values. `column` strips values verticaly in a column, the resulting array will contain arrays (per column) with values resembling normalized data for cells in the column\r\n   * @param {Boolean=} [options.excludeBlock=true] - if table contains block cells that rowspan across several rows, we might need to exclude those from actual data\r\n   * @param {Array|Number} [options.excludeColumns] - if table contains columns that are not to be in data, then pass a single index or an array of cell indices (0-based). You need to count columns not by headers but by the cells in rows.\r\n   * @param {Array|Number} [options.excludeRows] - if table contains rows that are not to be in data, then pass a single index or an array of row indices (0-based). You need to count only rows that contain data, not the table-header rows.\r\n   * @param {SortTable} options.sorting - sorting options, see {@link SortTable}. If you want to leave all options default but enable sorting, pass an empty object(`.., sorting:{}`), or sorting won't be applied.\r\n   * @param {SortTable} options.floatingHeader - floating header, see {@link SortTable}. If you want to leave all options default but enable sorting, pass an empty object(`.., sorting:{}`), or sorting won't be applied.\r\n   * */\r\n  constructor(options){\r\n    let {\r\n      source,\r\n      rowheaderColumnIndex,defaultHeaderRow,dataStripDirection,excludeBlock,excludeColumns,excludeRows,\r\n      sorting,\r\n      floatingHeader\r\n    } = options;\r\n    super();\r\n\r\n    /**\r\n     *  The source table\r\n     *  @type {HTMLTableElement}\r\n     *  @memberOf AggregatedTable\r\n     *  */\r\n    this.source = source;\r\n    let refSource;\r\n    if(floatingHeader && typeof floatingHeader=='object'){\r\n      this.floatingHeader = new TableFloatingHeader(source);\r\n      /**\r\n       *  The floating header\r\n       *  @type {HTMLTableElement}\r\n       *  @memberOf AggregatedTable\r\n       *  */\r\n      this.refSource = refSource = this.floatingHeader.header;\r\n    }\r\n\r\n    /**\r\n     *  Whether data is monodimensional or multidimensional\r\n     *  @type {Boolean}\r\n     *  @memberOf AggregatedTable\r\n     *  */\r\n\r\n    this.multidimensional = this.constructor.detectMultidimensional(source);\r\n\r\n    /**\r\n     *  data Array\r\n     *  @type {Array.<{cell:HTMLTableCellElement, data:?String|?Number, columnIndex:Number}>}\r\n     *  @memberOf AggregatedTable\r\n     *  */\r\n    this.data = this.constructor.getData({source,refSource,defaultHeaderRow,excludeBlock,excludeColumns,excludeRows,direction:dataStripDirection,multidimensional: this.multidimensional});\r\n\r\n\r\n    if(sorting && typeof sorting == 'object'){\r\n      let reorderFunction = e=>{\r\n        return this.constructor.reorderRows(this.data,this.source,this.multidimensional)\r\n      };\r\n      [source,refSource].forEach(target=>{\r\n        if(target){\r\n          target.addEventListener('reportal-table-sort', reorderFunction)\r\n        }\r\n      });\r\n\r\n      sorting.source = source;\r\n      sorting.refSource = refSource;\r\n      sorting.defaultHeaderRow = defaultHeaderRow;\r\n      sorting.data=this.data;\r\n      sorting.multidimensional = this.multidimensional;\r\n\r\n      /**\r\n       *  sorting object. See {@link SortTable}\r\n       *  @type {SortTable}\r\n       *  @memberOf AggregatedTable\r\n       *  */\r\n      this.sorting = new SortTable(sorting);\r\n\r\n      // add listener to do reordering on sorting\r\n    }\r\n\r\n    /**\r\n     * table columns array\r\n     * @type {Array.<{index:Number, title:String, colSpan:Number, cell: HTMLTableCellElement, ?refCell:HTMLTableCellElement}>}\r\n     * @memberOf AggregatedTable\r\n     * */\r\n    this.columns = this.sorting && this.sorting.columns? this.sorting.columns : new TableColumns({source,refSource,defaultHeaderRow});\r\n  }\r\n\r\n\r\n  /**\r\n   * Extracts data from a given cell. Override in an inherited class if you need to add any metadata to it.\r\n   * @param {HTMLTableCellElement} cell - cell element to have data stripped off it\r\n   * @param {HTMLTableCellElement} rowIndex - index of the row it's in\r\n   * @param {HTMLTableCellElement} columnIndex - index of the column it's in\r\n   * @returns {{cell:HTMLTableCellElement, ?data:String|Number, columnIndex:Number}} Returns an object `{cell:HTMLTableCellElement, data:?String|?Number, columnIndex:Number}` (if data is absent in the cell or its text content boils down to an empty string - i.e. there are no characters in the cell, only HTML tags) it returns null in `data`\r\n   * @override\r\n   * */\r\n  static prepareDataCell(cell, rowIndex, columnIndex){\r\n    return {\r\n      cell,\r\n      data: ReportalBase.isNumber(cell.textContent.trim()),\r\n      columnIndex,\r\n      rowIndex\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This function takes care of repositioning rows in the table to match the `data` array in the way it was sorted and if the data is separated into blocks, then move the block piece to the first row in each data block.\r\n   * @param {Array} data - full sorted dataset. Instance of {@link TableData#getData}\r\n   * @param {HTMLTableElement} source - source table\r\n   * @param {Boolean} multidimensional\r\n   * */\r\n  static reorderRows(data,source,multidimensional){\r\n    let fragment = document.createDocumentFragment();\r\n    AggregatedTable.dimensionalDataIterator(data,multidimensional,(dataDimension)=>{\r\n      if(multidimensional){AggregatedTable.repositionBlockCell(dataDimension)} // if multidimensional reposition aggregating block cell to the topmost row in sorted array\r\n      dataDimension.forEach(item=>{fragment.appendChild(item[0].cell.parentNode)}); // add row to fragment in the array order, this doesn't account for column stripped data yet\r\n    });\r\n    source.querySelector('tbody').appendChild(fragment);\r\n  }\r\n\r\n  /*\r\n   * Repositions the rowspanning block cell from the initial row to the new sorted row\r\n   * @param {Array} items - dimension of data\r\n   * */\r\n  static repositionBlockCell(items){\r\n    let blockRowItem = items.filter(item=>item[0].cell.parentNode.classList.contains('firstInBlock'))[0];\r\n    let blockRow = blockRowItem[0].cell.parentNode;\r\n    if(items.indexOf(blockRowItem)!=0){// if block row isn't first in dimension\r\n      let newFirstRow = items[0][0].cell.parentNode;\r\n      newFirstRow.insertBefore(blockRow.querySelector('.blockCell'),newFirstRow.firstElementChild);// move block cell\r\n      newFirstRow.classList.add('firstInBlock');\r\n      blockRow.classList.remove('firstInBlock');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * allows to perform action on data based on its multidimensionality\r\n   * @param {Array} data - full dataset. Instance of {@link TableData#getData}\r\n   * @param {Boolean} multidimensional\r\n   * @param {!Function} callback - a function to be executed on a dimension of data. Callback is called with two attributes: `dimension` - the current iteration of data and `index` (optional) if it's multidimensional\r\n   * */\r\n  static dimensionalDataIterator(data,multidimensional,callback){\r\n    if(!callback || typeof callback != 'function'){throw new TypeError('`callback` must be passed and be a function')}\r\n    if(!multidimensional){\r\n      return callback(data)\r\n    } else { // if array has nested array blocks\r\n      data.forEach((dimension,index)=>{\r\n        callback(dimension,index);\r\n      });\r\n    }\r\n  }\r\n\r\n\r\n}\r\n\r\nexport default AggregatedTable\r\n\n\n\n// WEBPACK FOOTER //\n// ./~/r-aggregated-table/src/aggregated-table.js","/**\r\n * Created by IvanP on 07.09.2016.\r\n */\r\n\r\nimport TableData from \"./table-data\";\r\nimport AggregatedTable from \"./aggregated-table\";\r\nimport ReportalBase from \"r-reportal-base\";\r\nimport AggregatedTableRowMeta from \"./aggregated-table-row-meta\";\r\n\r\n\r\nwindow.Reportal = window.Reportal || {};\r\nReportalBase.mixin(window.Reportal,{\r\n  TableData,\r\n  AggregatedTable,\r\n  AggregatedTableRowMeta\r\n});\r\n\r\nexport default AggregatedTable\r\n\n\n\n// WEBPACK FOOTER //\n// ./~/r-aggregated-table/src/main.js","/**\r\n * Created by IvanP on 15.12.2016.\r\n */\r\nimport ReportalBase from \"r-reportal-base\";\r\n\r\n/**\r\n * A class that provides utility static methods to load children of a level of hiererachy and a table per a given id\r\n * */\r\nclass AsyncHierarchyTable{\r\n  /**\r\n   * Queries if each row might contain child rows by quering hierarchy for next level\r\n   * @param {!String} id - rowheader id for current row\r\n   * @param {!Number} hierarchyID - id of Hierarchy in Table Designer\r\n   * @param {!String} hierarchyControlID - id of the Reportal Hierarchy Component instance on the page\r\n   * @param {!String} pageStateID - Reportal state id\r\n   * @param {Number=} languageCode=9 - Language code (according to Confirmit table of language codes) of the language the hierarchy is going to be streamed in at the page load\r\n   * @returns {Array} array of child nodes of the `id` in hierarchy\r\n   * */\r\n  static fetchChildHierarchy(id,hierarchyID,hierarchyControlID,pageStateID,languageCode=9){\r\n    let path = [\r\n      location.origin,\r\n      'reportal',\r\n      'Hierarchy',\r\n      ReportalBase.getQueryVariable('ReportId'),\r\n      hierarchyID,\r\n      languageCode,\r\n      'GetChildNodes'\r\n    ];\r\n\r\n    let query=[\r\n      `nodeId=${id}`,\r\n      `info=${AsyncHierarchyTable.encode({\r\n        IsPreview:ReportalBase.getQueryVariable('Preview')==='true',\r\n        HierarchyControlId:hierarchyControlID\r\n      })}`,\r\n      'isRepBase=false',\r\n      'parameter=',\r\n      `PageStateId=${pageStateID}`\r\n    ];\r\n\r\n    let hierarchyItemChildren = ReportalBase.promiseRequest([path.join('/'),'?',query.join('&')].join(''));\r\n    return hierarchyItemChildren.then(response=>{return Promise.resolve(JSON.parse(response))});\r\n  }\r\n\r\n  /**\r\n   * Gets row nodes that are child to the parent row#`id`\r\n   * @param {!String} id - rowheader id for current row\r\n   * @param {?String} parentID - rowheader id for parent row\r\n   * @param {!String} tableID - Reportal Aggregated Table Component id\r\n   * @param {!String} pageStateID - Reportal state id\r\n   * @return {Promise} Returns a thenable promise which result is an `HTMLTableElement` with rows that are children to the row#`id`\r\n   * */\r\n  static fetchChildTable(id, parentID, tableID,pageStateID){\r\n    parentID = parentID!=null?parentID:id;\r\n    let path = [\r\n      location.origin,\r\n      'reportal',\r\n      'Report',\r\n      ReportalBase.getQueryVariable('ReportId'),\r\n      'Component',\r\n      tableID\r\n    ];\r\n    let query=[\r\n      `PageId=${ReportalBase.getQueryVariable('PageId')}`,\r\n      `Preview=${ReportalBase.getQueryVariable('Preview')}`,\r\n      `PageStateId=${pageStateID}`,\r\n      `pageFilters=${AsyncHierarchyTable.encode({})}`,\r\n      `customFilters=${AsyncHierarchyTable.encode({})}`,\r\n      `persNodes=${AsyncHierarchyTable.encode([{NodeId:id,Text:null}])}`, // child node id\r\n      `origNodes=${AsyncHierarchyTable.encode([{NodeId:parentID,Text:null}])}` // parent node id\r\n    ];\r\n    let tableResult = ReportalBase.promiseRequest([path.join('/'),'?',query.join('&')].join(''));\r\n    return tableResult.then(response=>{\r\n      let host = document.createElement('span');\r\n      host.innerHTML = response;\r\n      return Promise.resolve(host.querySelector('table'));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Strips rows from the table received\r\n   * @param {HTMLTableElement} table - Aggregated table element\r\n   * @param {Array} excludedRows - rows excluded from insertion\r\n   * @return {Array} Returns an array of rows {HTMLTableRowElement}\r\n   * */\r\n  static stripRowsFromResponseTable(table,excludedRows){\r\n    let rows = [].slice.call(table.querySelectorAll('tbody>tr'));\r\n    if(excludedRows && excludedRows.length>0){\r\n      excludedRows.reverse().forEach(index=>{\r\n        rows.splice(index, 1);\r\n      });\r\n    }\r\n    return rows;\r\n  }\r\n\r\n  /**\r\n   * Does `JSON.stringify` and `encodeURIComponent` of anything passed to be added to the query string\r\n   * @param {String|Object|Array} toEncode - piece to be URLencoded\r\n   * @returns {String} Returns an encoded string\r\n   * */\r\n  static encode(toEncode){\r\n    return encodeURIComponent(JSON.stringify(toEncode));\r\n  }\r\n\r\n}\r\n\r\nexport default AsyncHierarchyTable;\r\n\r\n\r\nwindow.Reportal = window.Reportal || {};\r\nReportalBase.mixin(window.Reportal,{\r\n  AsyncHierarchyTable\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./~/r-async-hierarchy-table/src/main.js","class SortOrder {\r\n  /**\r\n   * Creates a `sortOrder` array\r\n   * @param {Object} options - configuration options\r\n   * @param {Object} options.columns - an array of columns from {@link TableColumns}\r\n   * @param {Function} options.sortCallback - function that performs sorting based on the `sortOrder`\r\n   * @param {Object} options.sortCallbackScope - scope in which sort callback needs to be executed\r\n   * @param {Object} [options.defaultSorting] - an array of objects that specify default sorting\r\n   * @param {Number} options.defaultSorting.column - column index\r\n   * @param {String} options.defaultSorting.direction - sort direction (`asc`|`desc`)\r\n   * @return {Array}\r\n   * */\r\n  constructor(options){\r\n    let {columns, sortCallback, defaultSorting=[], sortCallbackScope=this} = options;\r\n\r\n    this.sortOrder = [];\r\n    if(typeof columns != undefined && columns != null){\r\n      this.columns = columns;\r\n    } else {\r\n      throw new TypeError('SortOrder: columns must be specified');\r\n    }\r\n    this.sort = ()=>{\r\n      if(sortCallback && typeof sortCallback === 'function'){\r\n        sortCallback.call(sortCallbackScope,this)\r\n      }\r\n    };\r\n    if(defaultSorting.length>0){\r\n      defaultSorting.forEach(item=>this.add(item));\r\n      this.sort();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns an array containing a `cell` from the table and a reference cell (`refCell`) from the floating header if any\r\n   * @param {!Number} columnIndex - index of the column from the array of columns from {@link TableColumns}\r\n   * @return {{cell:HTMLTableCellElement, refCell:HTMLTableCellElement}}\r\n   * */\r\n  getCell(columnIndex){\r\n    if(typeof columnIndex != 'undefined' && columnIndex!=null){\r\n      let cells = [];\r\n      if(this.columns[columnIndex].cell){cells.push(this.columns[columnIndex].cell)}\r\n      if(this.columns[columnIndex].refCell){cells.push(this.columns[columnIndex].refCell)}\r\n      return cells;\r\n    } else {\r\n      throw new TypeError('columnIndex parameter should not be null');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds another column to be sorted\r\n   * @param {!Object} obj - object describing sorting\r\n   * @param {Number} obj.column - column index\r\n   * @param {String} obj.direction - sort direction (`asc`|`desc`)\r\n   * */\r\n\r\n  add (obj){\r\n    this.getCell(obj.column).forEach(cell=>{\r\n      //if(!cell.classList.contains('sorted')){ // this column is not sorted, there might be others that are.\r\n        ['sorted',obj.direction].forEach(className=>cell.classList.add(className));\r\n      //} else { //swaps sorting from asc to desc\r\n      //  ['asc','desc'].forEach(className=>cell.classList.toggle(className));\r\n      //}\r\n    });\r\n    this.sortOrder.push(obj);\r\n  }\r\n\r\n  /**\r\n   * Removes a column from `sortOrder`\r\n   * @param {Number} column - column index as reference to the item to be removed.\r\n   * @param {Number} index - index of item in `sortOrder` array to be removed\r\n   * */\r\n  remove (column,index){\r\n    ['sorted','asc','desc'].forEach(className=>{\r\n      this.getCell(column).forEach(cell=>cell.classList.remove(className))\r\n    });\r\n    this.sortOrder.splice(index,1);\r\n  };\r\n\r\n  /**\r\n   * Replaces all items in `sortOrder`\r\n   * @param {!Object} obj - object describing sorting\r\n   * @param {Number} obj.column - column index\r\n   * @param {String} obj.direction - sort direction (`asc`|`desc`)\r\n   * */\r\n  replace (obj){\r\n    if(this.sortOrder.length>0){\r\n      this.sortOrder.forEach((item,index)=>{\r\n        this.remove(item.column,index);\r\n      });\r\n    }\r\n    this.add(obj);\r\n    this.sort();\r\n  };\r\n}\r\nexport default SortOrder;\r\n\n\n\n// WEBPACK FOOTER //\n// ./~/r-sort-table/src/sort-order.js","import ReportalBase from \"r-reportal-base\";\r\nimport TableColumns from \"./table-columns\";\r\nimport SortOrder from \"./sort-order\";\r\n\r\n/**\r\n * Event reporting that a table has been sorted\r\n * @event SortTable~reportal-table-sort\r\n */\r\n\r\n/**\r\n * Makes a table sortable, gives API for sorting. It sorts `data` array, but doesn't move rows in the `source` table, because of differences in implementation.\r\n *\r\n * > Note: It's important that every Array item that is going to be sortable was either a `String`, a `Number`, a `null`, or an `Object` that contained `data` property (which was of the previously named types)\r\n *\r\n * @param {Object} options - options passed to configure the Sorting\r\n * @param {HTMLTableElement} options.source - source table sorting will be applied to\r\n * @param {HTMLTableElement} [options.refSource] - the floating header if any, will reflect and trigger sorting on header when scrolled.\r\n * @param {Number} [options.defaultHeaderRow=-1] - index of the row in `thead` (incremented from 0) that will have sorting enabled for columns. If `-1` then last row.\r\n * @param {Array} [options.included] - Array of column indices (incremented from 0) that will have sorting enabled. If not specified, all columns will be sortable. Optionally `excluded` can be specified instead as a shorthand to pass only indices of columns to be excluded from sorting, assumning that others will be made sortable. It's important to count the column index in the defaultHeaderRow\r\n * @param {Array} [options.excluded] - Array of column indices (incremented from 0) that will be excluded from sorting. Can be used as a shorthand instead of `included`.\r\n * @param {Object} [options.defaultSorting] - an array of objects that specify default sorting\r\n * @param {Number} options.defaultSorting.column - column index\r\n * @param {String} options.defaultSorting.direction - sort direction (`asc`|`desc`)\r\n * @param {Array} options.data - data with information for rows to be sorted\r\n * @param {Boolean} [options.multidimensional=false] - if `data` is single-dimensional (contains rows with data to be sorted as immediate array items: `data [rowItem...]`), then it is `false`. If it has blocks of data as items (each block containing an array of rows to be sorted: data [block [rowItem...]...]), then set it to `true`. Currently it supports only a two-level aggregation max (data->block->rowItem).\r\n * @prop {HTMLTableElement} source - source table\r\n * @prop {Array} data - data array to be sorted\r\n * @prop {Boolean} multidimensional - if `data` is mono-dimensional (contains rows with data to be sorted as immediate array items: `data [rowItem...]`), then it is `false`. If it has blocks of data as items (each block containing an array of rows to be sorted: data [block [rowItem...]...]), then set it to `true`. Currently it supports only a two-level aggregation max (data->block->rowItem).\r\n * @prop {SortOrder} sortOrder - instance of {@link SortOrder}\r\n * @prop {TableColumns} columns - instance of {@link TableColumns} with a modified prototype (added `sortable:true` and `.sortable` to sortable columns)\r\n * @class SortTable\r\n * */\r\nclass SortTable {\r\n  /**\r\n   *\r\n   *\r\n   *  */\r\n\r\n  constructor(options){\r\n    let {source,refSource,defaultHeaderRow=-1,included,excluded,defaultSorting=[],data=[],multidimensional=false}=options;\r\n    this._sortEvent = ReportalBase.newEvent('reportal-table-sort');\r\n\r\n      if(source){\r\n        this.source=source;\r\n      } else {\r\n        throw new Error('`source` table is not specified for SortTable');\r\n      }\r\n      this.data = data;\r\n      this.multidimensional = multidimensional;\r\n\r\n      //let tableColumns= new TableColumns({source, refSource, defaultHeaderRow});\r\n      let sortableColumns=SortTable.defineSortableColumns(new TableColumns({source, refSource, defaultHeaderRow}), included, excluded);\r\n      this.columns = sortableColumns;\r\n      // setup sort order and do initial default sorting\r\n      this.sortOrder = {sortOrder:[]} = new SortOrder({columns:sortableColumns, sortCallback:this.sort, sortCallbackScope:this, defaultSorting});\r\n      [source,refSource].forEach(src=>{if(src){SortTable.listenForSort(TableColumns.getHeader(src),sortableColumns, this.sortOrder)}});// set up listeners for headers\r\n\r\n  }\r\n\r\n\r\n  /**\r\n   * Checks the table columns array against the `included`/`excluded` columns arrays and adds a `sortable:true` property and a `.sortable` class to the sortable ones\r\n   * @param {TableColumns} columns - an instance of {@link TableColumns}\r\n   * @param {Array} [included] - array of included columns indices\r\n   * @param {Array} [excluded] - array of excluded columns indices\r\n   * */\r\n  static defineSortableColumns(columns, included, excluded){\r\n    let sortableColumns = [].slice.call(columns);\r\n    sortableColumns.forEach((column,index)=>{\r\n      let sortable=((!included && !excluded) || (included && included.indexOf(index)!=-1) || (excluded && excluded.indexOf(index)==-1));\r\n      if(sortable){\r\n        column.cell.classList.add('sortable');\r\n        if(column.refCell){column.refCell.classList.add('sortable');}\r\n        column.sortable = true;\r\n      }\r\n    });\r\n    return sortableColumns\r\n  }\r\n\r\n  /**\r\n   * sets up listeners for column headers available for click\r\n   * @param {HTMLElement} delegatedTarget - element that will receive clicks and see if they are valid, `thead` is recommended to boil down to header clicks only\r\n   * @param {TableColumns} columns - array of table columns from {@link SortTable#defineSortableColumns}\r\n   * @param {SortOrder} sortOrder - instance of {@link SortOrder}\r\n   * @listens click\r\n   * */\r\n  static listenForSort(delegatedTarget, columns, sortOrder){\r\n    delegatedTarget.addEventListener('click',e=>{\r\n      // if it's a table cell, is in columns array and is sortable\r\n      let clickedColumn;\r\n      for(let i=0;i<columns.length;i++){\r\n        if(e.target==columns[i].cell || e.target==columns[i].refCell){\r\n          clickedColumn= columns[i]; break;\r\n        }\r\n      }\r\n      if((e.target.tagName == 'TD' || e.target.tagName == 'TH') && clickedColumn.sortable){\r\n        sortOrder.replace({column:columns.indexOf(clickedColumn), direction: e.target.classList.contains('asc')?'desc':'asc'});\r\n      }\r\n    })\r\n  }\r\n\r\n\r\n  /**\r\n   * Performs channeling of sorting based on whether `this.data` is `multidimensional`\r\n   * @param {SortOrder} sortOrder - instance of {@link SortOrder} passed by the {@link SortOrder#sort} on initial sort\r\n   * @fires SortTable~reportal-table-sort\r\n   * */\r\n  sort(sortOrder){\r\n    let so = sortOrder.sortOrder || this.sortOrder.sortOrder,\r\n      columns = this.columns;\r\n    if(so && so.length>0){\r\n      if(!this.multidimensional){\r\n        SortTable.sortDimension(this.data, columns, so);\r\n      } else { // if array has nested array blocks\r\n        this.data.forEach(dimension=>{\r\n          SortTable.sortDimension(dimension, this.columns, so);\r\n        });\r\n      }\r\n      columns[so[0].column].cell.dispatchEvent(this._sortEvent);\r\n    }\r\n  }\r\n  /**\r\n   * Splits sorting into one-column or two-column. The precedence of columns in `sortOrder` is the factor defining sort priority\r\n   * @param {Array} data - array containing row items to be sorted\r\n   * @param {TableColumns} columns - array of table columns from {@link SortTable#defineSortableColumns}\r\n   * @param {SortOrder} sortOrder - instance of {@link SortOrder}\r\n   * */\r\n  static sortDimension(data,columns,sortOrder){\r\n    let getIndex = (i)=>{return columns[sortOrder[i].column].index};\r\n    let getDirection=(i)=>{return sortOrder[i].direction === 'desc' ? -1 : 1};\r\n    // TODO: add possibility to sort the data that was stripped by column.\r\n    data.sort((a, b)=>{ // sort rows\r\n      if(sortOrder.length==1){ //sort one column only\r\n        return SortTable.sorter( a[getIndex(0)], b[getIndex(0)], getDirection(0) )\r\n      } else { //sort against two columns\r\n        return SortTable.sorter( a[getIndex(0)], b[getIndex(0)], getDirection(0) ) || SortTable.sorter( a[getIndex(1)], b[getIndex(1)], getDirection(1) )\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Function that performs case insensitive sorting in the array. It can distinguish between numbers, numbers as strings, HTML and plain strings\r\n   * */\r\n  static sorter(a,b,lesser){\r\n    let regex = /[<>]/g;\r\n    if(regex.test(a) || regex.test(b)){ // if we need to sort elements that have HTML like links\r\n      let tempEl1 = document.createElement('span'); tempEl1.innerHTML = a;\r\n      a=tempEl1.textContent.trim();\r\n      let tempEl2 = document.createElement('span'); tempEl2.innerHTML = b;\r\n      b=tempEl2.textContent.trim();\r\n    }\r\n    if(typeof a=='object' && typeof a.data != undefined){a=a.data}\r\n    if(typeof b=='object' && typeof b.data != undefined){b=b.data}\r\n    if(!isNaN(a) && !isNaN(b)){ //they might be numbers or null\r\n      if(a===null){return 1} else if (b===null){return -1}\r\n      return a <  b ? lesser :  a >  b ? -lesser : 0;\r\n    }\r\n    else if(!isNaN(parseFloat(a)) && !isNaN(parseFloat(b))){ // they might be number strings\r\n      return parseFloat(a) <  parseFloat(b) ? lesser :  parseFloat(a) >  parseFloat(b) ? -lesser : 0;\r\n    } else { //they might be simple strings\r\n      return a.toLowerCase() < b.toLowerCase() ? lesser : a.toLowerCase() > b.toLowerCase() ? -lesser : 0;\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport default SortTable\r\n\n\n\n// WEBPACK FOOTER //\n// ./~/r-sort-table/src/sort-table.js","/**\r\n * Created by IvanP on 09.09.2016.\r\n */\r\n\r\nclass TableColumns{\r\n  /**\r\n   * Creates an array of objects corresponding to the cells of `defaultHeaderRow`, that contain `sortable` property, denoting the column is sortable,\r\n   * `index` of the column and reference to the `cell`. Adds `.sortable` to a sortable cell\r\n   * @param {Object} options - options passed to configure the Sorting\r\n   * @param {HTMLTableElement} options.source - source table sorting will be applied to\r\n   * @param {HTMLTableElement} options.refSource - floating header if any\r\n   * @param {Number|Object} [options.defaultHeaderRow=-1] - index of the row in `thead` (incremented from 0) that will have sorting enabled for columns. If `-1` then last row.\r\n   * @return {{index:Number, title:String, colSpan:Number, cell: HTMLTableCellElement, ?refCell:HTMLTableCellElement}} - an array of objects that have this structure\r\n   * */\r\n  constructor(options){\r\n    let {source,refSource,defaultHeaderRow=-1} = options;\r\n    let thead,refThead;\r\n    if(source){thead=TableColumns.getHeader(source)} else {throw new TypeError('`source` table is not specified, cannot create TableColumns')}\r\n    if(refSource){refThead=TableColumns.getHeader(refSource)}\r\n    return TableColumns.computeColumns(thead,refThead,defaultHeaderRow);\r\n  }\r\n\r\n  /**\r\n   * Gets a header\r\n   * @param {HTMLTableElement} source - source table headers are created for\r\n   * */\r\n  static getHeader(source){\r\n    if(source && source.tagName == 'TABLE'){\r\n      let header = source.querySelector(\"thead\");\r\n      if(header && header.children.length>0) {\r\n        return header;\r\n      } else {\r\n        throw new TypeError('`source` table has no header or rows');\r\n      }\r\n    } else {\r\n      throw new TypeError('`source` is not specified or is not a table');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculates defaultHeaderRow for a passed `thead`\r\n   * @param {!HTMLTableElement} thead - source table header\r\n   * @param {!Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n   * @return {{index:Number, row: HTMLTableRowElement}}\r\n   * */\r\n  static getDefaultHeaderRow(thead,defaultHeaderRowIndex){\r\n    // calculate default header row\r\n    let headerRows = thead.children,\r\n      headerRowIndex = defaultHeaderRowIndex==-1 ? headerRows.length + defaultHeaderRowIndex : defaultHeaderRowIndex;\r\n    return {\r\n      index:headerRowIndex,\r\n      row:headerRows.item(headerRowIndex)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Gets an array of header cell nodes from default header row\r\n   * @param {?HTMLTableElement} thead - source table header\r\n   * @param {!Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n   * @return {?Array} Returns an array of header cell nodes or null if `thead` is not specified\r\n   * */\r\n  static getHeaderCells(thead,defaultHeaderRowIndex){\r\n    if(thead){\r\n      if(defaultHeaderRowIndex!=null){\r\n        let defaultHeaderRow = TableColumns.getDefaultHeaderRow(thead,defaultHeaderRowIndex);\r\n        let headerRows = thead.children;\r\n        let rowsLength = headerRows.length;\r\n        let abstr = {};\r\n        for(let r=0;r<rowsLength;r++){\r\n          let row = headerRows.item(r);\r\n          let augmentIndex=0; // index that will account for colSpan of upper rows' cells\r\n          [].slice.call(row.children).forEach((cell,index)=>{ //iterate through cells\r\n            for(let rs=0; rs<=cell.rowSpan-1;rs++){ //spread cell across its rowspan\r\n              let rowA = abstr[r+rs] = abstr[r+rs] || {}; //create row if not exists\r\n              if(!rowA[augmentIndex]){ //insert cell into slot if not filled\r\n                rowA[augmentIndex]=cell;\r\n              } else { //if filled look for the next empty because rowspanned columns fill them in a linear way\r\n                let i=0;\r\n                while(true){\r\n                  if(!rowA[i]){\r\n                    rowA[i]=cell;\r\n                    augmentIndex=i;\r\n                    break;\r\n                  }\r\n                  i++;\r\n                }\r\n              }\r\n            }\r\n            augmentIndex+=cell.colSpan;\r\n          })\r\n        }\r\n        return Object.keys(abstr[defaultHeaderRow.index]).map(k => abstr[defaultHeaderRow.index][k])\r\n      } else {\r\n        throw new TypeError('TableColumns.getHeaderCells: defaultHeaderRowIndex is not specified or is not a Number')\r\n      }\r\n    }\r\n    return null\r\n  }\r\n\r\n  /**\r\n   * Gets an array of columns from the table\r\n   * @param {!HTMLTableElement} thead - source table header\r\n   * @param {!HTMLTableElement} refThead - reference table header from floating header if any\r\n   * @param {Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n   * @return {?Array} Returns an array of header cell nodes or null if `thead` is not specified\r\n   * */\r\n  static computeColumns(thead,refThead,defaultHeaderRowIndex){\r\n    let theadCells = TableColumns.getHeaderCells(thead,defaultHeaderRowIndex);\r\n    let refTheadCells = TableColumns.getHeaderCells(refThead,defaultHeaderRowIndex);\r\n    let realColumnIndex=0;\r\n    return theadCells.map((cell,index)=>{\r\n      let obj = {\r\n        index: realColumnIndex,\r\n        title: cell.textContent,\r\n        cell,\r\n        colSpan:cell.colSpan\r\n      };\r\n      if(refTheadCells!=null){obj.refCell = refTheadCells[index]}\r\n      // we need to increment the colspan only for columns that follow rowheader because the block is not in data.\r\n      realColumnIndex= realColumnIndex>0?(realColumnIndex + cell.colSpan):realColumnIndex+1;\r\n      return obj;\r\n    });\r\n  }\r\n}\r\nexport default TableColumns;\r\n\n\n\n// WEBPACK FOOTER //\n// ./~/r-sort-table/src/table-columns.js","/**\r\n * Created by IvanP on 07.09.2016.\r\n */\r\nimport TableColumns from \"./table-columns\";\r\nimport ReportalBase from \"r-reportal-base\";\r\n\r\nwindow.Reportal = window.Reportal || {};\r\nReportalBase.mixin(window.Reportal,{\r\n  TableColumns,\r\n});\r\n\r\nexport default TableColumns;\r\n\n\n\n// WEBPACK FOOTER //\n// ./~/r-table-columns/src/main.js","/**\r\n * Created by IvanP on 09.09.2016.\r\n */\r\n\r\nclass TableColumns{\r\n  /**\r\n   * Creates an array of objects corresponding to the cells of `defaultHeaderRow`.\r\n   * @param {Object} options - options passed to configure the Sorting\r\n   * @param {HTMLTableElement} options.source - source table sorting will be applied to\r\n   * @param {HTMLTableElement} options.refSource - floating header if any\r\n   * @param {Number|Object} [options.defaultHeaderRow=-1] - index of the row in `thead` (incremented from 0) that will have sorting enabled for columns. If `-1` then last row.\r\n   * @return {{index:Number, title:String, colSpan:Number, cell: HTMLTableCellElement, ?refCell:HTMLTableCellElement}} - an array of objects that have this structure\r\n   * */\r\n  constructor(options){\r\n    let {source,refSource,defaultHeaderRow=-1} = options;\r\n    let thead,refThead;\r\n    if(source){thead=TableColumns.getHeader(source)} else {throw new TypeError('`source` table is not specified, cannot create TableColumns')}\r\n    if(refSource){refThead=TableColumns.getHeader(refSource)}\r\n    return TableColumns.computeColumns(thead,refThead,defaultHeaderRow);\r\n  }\r\n\r\n  /**\r\n   * Gets a header\r\n   * @param {HTMLTableElement} source - source table headers are created for\r\n   * */\r\n  static getHeader(source){\r\n    if(source && source.tagName == 'TABLE'){\r\n      let header = source.querySelector(\"thead\");\r\n      if(header && header.children.length>0) {\r\n        return header;\r\n      } else {\r\n        throw new TypeError('`source` table has no header or rows');\r\n      }\r\n    } else {\r\n      throw new TypeError('`source` is not specified or is not a table');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculates defaultHeaderRow for a passed `thead`\r\n   * @param {!HTMLTableElement} thead - source table header\r\n   * @param {!Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n   * @return {{index:Number, row: HTMLTableRowElement}}\r\n   * */\r\n  static getDefaultHeaderRow(thead,defaultHeaderRowIndex){\r\n    // calculate default header row\r\n    let headerRows = thead.children,\r\n      headerRowIndex = defaultHeaderRowIndex==-1 ? headerRows.length + defaultHeaderRowIndex : defaultHeaderRowIndex;\r\n    return {\r\n      index:headerRowIndex,\r\n      row:headerRows.item(headerRowIndex)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Gets an array of header cell nodes from default header row\r\n   * @param {?HTMLTableElement} thead - source table header\r\n   * @param {!Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n   * @return {?Array} Returns an array of header cell nodes or null if `thead` is not specified\r\n   * */\r\n  static getHeaderCells(thead,defaultHeaderRowIndex){\r\n    if(thead){\r\n      if(defaultHeaderRowIndex!=null){\r\n        let defaultHeaderRow = TableColumns.getDefaultHeaderRow(thead,defaultHeaderRowIndex);\r\n        let headerRows = thead.children;\r\n        let rowsLength = headerRows.length;\r\n        let abstr = {};\r\n        for(let r=0;r<rowsLength;r++){\r\n          let row = headerRows.item(r);\r\n          let augmentIndex=0; // index that will account for colSpan of upper rows' cells\r\n          [].slice.call(row.children).forEach((cell,index)=>{ //iterate through cells\r\n            for(let rs=0; rs<=cell.rowSpan-1;rs++){ //spread cell across its rowspan\r\n              let rowA = abstr[r+rs] = abstr[r+rs] || {}; //create row if not exists\r\n              if(!rowA[augmentIndex]){ //insert cell into slot if not filled\r\n                rowA[augmentIndex]=cell;\r\n              } else { //if filled look for the next empty because rowspanned columns fill them in a linear way\r\n                let i=0;\r\n                while(true){\r\n                  if(!rowA[i]){\r\n                    rowA[i]=cell;\r\n                    augmentIndex=i;\r\n                    break;\r\n                  }\r\n                  i++;\r\n                }\r\n              }\r\n            }\r\n            augmentIndex+=cell.colSpan;\r\n          })\r\n        }\r\n        return Object.keys(abstr[defaultHeaderRow.index]).map(k => abstr[defaultHeaderRow.index][k])\r\n      } else {\r\n        throw new TypeError('TableColumns.getHeaderCells: defaultHeaderRowIndex is not specified or is not a Number')\r\n      }\r\n    }\r\n    return null\r\n  }\r\n\r\n  /**\r\n   * Gets an array of columns from the table\r\n   * @param {!HTMLTableElement} thead - source table header\r\n   * @param {!HTMLTableElement} refThead - reference table header from floating header if any\r\n   * @param {Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n   * @return {?Array} Returns an array of header cell nodes or null if `thead` is not specified\r\n   * */\r\n  static computeColumns(thead,refThead,defaultHeaderRowIndex){\r\n    let theadCells = TableColumns.getHeaderCells(thead,defaultHeaderRowIndex);\r\n    let refTheadCells = TableColumns.getHeaderCells(refThead,defaultHeaderRowIndex);\r\n    let realColumnIndex=0;\r\n    return theadCells.map((cell,index)=>{\r\n      let obj = {\r\n        index: realColumnIndex,\r\n        title: cell.textContent,\r\n        cell,\r\n        colSpan:cell.colSpan\r\n      };\r\n      if(refTheadCells!=null){obj.refCell = refTheadCells[index]}\r\n      // we need to increment the colspan only for columns that follow rowheader because the block is not in data.\r\n      realColumnIndex= realColumnIndex>0?(realColumnIndex + cell.colSpan):realColumnIndex+1;\r\n      return obj;\r\n    });\r\n  }\r\n}\r\nexport default TableColumns;\r\n\n\n\n// WEBPACK FOOTER //\n// ./~/r-table-columns/src/table-columns.js","import ReportalBase from \"r-reportal-base\";\r\n\r\nvar TableFloatingHeaderStyle = require('./table-floating-header-styles.css');\r\n\r\n/**\r\n * FixedHeader class enables a fixed header appear on tables that have `.reportal-fixed-header` class when the table header is scrolled under address bar.\r\n */\r\nclass TableFloatingHeader {\r\n  /**\r\n   * @param {HTMLTableElement} source - source table that needs a cloned header\r\n   * */\r\n  constructor(source){\r\n    if(typeof source == undefined || source.tagName != 'TABLE'){\r\n      throw new TypeError('`source` must be defined and must be a table')\r\n    }\r\n\r\n    TableFloatingHeader.wrapTable(source);\r\n\r\n    /**\r\n     *  The cloned floating header without TBODY\r\n     *  @type {HTMLTableElement}\r\n     *  @memberOf TableFloatingHeader\r\n     *  */\r\n    this.header  = TableFloatingHeader.cloneHeader(source);\r\n\r\n    /**\r\n     *  The source table\r\n     *  @type {HTMLTableElement}\r\n     *  @memberOf TableFloatingHeader\r\n     *  */\r\n    this.source = source;\r\n    /**\r\n     *  Visibility status of the table\r\n     *  @type {Boolean}\r\n     *  @memberOf TableFloatingHeader\r\n     *  */\r\n    this.visible = false;\r\n\r\n    this._meta = {\r\n      lastScrollY:0,\r\n      sourceTHEAD: source.querySelector('thead'),\r\n      ticking:false\r\n    };\r\n\r\n    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\r\n\r\n    this.resizeFixed();\r\n\r\n    window.addEventListener(\"resize\", ()=>this.resizeFixed.call(this), false); // attach a resize listener to resize the header\r\n    window.addEventListener(\"scroll\", ()=>this.scrollFixed.call(this), false); // attach a resize listener to resize the header\r\n  }\r\n\r\n  /**\r\n   * calculates offset height of the table\r\n   * @param {HTMLTableElement} source - source table\r\n   * */\r\n  static calcOffsetHeight(source){\r\n    this._meta.tableOffsetTop = source.parentNode.offsetTop;\r\n    this._meta.tableOffsetBottom = source.parentNode.offsetTop + source.offsetHeight - this._meta.sourceTHEAD.offsetHeight;\r\n  }\r\n\r\n  /**\r\n   * Event reporting that a header is visible\r\n   * @event TableFloatingHeader~reportal-fixed-header-visible\r\n   */\r\n\r\n  /**\r\n   * Event reporting that a header is hidden\r\n   * @event TableFloatingHeader~reportal-fixed-header-hidden\r\n   */\r\n\r\n  /**\r\n   * sets visibility of the table\r\n   * @param {HTMLTableElement} source - source table\r\n   * @param {HTMLTableElement} header - cloned table with header only\r\n   * @param {Boolean} visible - visibility status\r\n   * @fires TableFloatingHeader~reportal-fixed-header-visible\r\n   * @fires TableFloatingHeader~reportal-fixed-header-visible\r\n   * */\r\n  static setVisibility(source, header, visible){\r\n    if(visible){\r\n      header.style.display='table';\r\n      source.dispatchEvent(ReportalBase.newEvent('reportal-fixed-header-visible'));\r\n    } else {\r\n      header.style.display='none';\r\n      source.dispatchEvent(ReportalBase.newEvent('reportal-fixed-header-hidden'));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * wraps the `source` table into a `div.aggregatedTableContainer`\r\n   * */\r\n  static wrapTable(source){\r\n    let wrapper = document.createElement('div');\r\n    wrapper.classList.add('aggregatedTableContainer');\r\n    source.parentNode.appendChild(wrapper);\r\n    wrapper.appendChild(source);\r\n  }\r\n\r\n  /**\r\n   * clones header of `source` table and appends to wrapper\r\n   * */\r\n  static cloneHeader(source){\r\n    let header = source.cloneNode(true);\r\n    header.classList.add('fixed');\r\n    source.parentNode.appendChild(header);\r\n    [].slice.call(header.children).forEach(child=>{\r\n      if(child.nodeName=='TBODY'){\r\n        header.removeChild(child);\r\n      }\r\n    });\r\n    return header;\r\n  }\r\n\r\n  /**\r\n   * function that polls the callback\r\n   * @param {Function} callback - function that's going to be passed to `requestAnimationFrame` for execution\r\n   * */\r\n  requestTick(callback){\r\n    if(!this._meta.ticking) {\r\n      requestAnimationFrame(callback);\r\n      this._meta.ticking = true;\r\n    }\r\n  }\r\n\r\n  static _resizeCallback(){\r\n    let initialHeader = this._meta.sourceTHEAD.querySelectorAll('tr>*'),\r\n      clonedHeader = this.header.querySelectorAll('thead>tr>*'),\r\n      headerWidth = this.source.offsetWidth + 'px',\r\n      widths=[];\r\n    // do reflow\r\n    for(let i=0;i<initialHeader.length;i++){\r\n      widths.push(initialHeader[i].offsetWidth);\r\n    }\r\n    //do repaint\r\n    for(let c=0;c<clonedHeader.length;c++){\r\n      clonedHeader[c].style.width = widths[c] + 'px';\r\n    }\r\n    this.header.style.width = headerWidth;\r\n\r\n    TableFloatingHeader.calcOffsetHeight.call(this,this.source); //recalc height of the table after reflow\r\n    this._meta.ticking=false;\r\n    this.scrollFixed(); // to compensate top offset in case after resize the table is less in height and top has changed\r\n  }\r\n\r\n  /**\r\n   * Calculates widths for all columns in the fixed header based on the `source`\r\n   * */\r\n  resizeFixed(){\r\n    this.requestTick(TableFloatingHeader._resizeCallback.bind(this))\r\n  }\r\n\r\n\r\n  static _scrollCallback(){\r\n    let offset = this._meta.lastScrollY,\r\n      tableOffsetTop = this._meta.tableOffsetTop,\r\n      tableOffsetBottom = this._meta.tableOffsetBottom;\r\n    if((offset < tableOffsetTop || offset > tableOffsetBottom) && this.visible){\r\n      this.visible = false;\r\n      TableFloatingHeader.setVisibility(this.source,this.header,false);\r\n    }\r\n    else if(offset >= tableOffsetTop && offset <= tableOffsetBottom){\r\n      this.header.style.top=offset-tableOffsetTop+'px';\r\n      if(!this.visible){\r\n        this.visible=true;\r\n        TableFloatingHeader.setVisibility(this.source,this.header,true);\r\n      }\r\n    }\r\n    this._meta.ticking=false;\r\n  }\r\n\r\n\r\n  /**\r\n   * Displays a fixed header when the table header is scrolled off the screen\r\n   * */\r\n  scrollFixed() {\r\n      this._meta.lastScrollY = window.pageYOffset;\r\n      this.requestTick(TableFloatingHeader._scrollCallback.bind(this));\r\n  }\r\n\r\n}\r\n\r\nexport default TableFloatingHeader;\r\n\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// ./~/r-table-floating-header/src/table-floating-header.js","require(\"./drilldown-map.css\");\nimport ReportalBase from \"r-reportal-base\";\nimport AsyncHierarchyTable from \"r-async-hierarchy-table\";\nimport MapHierarchy from \"./map-hierarchy\";\nimport AggregatedTable from \"r-aggregated-table\";\n\nclass DrilldownMap extends MapHierarchy {\n  /**\n   * Creates a drilldown map. It uses a color function `colorFn` that allows colorcode countries\n   * `colorFn` accepts two attributes: `value` and `target` and must return a color string based on those two attributes.\n   * Make sure hierarchy has `target` loaded from DBDesigner table into each hierarchy level, otherwise a default config `dataClasses` takes precedence on value\n   * Example:\n   *\n   *    {\n   *    //some constructor configuration above\n   *      colorFn: function(value,target){\n   *        return (value!=null && target!=null)? (value - target >= 0) ? \"#18BC9C\" : ((value >= 0.9*target) ? \"#FF4900\" : \"#E45335\") : undefined;\n   *      }\n   *     //some constructor configuration below\n   *    }\n   *\n   * @param {HTMLTableElement} source - a source drilldown table that contains the initial set of data(with reference group enabled and 1 child level)\n   * @param {String} tableID - id of the `source` table that is the initial source of data (from reportal backend)\n   * @param {Array} rowheaders - a rowheaders array for the loaded table\n   * @param {Object} hierarchy - a hierarchical object for a map to be built upon\n   * @param {String} [initMap=\"custom/world-highres2\"] - the initial map object that's going to be loaded to initialise the map\n   * @param {String} containerID - id of the container the map will be drawn to\n   * @param {Function} mappointCallback - executed when a mappoint (city) is clicked\n   * @param {Function} colorFn - A function that allows custom color coding computation based on value and target.\n   * @param {Number} [valueColumn=1] - Zero-based column index that contains primary value which will be used for map coloring.\n   * @param {Boolean} [fullParentLevelInfo=true] - Display full info of the parent level in right part of the map, rather than the parent level name and the primary value\n   * @param {String} [pageStateId=document.querySelector('#PageStateId').value] - PageStateId\n   * @param {Object} normals - an object where the keys are the names of columns taken from DBDesignerTable and values - their string types: `string`, `number`, `boolean`, `stringArray`, `numberArray`\n   * @param {String} [normalsSeparator=','] - delimiter between values in `stringArray` (`us-ca, us-tx, us-wy`) and `numberArray` (`-31.86,16.38`). They are served as a delimiter-separated string and the delimiter is `,` by default. If you use another one, make sure you specify it here\n   * @param {Object} [options={}] - options passed to HighMap to restyle/reconfigure it\n   * */\n  constructor(config={}) {\n    const {\n      source, rowheaders,\n      hierarchy, initMap = \"custom/world-highres2\", containerID, mappointCallback,\n      excludeColumns, excludeRows, valueColumn = 1,\n      fullParentLevelInfo = true,\n      colorFn = function (value, target) {\n        return value !== null ? value >= 80 ? \"#4caf50\" : ((value < 80 && value >= 60 ) ? \"#ffc107\" : \"#ff5722\") : \"blue\";\n      },\n      pageStateId = (document.querySelector('#PageStateId') ? document.querySelector('#PageStateId').value : null),\n      tableID,\n      normals, normalsSeparator = \",\", options = {}\n    } = config;\n\n    super(hierarchy, normals, normalsSeparator);\n\n    this.declareGlobals(config,{\n      initMap: 'custom/world-highres2',\n      valueColumn: 1,\n      fullParentLevelInfo: true,\n      colorFn: function (value, target) {\n        return value !== null ? value >= 80 ? '#4caf50' : ((value < 80 && value >= 60 ) ? '#ffc107' : '#ff5722') : 'blue';\n      },\n      pageStateId: (document.querySelector('#PageStateId') ? document.querySelector('#PageStateId').value : null),\n      normalsSeparator: ',',\n      options:{},\n    }, this.typeCheck(config));\n\n    this.parseTableData();\n\n    this.drawMap(rowheaders, containerID, initMap, options);\n  }\n\n  declareGlobals(options,defaults,typeCheck){\n    Object.keys(options).forEach(key=>{\n      const prop = options[key] || defaults[key];\n      if(typeCheck && typeCheck[key] && typeof typeCheck[key]==='function') typeCheck[key](prop);\n      this[key]=prop;\n    })\n  }\n\n  typeCheck(opts){\n    if (typeof Highcharts === 'undefined') {throw new Error('Highcharts must be declared. Probably they are missing')}\n    if (typeof Highcharts.maps === 'undefined') {throw new Error('HighMaps must be loaded. Probably they are missing')}\n\n    return {\n      source: function(){\n        if(!(opts.source && opts.source.localName==='table'))\n          throw new Error('source table must be specified')\n      },\n      mappointCallback: function(){\n        const cb=opts.mappointCallback;\n        if(cb && cb !== null && typeof cb !== 'function')\n          throw new Error('mappointCallback must be a function')\n      },\n    }\n  }\n\n  /**\n   * Parses table passed to it and adds data to `._data` in `hierarchy`\n   * @param {HTMLTableElement} source - source table for data\n   * @param {Number|Array} excludeRows - rows to be excluded from parsing\n   * @param {Array} rowheaders - array of `source` rowheaders\n   * @param {Object} flatHierarchy - flat hierarchy object\n   * */\n  parseTableData() {\n    const {source, excludeRows, rowheaders, flatHierarchy, excludeColumns} = this;\n    let aggregatedTable = new AggregatedTable({source, excludeColumns, excludeRows});\n    if (DrilldownMap.rowHeadersAreValid) {\n      rowheaders.forEach((rowHeader, i) => {\n        if (!flatHierarchy[rowHeader]._data) {\n          flatHierarchy[rowHeader]._data = aggregatedTable.data[i].map((dataItem, index) => {\n            return {\n              value: dataItem.data,\n              title: index !== 0 ? aggregatedTable.columns[index].title : \"Region\"\n            }\n          })\n        }\n      })\n    } else {\n      throw new Error('rowheaders must be present to parse data');\n    }\n  }\n\n  static rowHeadersAreValid(rowheaders){\n    return rowheaders && rowheaders !== null && rowheaders.length > 0\n  }\n\n\n  /**\n   * Creates custom geoJSON file\n   * @param {Object} mapData - initial map\n   * @param {Array}countriesList - list of countries IDs\n   * @param {String} mapName\n   * @returns {Object}\n   * */\n  static createCustomGeoJSON(mapData, countriesList, mapName) {\n    let geojson = {\n      title: \"\",\n      version: \"0.1.0\",\n      type: \"FeatureCollection\",\n      copyright: \"Copyright (c) 2015 Highsoft AS, Based on data from Natural Earth\",\n      copyrightShort: \"Natural Earth\",\n      copyrightUrl: \"http://www.naturalearthdata.com\",\n      crs: {\n        type: \"name\",\n        properties: {\n          name: \"urn:ogc:def:crs:EPSG:54003\"\n        }\n      },\n      \"hc-transform\": {\n        default: {\n          crs: \"+proj=mill +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +R_A +datum=WGS84 +units=m +no_defs\",\n          scale: 1.72182781654e-05,\n          jsonres: 15.5,\n          jsonmarginX: -999,\n          jsonmarginY: 9851.0,\n          xoffset: -19495356.3693,\n          yoffset: 12635908.1982\n        }\n      },\n      features: DrilldownMap.getFeatures(countriesList, mapData)\n    };\n\n    geojson.title = mapName;\n    return geojson;\n  }\n\n  /**\n   * Get array of features from geoJSON file\n   * @param {Array|String} countriesList - countries IDs\n   * @param {Object} mapData - your initial map\n   * @param {String} key for geojson features comparing\n   * @returns {Array} features list\n   * */\n  static getFeatures(countriesList, mapData, key = \"hc-key\") {\n    if (typeof countriesList === 'string') {\n      return mapData.features.filter(feature => feature.properties[key] === countriesList);\n    } else if (Array.isArray(countriesList)) {\n      return mapData.features.filter(feature => countriesList.indexOf(feature.properties[key]) !== -1);\n    }\n  }\n\n\n  /**\n   * Get series for the first time map initialization\n   * @param {Object} curLVL - current level in hierarchy\n   * @param {Array} [series=[]] - series\n   * @returns {Array}\n   * */\n  initMap(curLVL, series = []) {\n    curLVL.subcells.forEach(subcell => {\n      if (subcell.mapID) {\n        let seriesItem = this.composeSeries(subcell);\n        series.push(seriesItem);\n      }\n    });\n    return series;\n  }\n\n  /**\n   * Load map from HighMaps map collection\n   * @param {String} source\n   * @returns {Promise}\n   * */\n  static loadMap(source) {\n    return new Promise((resolve, reject) => {\n      jQuery.getScript('https://code.highcharts.com/mapdata/' + source + '.js', function () {\n        resolve(Highcharts.maps[source]);\n      });\n    });\n  }\n\n  /**\n   * Gets the main value that the chart is built on\n   * @param {Object} level - level under examination\n   * @param {Number} valueColumn - Zero-based column index that contains primary value which will be used for map coloring\n   * @returns {Number} Returns primary value\n   * */\n  static getPrimaryValue(level, valueColumn) {\n    return level._data[valueColumn].value;\n  }\n\n\n  /**\n   * Creates a single series data for HighMap series option\n   * @param {Object} level - a level in hierarchy\n   * @returns {Object}\n   * */\n  getSeriesData(level) {\n    let drilldown = level.subcells ? level.text : null;\n    if (typeof level.mapID === 'string') {\n      return [{\n        drilldown: drilldown,\n        code: level.mapID,\n        value: DrilldownMap.getPrimaryValue(level, this.valueColumn),\n        data: level._data,\n      }]\n    } else if (Array.isArray(level.mapID)) {\n      return level.mapID.map(mapID => {\n\n        return {\n          drilldown: drilldown,\n          code: mapID,\n          value: DrilldownMap.getPrimaryValue(level, this.valueColumn),\n          data: level._data,\n        }\n      });\n    } else {\n      throw new Error(\"Data element is corrupted\");\n    }\n  }\n\n  /**\n   * Executes `colorFn` passed by user to compute color by passing `value` and `target` to it\n   * @param {Function} colorFn - color function\n   * @param {Number} value - value to test\n   * @param {Number} target - target for the level\n   * */\n  static computeColor(colorFn, value, target) {\n    if (colorFn) {\n      return colorFn(value, target)\n    } else {\n      return undefined\n    }\n  }\n\n  /**\n   * Create a single mappoint series\n   * @param {Object} subcell - a single hierarchy element\n   * @param {Object} mapData\n   * @param {Object} chart - reference to chart object\n   * @returns {Object} series for map points\n   * */\n  getCoordinateSeries(subcell, mapData, chart) {\n    chart.mapTransforms = mapData ? mapData[\"hc-transform\"] : Highcharts.maps[\"custom/world-highres2\"][\"hc-transform\"];\n    let pos = chart.fromLatLonToPoint({lat: subcell.coordinates[0], lon: subcell.coordinates[1]});\n    let config = {\n      type: \"mappoint\",\n      name: subcell.text,\n      marker: {\n        lineColor: \"black\",\n        lineWidth: 1,\n        radius: 4,\n        symbol: \"circle\",\n      },\n      data: [{\n        color: DrilldownMap.computeColor(this.colorFn, DrilldownMap.getPrimaryValue(subcell, this.valueColumn), subcell.target),\n        name: subcell.text,\n        value: subcell.value,\n        x: pos.x,\n        y: pos.y\n      }]\n    };\n    if (this.mappointCallback) {\n      let self = this;\n      config.events = {\n        click: function (e) {\n          self.mappointCallback.call(this, e);\n        }\n      }\n    }\n    return config\n  }\n\n  /**\n   * Creates a single series item for Highmaps series option\n   * @param {Object} subcell - a subcell\n   * @param {Object} mapData\n   * @param {Object} chart - reference to chart object\n   * @returns {Object} Returns series\n   * */\n  composeSeries(subcell, mapData, chart) {\n    if (!subcell.coordinates) {\n      mapData = mapData ? Highcharts.geojson(DrilldownMap.createCustomGeoJSON(mapData, subcell.mapID, subcell.text)) : Highcharts.geojson(DrilldownMap.createCustomGeoJSON(Highcharts.maps['custom/world-highres2'], subcell.mapID, subcell.text));\n      if (subcell.mapID) {\n        let target = subcell.target;\n        if (!target || target === null) {\n          target = this.hierarchy[0].target;\n        }\n        return {\n          name: subcell.text,\n          dataLabels: {\n            enabled: true,\n            formatter: function () {\n              if (this.series.data[0][\"hc-key\"] === this.point[\"hc-key\"])\n                return this.series.name\n            }\n          },\n          tooltip: {\n            pointFormat: this.getTooltip()\n          },\n          color: DrilldownMap.computeColor(this.colorFn, DrilldownMap.getPrimaryValue(subcell, this.valueColumn), target),\n          allAreas: false,\n          parent: subcell.parent.text,\n          mapData,\n          joinBy: ['hc-key', 'code'],\n          data: this.getSeriesData(subcell)\n        };\n      }\n    } else {\n      return this.getCoordinateSeries(subcell, mapData, chart)\n    }\n  }\n\n  /**\n   * get subcell by text rather than by id\n   * @param {Object} curLVL - current level\n   * @param {String} name - name of the subcell we're looking for\n   * @returns {Object} Returns a subcell which has that name\n   * */\n  static getLevelByName(curLVL, name) {\n    return curLVL.subcells.filter(el => el.text === name)[0];\n  }\n\n  /**\n   * Updates your map view after drilldown click\n   * @param {Object} curLVL\n   * @param {Object} chart\n   * @param {Object} e - drilldown event object\n   * @returns {Object} Returns curLVL\n   * */\n  updateMap(curLVL, chart, e) {\n    if (curLVL && curLVL.mapName) {// if we have another map to load\n      let map = DrilldownMap.loadMap(curLVL.mapName);\n      map.then(mapData => {\n        this.addSeries(curLVL, chart, e, mapData)\n      });\n    } else if (curLVL && !curLVL.mapName) {\n      this.addSeries(curLVL, chart, e);\n    }\n  }\n\n  /**\n   * Composes a series for your HighMaps options config\n   * @param {Object} curLVL\n   * @param {Object} chart\n   * @param {Object} e - drilldown event object\n   * @param {Object} mapData - mapData geoJSON\n   * */\n  addSeries(curLVL, chart, e, mapData) {\n    if (curLVL.subcells) { // if it's an end point\n      if (curLVL.subcells[0].coordinates) {\n        let seriesItem = this.composeSeries(curLVL, mapData, chart);\n        seriesItem.data.forEach(dataItem => {\n          dataItem.drilldown = null;\n          dataItem.value = null\n        });\n        chart.addSingleSeriesAsDrilldown(e.point, seriesItem);\n      }\n      curLVL.subcells.forEach(subcell => {\n        if (!subcell.mapID && !subcell.coordinates) return;\n        let seriesItem = this.composeSeries(subcell, mapData, chart);\n        chart.addSingleSeriesAsDrilldown(e.point, seriesItem);\n      });\n      chart.applyDrilldown();\n    } else {\n      let seriesItem = this.composeSeries(curLVL, mapData, chart);\n      seriesItem.data.map(dataItem => {\n        dataItem.drilldown = null;\n        dataItem.value = null\n      });\n      chart.addSeriesAsDrilldown(e.point, seriesItem);\n    }\n  }\n\n  /**\n   * Generates chart subtitle returning region and main value of full info based on `fullParentLevelInfo`\n   * */\n  get subtitle() {\n    if (this.fullParentLevelInfo) {\n      return this.curLVL._data.map((item) => {\n        return `<span class=\"tooltip-level-label\">${item.title}:</span><span class=\"tooltip-level-value\"> ${item.value}</span>`\n      }).join(\"<br />\")\n    } else {\n      return `${this.curLVL._data[0].title}: ${this.curLVL._data[0].value}<br> ${this.curLVL._data[this.valueColumn].title}: ${this.curLVL._data[this.valueColumn].value}`\n    }\n  }\n\n  /**\n   * Generates a serialized dataset for a tooltip\n   * */\n  getTooltip() {\n    let data = this.curLVL._data;\n    return data.map((item, index) => `<span class=\"tooltip-level-label\">${item.title}:</span><span class=\"tooltip-level-value\"> {point.data.${index}.value}</span>`).join(\"<br />\")\n  }\n\n  /**\n   * @param {Array} rowheaders - a rowheaders array\n   * @param {String} containerID - id of the container to render map to\n   * @param {String} initMap - the initial map object that's going to be loaded to initialise the map\n   * @param {Object} options - options passed to HighMap to restyle/reconfigure it\n   * */\n  drawMap(rowheaders, containerID, initMap, options) {\n    this.curLVL = this.flatHierarchy[rowheaders[0]];\n    let self = this;\n    let config = {\n      lang: {\n        drillUpText: '< to {series.parent}'\n      },\n      tooltip: {\n        pointFormat: self.getTooltip()\n      },\n      title: {\n        text: ''\n      },\n      legend: {\n        enabled: true\n      },\n      plotOptions: {\n        series: {\n          states: {\n            normal: {\n              animation: false\n            }\n          },\n          point: {\n            events: {\n              mouseOver: function (e) {\n                this.series.data.forEach(\n                  el => el.setState(\"hover\")\n                )\n              },\n              mouseOut: function (e) {\n                this.series.data.forEach(\n                  el => el.setState()\n                )\n              }\n            }\n          }\n        }\n      },\n      mapNavigation: {\n        enabled: true,\n        buttons: {\n          zoomIn: {\n            verticalAlign: \"bottom\"\n          },\n          zoomOut: {\n            verticalAlign: \"bottom\"\n          }\n        }\n      },\n      subtitle: {\n        align: 'right',\n        text: self.subtitle,\n        floating: true\n      },\n      drilldown: {\n        drillUpButton: {\n          position: {\n            align: \"left\",\n            y: 0\n          },\n          relativeTo: 'spacingBox'\n        }\n      },\n      chart: {\n        events: {\n          drilldown: function (e) {\n            //this == chart reference;\n            //console.log(CircularJSON.parse(CircularJSON.stringify(e.point)));\n            let chart = e.target;\n            self.curLVL = DrilldownMap.getLevelByName(self.curLVL, e.point.series.name);\n            let curLVL = self.curLVL;\n            if (curLVL) {\n              chart.showLoading('fetching data');\n              let table = AsyncHierarchyTable.fetchChildTable(curLVL.id, curLVL.parent ? curLVL.parent.id : null, self.tableID, self.pageStateId)\n                .then(table => {\n                  // parse data loaded from table\n                  DrilldownMap.parseTableData({\n                    source: table,\n                    excludeRows: 0,\n                    rowheaders: curLVL.subcells.map(lvl => lvl.id),\n                    flatHierarchy: self.flatHierarchy\n                  });\n                  self.updateMap(curLVL, chart, e);\n                  chart.subtitle.update({text: self.subtitle});\n                  chart.hideLoading();\n                });\n            }\n          },\n          drillupall: function (e) {\n            self.curLVL = self.curLVL.parent;\n            if (self.curLVL) {\n              e.target.subtitle.update({text: self.subtitle});\n            }\n          }\n        }\n      },\n      series: self.initMap(self.curLVL, [{\n        showInLegend: false,\n        mapData: Highcharts.maps[initMap]\n      }])\n    };\n\n    Highcharts.mapChart(containerID, ReportalBase.mixin(config, options));\n  }\n}\n\nexport default DrilldownMap;\n\n\n\n// WEBPACK FOOTER //\n// ./src/DrilldownMap.js","/**\n * Created by IvanP on 26.12.2016.\n */\nclass MapHierarchy {\n  constructor(hierarchy,normals,normalsSeparator){\n    this.flatHierarchy = hierarchy;\n    this.hierarchy = this.constructor.processHierarchy(this.flatHierarchy,normals,normalsSeparator);\n    this.constructor.addMapIDsToHierarchyLevel(this.hierarchy);\n  }\n\n  /**\n   * Processes hierarchy array by assigning parent-child relations and returning those that don't have a parent\n   * @param {Object} flatHierarchy - a flat hierarchy object with ids as keys\n   * @param {Object} [normals={}] - an object where keys myst coincide with column ids (thus be identical to keys in `item`). `normals` doesn't require for all keys from `item` to be present, only those that need to be normalised to a different type\n   * @param {String} [separator=','] - a separator array items are serialized with, by default it's a comma (`,`)\n   * */\n  static processHierarchy(flatHierarchy,normals={},separator=','){\n    let orphans = [],\n        toNormalize = Object.keys(normals).length>0;\n    for(let key in flatHierarchy){\n      let item = flatHierarchy[key];\n      if(toNormalize)MapHierarchy.normalize(item,normals);\n\n      // map item to parent\n      if(item.parent && item.parent!=null && item.parent.length>0){\n        item.parent = flatHierarchy[item.parent];\n        item.parent.subcells = item.parent.subcells || [];\n        item.parent.subcells.push(item);\n      } else {\n        orphans.push(item);\n      }\n    }\n    return orphans\n  }\n\n  static composeFlatHierarchy(hierarchy,normals){\n    let o={};\n    let toNormalize = normals.keys().length>0;\n    hierarchy.forEach(\n      item=>{\n        if(toNormalize)MapHierarchy.normalize(item,normals);\n        o[item.id]=item;\n      });\n    return o;\n  }\n\n  /**\n   * normalizes a string value to a certain format.\n   * - `arrayString` - normalizes comma-separated items to an Array of Strings, i.e \"haha\", \"lala\" would be [\"haha\", \"lala\"]\n   * - `arrayNumber` - normalizes comma-separated items to an Array of Floats, i.e \"-13.41\", \"48.66\" would be [-13.41, 48.66]\n   * - `string` - returns the string as is\n   * - `number` - parses the string as a Float\n   * - `boolean` - parses the string as a Boolean, case insensitive\n   *\n   * @param {Object} item - item to match contents against `normals`\n   * @param {Object} [normals={}] - an object where keys myst coincide with column ids (thus be identical to keys in `item`). `normals` doesn't require for all keys from `item` to be present, only those that need to be normalised to a different type\n   * @param {String} [separator=','] - a separator array items are serialized with, by default it's a comma (`,`)\n   * */\n  static normalize(item,normals={},separator=','){\n    let parser = {\n      stringArray: val => val.split(separator),\n      numberArray: val => val.split(separator).map(i=>parseFloat(i)),\n      string: val => val.trim(),\n      number: val => val!=null && !isNaN(parseFloat(val))? parseFloat(val): null,\n      boolean: val => val.toLowerCase()==\"true\" || val==\"1\"\n    };\n    for(let normal in normals){\n      if(item[normal]){// property exists in object\n        if(item[normal].length>0){\n          item[normal] = parser[normals[normal]](item[normal])\n        } else {\n          delete item[normal]\n        }\n      }\n    }\n  }\n\n\n  /**\n   * Updates initial hierarchy\n   * @param hierarchy\n   * @param parent - hierarchy level parent\n   */\n  static addMapIDsToHierarchyLevel(hierarchy, parent = null) {\n    hierarchy.forEach(subcell => {\n      if(subcell.parent && subcell.parent!=null && subcell.parent.mapName){\n        subcell.mapName = subcell.parent.mapName;\n      }\n      if (subcell.subcells) {\n        MapHierarchy.addMapIDsToHierarchyLevel(subcell.subcells, subcell);\n      }\n      if(subcell.parent && subcell.mapID && !subcell.parent.mapName){\n        if(!subcell.parent.mapID)\n          subcell.parent.mapID = [];\n        subcell.parent.mapID = subcell.parent.mapID.concat(subcell.mapID);\n      }\n    });\n  }\n\n}\nexport default MapHierarchy\n\n\n\n// WEBPACK FOOTER //\n// ./src/map-hierarchy.js"],"sourceRoot":""}