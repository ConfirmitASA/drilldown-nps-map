/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _DrilldownMap = __webpack_require__(13);\n\nvar _DrilldownMap2 = _interopRequireDefault(_DrilldownMap);\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nwindow.Reportal = window.Reportal || {};\n_rReportalBase2.default.mixin(window.Reportal, {\n  DrilldownMap: _DrilldownMap2.default,\n  ReportalBase: _rReportalBase2.default\n});\n\nexports.default = _DrilldownMap2.default;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz8zNDc5Il0sIm5hbWVzIjpbIndpbmRvdyIsIlJlcG9ydGFsIiwibWl4aW4iLCJEcmlsbGRvd25NYXAiLCJSZXBvcnRhbEJhc2UiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBQSxPQUFPQyxRQUFQLEdBQWtCRCxPQUFPQyxRQUFQLElBQW1CLEVBQXJDO0FBQ0Esd0JBQWFDLEtBQWIsQ0FBbUJGLE9BQU9DLFFBQTFCLEVBQW1DO0FBQ2pDRSxzQ0FEaUM7QUFFakNDO0FBRmlDLENBQW5DIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBEcmlsbGRvd25NYXAgZnJvbSBcIi4vRHJpbGxkb3duTWFwXCI7XG5pbXBvcnQgUmVwb3J0YWxCYXNlIGZyb20gXCJyLXJlcG9ydGFsLWJhc2VcIjtcblxud2luZG93LlJlcG9ydGFsID0gd2luZG93LlJlcG9ydGFsIHx8IHt9O1xuUmVwb3J0YWxCYXNlLm1peGluKHdpbmRvdy5SZXBvcnRhbCx7XG4gIERyaWxsZG93bk1hcCxcbiAgUmVwb3J0YWxCYXNlXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgRHJpbGxkb3duTWFwXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWFpbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ReportalBase = function () {\n  function ReportalBase() {\n    _classCallCheck(this, ReportalBase);\n  }\n\n  _createClass(ReportalBase, null, [{\n    key: 'mixin',\n\n\n    /**\n     * Copies props from a source object to a target object.\n     *\n     * Note, this method uses a simple `for...in` strategy for enumerating\n     * properties.  To ensure only `ownProperties` are copied from source\n     * to target and that accessor implementations are copied, use `extend`.\n     *\n     * @method mixin\n     * @param {Object} target Target object to copy properties to.\n     * @param {Object} source Source object to copy properties from.\n     * @return {Object} Target object that was passed as first argument.\n     */\n    value: function mixin(target, source) {\n      for (var i in source) {\n        target[i] = source[i];\n      }\n      return target;\n    }\n  }, {\n    key: '_logger',\n    value: function _logger(level, args) {\n      // accept ['foo', 'bar'] and [['foo', 'bar']]\n      if (args.length === 1 && Array.isArray(args[0])) {\n        args = args[0];\n      }\n      // only accept logging functions\n      switch (level) {\n        case 'log':\n        case 'warn':\n        case 'error':\n          console[level].apply(console, args);\n          break;\n      }\n    }\n  }, {\n    key: '_log',\n    value: function _log() {\n      var args = Array.prototype.slice.call(arguments, 0);\n      this._logger('log', args);\n    }\n  }, {\n    key: '_warn',\n    value: function _warn() {\n      var args = Array.prototype.slice.call(arguments, 0);\n      this._logger('warn', args);\n    }\n  }, {\n    key: '_error',\n    value: function _error() {\n      var args = Array.prototype.slice.call(arguments, 0);\n      this._logger('error', args);\n    }\n\n    /**\n     * Creates a named event with `name`\n     * @param {String} name - name of the event\n     * @return {Event} Returns a created event\n     * */\n\n  }, {\n    key: 'newEvent',\n    value: function newEvent(name) {\n      var event = document.createEvent('Event');\n      event.initEvent(name, true, true);\n      return event;\n    }\n\n    /**\n     * Inspects if the current string might be converted to number and renders it as number. If string length is 0, returns `null`. If none applies returns the string as is.\n     * @param {String} str - value of the cell if not HTML contents\n     * @return {Number|null|String}\n     * */\n\n  }, {\n    key: 'isNumber',\n    value: function isNumber(str) {\n      if (!isNaN(parseFloat(str))) {\n        str = str.replace(/,/i, ''); // remove unnecessary comma as a delimiter for thousands from data.\n        return parseFloat(str);\n      } else if (str.length == 0) {\n        return null;\n      } else {\n        return str;\n      }\n    }\n\n    /**\n     * Creates an XHR wrapped in a Promise\n     * @param {!String} URL - url to send a `GET` request to\n     * @return {Promise} Returns a then-able promise with `XMLHttpRequest.responseText`\n     * */\n\n  }, {\n    key: 'promiseRequest',\n    value: function promiseRequest(URL) {\n      return new Promise(function (resolve, reject) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', URL, true);\n        xhr.onload = function (e) {\n          xhr.status == 200 ? resolve(xhr.responseText) : reject(Error(xhr.status + ': ' + xhr.statusText));\n        };\n        xhr.onerror = function (e) {\n          reject(e);\n        };\n        xhr.send();\n      });\n    }\n\n    /**\n     * Gets a variable listed in query string\n     * @param {!String} variable - variable name to get value for\n     * @param {String=} [query=window.location.search.substring(1)] - the query string to search variable for in\n     * @return {String} Returns value for the variable\n     * */\n\n  }, {\n    key: 'getQueryVariable',\n    value: function getQueryVariable(variable) {\n      var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.location.search.substring(1);\n\n      var vars = query.split(\"&\");\n      for (var i = 0; i < vars.length; i++) {\n        var pair = vars[i].split(\"=\");\n        if (pair[0].toLowerCase() == variable.toLowerCase()) {\n          return pair[1];\n        }\n      }\n      return null;\n    }\n  }]);\n\n  return ReportalBase;\n}();\n\nexports.default = ReportalBase;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItcmVwb3J0YWwtYmFzZS9zcmMvcmVwb3J0YWwtYmFzZS5qcz9kYTM1Il0sIm5hbWVzIjpbIlJlcG9ydGFsQmFzZSIsInRhcmdldCIsInNvdXJjZSIsImkiLCJsZXZlbCIsImFyZ3MiLCJsZW5ndGgiLCJBcnJheSIsImlzQXJyYXkiLCJjb25zb2xlIiwiYXBwbHkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJhcmd1bWVudHMiLCJfbG9nZ2VyIiwibmFtZSIsImV2ZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsInN0ciIsImlzTmFOIiwicGFyc2VGbG9hdCIsInJlcGxhY2UiLCJVUkwiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsIm9ubG9hZCIsInN0YXR1cyIsInJlc3BvbnNlVGV4dCIsIkVycm9yIiwic3RhdHVzVGV4dCIsIm9uZXJyb3IiLCJlIiwic2VuZCIsInZhcmlhYmxlIiwicXVlcnkiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInNlYXJjaCIsInN1YnN0cmluZyIsInZhcnMiLCJzcGxpdCIsInBhaXIiLCJ0b0xvd2VyQ2FzZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztJQUFNQSxZOzs7Ozs7Ozs7QUFFSjs7Ozs7Ozs7Ozs7OzBCQVlhQyxNLEVBQVFDLE0sRUFBUTtBQUMzQixXQUFLLElBQUlDLENBQVQsSUFBY0QsTUFBZCxFQUFzQjtBQUNwQkQsZUFBT0UsQ0FBUCxJQUFZRCxPQUFPQyxDQUFQLENBQVo7QUFDRDtBQUNELGFBQU9GLE1BQVA7QUFDRDs7OzRCQUVjRyxLLEVBQU9DLEksRUFBTTtBQUMxQjtBQUNBLFVBQUlBLEtBQUtDLE1BQUwsS0FBZ0IsQ0FBaEIsSUFBcUJDLE1BQU1DLE9BQU4sQ0FBY0gsS0FBSyxDQUFMLENBQWQsQ0FBekIsRUFBaUQ7QUFDL0NBLGVBQU9BLEtBQUssQ0FBTCxDQUFQO0FBQ0Q7QUFDRDtB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WWhELFkiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFJlcG9ydGFsQmFzZSB7XG5cbiAgLyoqXG4gICAqIENvcGllcyBwcm9wcyBmcm9tIGEgc291cmNlIG9iamVjdCB0byBhIHRhcmdldCBvYmplY3QuXG4gICAqXG4gICAqIE5vdGUsIHRoaXMgbWV0aG9kIHVzZXMgYSBzaW1wbGUgYGZvci4uLmluYCBzdHJhdGVneSBmb3IgZW51bWVyYXRpbmdcbiAgICogcHJvcGVydGllcy4gIFRvIGVuc3VyZSBvbmx5IGBvd25Qcm9wZXJ0aWVzYCBhcmUgY29waWVkIGZyb20gc291cmNlXG4gICAqIHRvIHRhcmdldCBhbmQgdGhhdCBhY2Nlc3NvciBpbXBsZW1lbnRhdGlvbnMgYXJlIGNvcGllZCwgdXNlIGBleHRlbmRgLlxuICAgKlxuICAgKiBAbWV0aG9kIG1peGluXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGFyZ2V0IG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgU291cmNlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAgICogQHJldHVybiB7T2JqZWN0fSBUYXJnZXQgb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCBhcyBmaXJzdCBhcmd1bWVudC5cbiAgICovXG4gIHN0YXRpYyBtaXhpbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIGZvciAodmFyIGkgaW4gc291cmNlKSB7XG4gICAgICB0YXJnZXRbaV0gPSBzb3VyY2VbaV07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBzdGF0aWMgX2xvZ2dlcihsZXZlbCwgYXJncykge1xuICAgIC8vIGFjY2VwdCBbJ2ZvbycsICdiYXInXSBhbmQgW1snZm9vJywgJ2JhciddXVxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICBhcmdzID0gYXJnc1swXTtcbiAgICB9XG4gICAgLy8gb25seSBhY2NlcHQgbG9nZ2luZyBmdW5jdGlvbnNcbiAgICBzd2l0Y2gobGV2ZWwpIHtcbiAgICAgIGNhc2UgJ2xvZyc6XG4gICAgICBjYXNlICd3YXJuJzpcbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgY29uc29sZVtsZXZlbF0uYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBfbG9nKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICB0aGlzLl9sb2dnZXIoJ2xvZycsIGFyZ3MpO1xuICB9XG5cbiAgc3RhdGljIF93YXJuKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICB0aGlzLl9sb2dnZXIoJ3dhcm4nLCBhcmdzKTtcbiAgfVxuXG4gIHN0YXRpYyBfZXJyb3IoKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgIHRoaXMuX2xvZ2dlcignZXJyb3InLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmFtZWQgZXZlbnQgd2l0aCBgbmFtZWBcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcmV0dXJuIHtFdmVudH0gUmV0dXJucyBhIGNyZWF0ZWQgZXZlbnRcbiAgICogKi9cbiAgc3RhdGljIG5ld0V2ZW50KG5hbWUpe1xuICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LmluaXRFdmVudChuYW1lLCB0cnVlLCB0cnVlKTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cblxuICAvKipcbiAgICogSW5zcGVjdHMgaWYgdGhlIGN1cnJlbnQgc3RyaW5nIG1pZ2h0IGJlIGNvbnZlcnRlZCB0byBudW1iZXIgYW5kIHJlbmRlcnMgaXQgYXMgbnVtYmVyLiBJZiBzdHJpbmcgbGVuZ3RoIGlzIDAsIHJldHVybnMgYG51bGxgLiBJZiBub25lIGFwcGxpZXMgcmV0dXJucyB0aGUgc3RyaW5nIGFzIGlzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gdmFsdWUgb2YgdGhlIGNlbGwgaWYgbm90IEhUTUwgY29udGVudHNcbiAgICogQHJldHVybiB7TnVtYmVyfG51bGx8U3RyaW5nfVxuICAgKiAqL1xuICBzdGF0aWMgaXNOdW1iZXIoc3RyKXtcbiAgICBpZighaXNOYU4ocGFyc2VGbG9hdChzdHIpKSl7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgvLC9pLCcnKTsvLyByZW1vdmUgdW5uZWNlc3NhcnkgY29tbWEgYXMgYSBkZWxpbWl0ZXIgZm9yIHRob3VzYW5kcyBmcm9tIGRhdGEuXG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIpO1xuICAgIH0gZWxzZSBpZihzdHIubGVuZ3RoPT0wKXtyZXR1cm4gbnVsbH0gZWxzZSB7cmV0dXJuIHN0cn1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gWEhSIHdyYXBwZWQgaW4gYSBQcm9taXNlXG4gICAqIEBwYXJhbSB7IVN0cmluZ30gVVJMIC0gdXJsIHRvIHNlbmQgYSBgR0VUYCByZXF1ZXN0IHRvXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJldHVybnMgYSB0aGVuLWFibGUgcHJvbWlzZSB3aXRoIGBYTUxIdHRwUmVxdWVzdC5yZXNwb25zZVRleHRgXG4gICAqICovXG4gIHN0YXRpYyBwcm9taXNlUmVxdWVzdChVUkwpe1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSxyZWplY3QpPT57XG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIub3BlbignR0VUJywgVVJMLCB0cnVlKTtcbiAgICAgIHhoci5vbmxvYWQgPSBlPT57eGhyLnN0YXR1cyA9PSAyMDA/cmVzb2x2ZSh4aHIucmVzcG9uc2VUZXh0KTpyZWplY3QoRXJyb3IoYCR7eGhyLnN0YXR1c306ICR7eGhyLnN0YXR1c1RleHR9YCkpO31cbiAgICAgIHhoci5vbmVycm9yID0gZT0+e3JlamVjdChlKX1cbiAgICAgIHhoci5zZW5kKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIHZhcmlhYmxlIGxpc3RlZCBpbiBxdWVyeSBzdHJpbmdcbiAgICogQHBhcmFtIHshU3RyaW5nfSB2YXJpYWJsZSAtIHZhcmlhYmxlIG5hbWUgdG8gZ2V0IHZhbHVlIGZvclxuICAgKiBAcGFyYW0ge1N0cmluZz19IFtxdWVyeT13aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKV0gLSB0aGUgcXVlcnkgc3RyaW5nIHRvIHNlYXJjaCB2YXJpYWJsZSBmb3IgaW5cbiAgICogQHJldHVybiB7U3RyaW5nfSBSZXR1cm5zIHZhbHVlIGZvciB0aGUgdmFyaWFibGVcbiAgICogKi9cbiAgc3RhdGljIGdldFF1ZXJ5VmFyaWFibGUodmFyaWFibGUscXVlcnk9d2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpe1xuICAgIHZhciB2YXJzID0gcXVlcnkuc3BsaXQoXCImXCIpO1xuICAgIGZvciAodmFyIGk9MDtpPHZhcnMubGVuZ3RoO2krKykge1xuICAgICAgdmFyIHBhaXIgPSB2YXJzW2ldLnNwbGl0KFwiPVwiKTtcbiAgICAgIGlmKChwYWlyWzBdKS50b0xvd2VyQ2FzZSgpID09IHZhcmlhYmxlLnRvTG93ZXJDYXNlKCkpe3JldHVybiBwYWlyWzFdO31cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxufVxuZXhwb3J0IGRlZmF1bHQgUmVwb3J0YWxCYXNlXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3ItcmVwb3J0YWwtYmFzZS9zcmMvcmVwb3J0YWwtYmFzZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by IvanP on 21.09.2016.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//import TableDataRowMeta from \"./TableDataRowMeta\";\n\n/**\r\n * A base class for stripping data from HTML tables\r\n * */\nvar TableData = function () {\n  function TableData() {\n    _classCallCheck(this, TableData);\n  }\n\n  _createClass(TableData, null, [{\n    key: 'detectMultidimensional',\n\n    /**\r\n     * Detects if the dataset is multi-dimentional and sets classes on items: a rowspanning cell gets a `.blockCell` and the row containing it a `.firstInBlock`\r\n     * __Doesn't work with `Horizontal Percents` enabled!__\r\n     * @param {HTMLTableElement} source - source table\r\n     * @return {Boolean} Returns if the data in table is multi-dimentional\r\n     * */\n    value: function detectMultidimensional(source) {\n      var multidimensional = false;\n      var blocks = source.parentNode.querySelectorAll('table#' + source.id + '>tbody>tr>td:nth-child(1)[rowspan]');\n      if (blocks.length > 0) {\n        multidimensional = true;\n        [].slice.call(blocks).forEach(function (blockCell) {\n          blockCell.classList.add('blockCell');\n          blockCell.parentNode.classList.add('firstInBlock');\n        });\n      }\n      return multidimensional;\n    }\n\n    /**\r\n     * Extracts data from a given cell. Override in an inherited class if you need to add any metadata to it.\r\n     * @param {HTMLTableCellElement} cell - cell element to have data stripped off it\r\n     * @param {HTMLTableCellElement} rowIndex - index of the row it's in\r\n     * @param {HTMLTableCellElement} columnIndex - index of the column it's in\r\n     * @returns {?String|?Number} Returns a `String`, a `Number` or a `null` (if data is absent in the cell or its text content boils down to an empty string - i.e. there are no characters in the cell, only HTML tags)\r\n     * */\n\n  }, {\n    key: 'prepareDataCell',\n    value: function prepareDataCell(cell, rowIndex, columnIndex) {\n      return _rReportalBase2.default.isNumber(cell.textContent.trim());\n      /*return {\r\n          cell,\r\n          data: ReportalBase.isNumber(cell.textContent.trim()),\r\n          rowIndex,\r\n          columnIndex\r\n        }*/\n    }\n\n    /**\r\n     * A universal data-extraction function. It strips data from a table's body. Data can be stripped by rows (horizontally) or by columns (vertically) which is controlled by `direction`. It accounts for a spanning block cell and may exclude it.\r\n     * @param {Object} options - options to configure the way data is stripped off the table\r\n     * @param {HTMLTableElement} options.source - source table that will be an input for data stripping\r\n     * @param {String=} options.direction='row' - direction in which data stripping will occur: `row` strips across rows and presents an array where each array item is an array of cell values. `column` strips values verticaly in a column, the resulting array will contain arrays (per column) with values resembling normalized data for cells in the column\r\n     * @param {Boolean=} [options.excludeBlock=true] - if table contains block cells that rowspan across several rows, we might need to exclude those from actual data\r\n     * @param {Array|Number} [options.excludeColumns] - if table contains columns that are not to be in data, then pass a single index or an array of cell indices (0-based). You need to count columns not by headers but by the cells in rows.\r\n     * @param {Array|Number} [options.excludeRows] - if table contains rows that are not to be in data, then pass a single index or an array of row indices (0-based). You need to count only rows that contain data, not the table-header rows.\r\n     * @param {Boolean=} options.multidimensional=false - whether the table has aggregating cells that aggregate rowheaders. Result of {@link TableData#detectMultidimensional} may be passed here to automatically calculate if it has aggregating cells.\r\n     * @returns {Array} returns data array.\r\n     * */\n\n  }, {\n    key: 'getData',\n    value: function getData(options) {\n      var _this = this;\n\n      var source = options.source,\n          _options$excludeBlock = options.excludeBlock,\n          excludeBlock = _options$excludeBlock === undefined ? true : _options$excludeBlock,\n          excludeColumns = options.excludeColumns,\n          excludeRows = options.excludeRows,\n          _options$direction = options.direction,\n          direction = _options$direction === undefined ? 'row' : _options$direction,\n          _options$multidimensi = options.multidimensional,\n          multidimensional = _options$multidimensi === undefined ? false : _options$multidimensi;\n\n      var data = [];\n      if (source && source.tagName == 'TABLE') {\n        (function () {\n          var rows = [].slice.call(source.parentNode.querySelectorAll('table#' + source.id + '>tbody>tr'));\n          if (rows.length > 0) {\n            (function () {\n              var tempArray = [];\n              // account for a negative row number (`-1`) meaning last row\n              if ((typeof excludeRows === 'undefined' ? 'undefined' : _typeof(excludeRows)) != undefined) {\n                if (typeof excludeRows == 'number') {\n                  // for non-block rows in multidimensional\n                  if (excludeRows < 0) {\n                    // account for a negative column number (e.g.`-1`) meaning last column\n                    excludeRows = rows.length + excludeRows;\n                  }\n                  rows.splice(excludeRows, 1);\n                }\n                if (Array.isArray(excludeRows)) {\n                  excludeRows.sort(function (a, b) {\n                    return a > b ? 1 : -1;\n                  }).reverse(); //sort to splice from the end of the array\n                  excludeRows.forEach(function (i) {\n                    if (i >= 0) {\n                      rows.splice(i, 1);\n                    } else {\n                      rows.splice(rows.length + i, 1);\n                    }\n                  });\n                }\n              }\n              rows.forEach(function (row, rowIndex) {\n                if (multidimensional) {\n                  // we need to check if the `tempArray` is not empty and push it to the `data` array, because we've encountered a new block, so the old block has to be pushed to data. Then we need to create a new block array and push there\n                  if (row.classList.contains('firstInBlock')) {\n                    if (Array.isArray(tempArray) && tempArray.length > 0) {\n                      data.push(tempArray);\n                    }\n                    tempArray = [];\n                  }\n                }\n\n                if (direction == 'row' && !Array.isArray(tempArray[tempArray.length])) {\n                  // if a row in an array doesn't exist create it\n                  tempArray[tempArray.length] = [];\n                }\n\n                // calculate which cells to exclude\n                var cells = [].slice.call(row.children);\n                var temp_excludeColumns = excludeColumns;\n                if ((typeof temp_excludeColumns === 'undefined' ? 'undefined' : _typeof(temp_excludeColumns)) != undefined) {\n                  if (typeof temp_excludeColumns == 'number') {\n                    // for non-block rows in multidimensional\n                    if (multidimensional && !row.classList.contains('firstInBlock') && !temp_excludeColumns < 0) {\n                      temp_excludeColumns = temp_excludeColumns + 1;\n                    }\n                    if (temp_excludeColumns < 0) {\n                      // account for a negative column number (e.g.`-1`) meaning last column\n                      temp_excludeColumns = cells.length + temp_excludeColumns;\n                    }\n                    cells.splice(temp_excludeColumns, 1);\n                  }\n                  if (Array.isArray(temp_excludeColumns)) {\n                    temp_excludeColumns.sort(function (a, b) {\n                      return a > b ? 1 : -1;\n                    }).reverse();\n                    temp_excludeColumns.forEach(function (i) {\n                      if (i >= 0) {\n                        cells.splice(multidimensional && !row.classList.contains('firstInBlock') ? i + 1 : i, 1);\n                      } else {\n                        cells.splice(cells.length + i, 1);\n                      }\n                    });\n                  }\n                }\n\n                cells.forEach(function (cell, index) {\n\n                  // we want to run this every row because number of cells in each row may differ and we want to exclude the last one\n                  if (typeof direction == 'string' && direction == 'row') {\n                    //if we strip data horizontally by row\n                    if (!(multidimensional && excludeBlock && cell.rowSpan > 1)) {\n                      // if it's a block cell we'd exclude it from data\n                      tempArray[tempArray.length - 1].push(_this.prepareDataCell(cell, rowIndex, index));\n                    }\n                  } else if (typeof direction == 'string' && direction == 'column') {\n                    //if we strip data vertically by column\n                    var realIndex = index;\n                    if (!(multidimensional && excludeBlock && cell.rowSpan > 1)) {\n                      //exclude block cell\n                      realIndex += !row.classList.contains('firstInBlock') ? 0 : -1; // offset cell that follows block cell one position back\n                      if (!Array.isArray(tempArray[realIndex])) {\n                        //create column array for current column if not available\n                        tempArray[realIndex] = [];\n                      }\n                      tempArray[realIndex].push(_this.prepareDataCell(cell, rowIndex, realIndex));\n                    }\n                  } else {\n                    throw new TypeError('direction has tobe a String==`row | column`, not a ${direction}');\n                  }\n                });\n              });\n              //we need to push the last block Array because there'll be no `.firstInBlock` anymore to do that\n              if (multidimensional && Array.isArray(tempArray) && tempArray.length > 0) {\n                data.push(tempArray);\n              } else {\n                data = tempArray;\n              }\n            })();\n          } else {\n            throw new Error('table#' + source.id + '\\'s body must contain rows');\n          }\n        })();\n      } else {\n        throw new TypeError('source must be defined and be a table');\n      }\n      return data;\n    }\n  }]);\n\n  return TableData;\n}();\n\nexports.default = TableData;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItYWdncmVnYXRlZC10YWJsZS9zcmMvdGFibGUtZGF0YS5qcz84ZDlhIl0sIm5hbWVzIjpbIlRhYmxlRGF0YSIsInNvdXJjZSIsIm11bHRpZGltZW5zaW9uYWwiLCJibG9ja3MiLCJwYXJlbnROb2RlIiwicXVlcnlTZWxlY3RvckFsbCIsImlkIiwibGVuZ3RoIiwic2xpY2UiLCJjYWxsIiwiZm9yRWFjaCIsImJsb2NrQ2VsbCIsImNsYXNzTGlzdCIsImFkZCIsImNlbGwiLCJyb3dJbmRleCIsImNvbHVtbkluZGV4IiwiaXNOdW1iZXIiLCJ0ZXh0Q29udGVudCIsInRyaW0iLCJvcHRpb25zIiwiZXhjbHVkZUJsb2NrIiwiZXhjbHVkZUNvbHVtbnMiLCJleGNsdWRlUm93cyIsImRpcmVjdGlvbiIsImRhdGEiLCJ0YWdOYW1lIiwicm93cyIsInRlbXBBcnJheSIsInVuZGVmaW5lZCIsInNwbGljZSIsIkFycmF5IiwiaXNBcnJheSIsInNvcnQiLCJhIiwiYiIsInJldmVyc2UiLCJpIiwicm93IiwiY29udGFpbnMiLCJwdXNoIiwiY2VsbHMiLCJjaGlsZHJlbiIsInRlbXBfZXhjbHVkZUNvbHVtbnMiLCJpbmRleCIsInJvd1NwYW4iLCJwcmVwYXJlRGF0YUNlbGwiLCJyZWFsSW5kZXgiLCJUeXBlRXJyb3IiLCJFcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7cWpCQUFBOzs7OztBQUdBOzs7Ozs7OztBQUNBOztBQUVBOzs7SUFHTUEsUzs7Ozs7Ozs7QUFDSjs7Ozs7OzJDQU04QkMsTSxFQUFPO0FBQ25DLFVBQUlDLG1CQUFtQixLQUF2QjtBQUNBLFVBQUlDLFNBQVNGLE9BQU9HLFVBQVAsQ0FBa0JDLGdCQUFsQixZQUE0Q0osT0FBT0ssRUFBbkQsd0NBQWI7QUFDQSxVQUFHSCxPQUFPSSxNQUFQLEdBQWMsQ0FBakIsRUFBbUI7QUFDakJMLDJCQUFtQixJQUFuQjtBQUNBLFdBQUdNLEtBQUgsQ0FBU0MsSUFBVCxDQUFjTixNQUFkLEVB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LE1BQUtNLGVBQUwsQ0FBcUJoQyxJQUFyQixFQUEwQkMsUUFBMUIsRUFBbUNnQyxTQUFuQyxDQUExQjtBQUNEO0FBQ0YsbUJBVE0sTUFTQTtBQUNMLDBCQUFNLElBQUlDLFNBQUosQ0FBYyxpRUFBZCxDQUFOO0FBQ0Q7QUFDRixpQkFuQkQ7QUFvQkQsZUEzREQ7QUE0REE7QUFDQSxrQkFBRzlDLG9CQUFvQjZCLE1BQU1DLE9BQU4sQ0FBY0osU0FBZCxDQUFwQixJQUFnREEsVUFBVXJCLE1BQVYsR0FBaUIsQ0FBcEUsRUFBc0U7QUFDcEVrQixxQkFBS2UsSUFBTCxDQUFVWixTQUFWO0FBQ0QsZUFGRCxNQUVPO0FBQ0xILHVCQUFPRyxTQUFQO0FBQ0Q7QUF4RmM7QUF5RmhCLFdBekZELE1BeUZPO0FBQ0wsa0JBQU0sSUFBSXFCLEtBQUosWUFBbUJoRCxPQUFPSyxFQUExQixnQ0FBTjtBQUNEO0FBN0ZvQztBQThGdEMsT0E5RkQsTUE4Rk87QUFDTCxjQUFNLElBQUkwQyxTQUFKLENBQWMsdUNBQWQsQ0FBTjtBQUNEO0FBQ0QsYUFBT3ZCLElBQVA7QUFDRDs7Ozs7O2tCQUlZekIsUyIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENyZWF0ZWQgYnkgSXZhblAgb24gMjEuMDkuMjAxNi5cclxuICovXHJcbmltcG9ydCBSZXBvcnRhbEJhc2UgZnJvbSBcInItcmVwb3J0YWwtYmFzZVwiO1xyXG4vL2ltcG9ydCBUYWJsZURhdGFSb3dNZXRhIGZyb20gXCIuL1RhYmxlRGF0YVJvd01ldGFcIjtcclxuXHJcbi8qKlxyXG4gKiBBIGJhc2UgY2xhc3MgZm9yIHN0cmlwcGluZyBkYXRhIGZyb20gSFRNTCB0YWJsZXNcclxuICogKi9cclxuY2xhc3MgVGFibGVEYXRhIHtcclxuICAvKipcclxuICAgKiBEZXRlY3RzIGlmIHRoZSBkYXRhc2V0IGlzIG11bHRpLWRpbWVudGlvbmFsIGFuZCBzZXRzIGNsYXNzZXMgb24gaXRlbXM6IGEgcm93c3Bhbm5pbmcgY2VsbCBnZXRzIGEgYC5ibG9ja0NlbGxgIGFuZCB0aGUgcm93IGNvbnRhaW5pbmcgaXQgYSBgLmZpcnN0SW5CbG9ja2BcclxuICAgKiBfX0RvZXNuJ3Qgd29yayB3aXRoIGBIb3Jpem9udGFsIFBlcmNlbnRzYCBlbmFibGVkIV9fXHJcbiAgICogQHBhcmFtIHtIVE1MVGFibGVFbGVtZW50fSBzb3VyY2UgLSBzb3VyY2UgdGFibGVcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGlmIHRoZSBkYXRhIGluIHRhYmxlIGlzIG11bHRpLWRpbWVudGlvbmFsXHJcbiAgICogKi9cclxuICBzdGF0aWMgZGV0ZWN0TXVsdGlkaW1lbnNpb25hbChzb3VyY2Upe1xyXG4gICAgbGV0IG11bHRpZGltZW5zaW9uYWwgPSBmYWxzZTtcclxuICAgIGxldCBibG9ja3MgPSBzb3VyY2UucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKGB0YWJsZSMke3NvdXJjZS5pZH0+dGJvZHk+dHI+dGQ6bnRoLWNoaWxkKDEpW3Jvd3NwYW5dYCk7XHJcbiAgICBpZihibG9ja3MubGVuZ3RoPjApe1xyXG4gICAgICBtdWx0aWRpbWVuc2lvbmFsID0gdHJ1ZTtcclxuICAgICAgW10uc2xpY2UuY2FsbChibG9ja3MpLmZvckVhY2goYmxvY2tDZWxsPT57XHJcbiAgICAgICAgYmxvY2tDZWxsLmNsYXNzTGlzdC5hZGQoJ2Jsb2NrQ2VsbCcpO1xyXG4gICAgICAgIGJsb2NrQ2VsbC5wYXJlbnROb2RlLmNsYXNzTGlzdC5hZGQoJ2ZpcnN0SW5CbG9jaycpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBtdWx0aWRpbWVuc2lvbmFsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeHRyYWN0cyBkYXRhIGZyb20gYSBnaXZlbiBjZWxsLiBPdmVycmlkZSBpbiBhbiBpbmhlcml0ZWQgY2xhc3MgaWYgeW91IG5lZWQgdG8gYWRkIGFueSBtZXRhZGF0YSB0byBpdC5cclxuICAgKiBAcGFyYW0ge0hUTUxUYWJsZUNlbGxFbGVtZW50fSBjZWxsIC0gY2VsbCBlbGVtZW50IHRvIGhhdmUgZGF0YSBzdHJpcHBlZCBvZmYgaXRcclxuICAgKiBAcGFyYW0ge0hUTUxUYWJsZUNlbGxFbGVtZW50fSByb3dJbmRleCAtIGluZGV4IG9mIHRoZSByb3cgaXQncyBpblxyXG4gICAqIEBwYXJhbSB7SFRNTFRhYmxlQ2VsbEVsZW1lbnR9IGNvbHVtbkluZGV4IC0gaW5kZXggb2YgdGhlIGNvbHVtbiBpdCdzIGluXHJcbiAgICogQHJldHVybnMgez9TdHJpbmd8P051bWJlcn0gUmV0dXJucyBhIGBTdHJpbmdgLCBhIGBOdW1iZXJgIG9yIGEgYG51bGxgIChpZiBkYXRhIGlzIGFic2VudCBpbiB0aGUgY2VsbCBvciBpdHMgdGV4dCBjb250ZW50IGJvaWxzIGRvd24gdG8gYW4gZW1wdHkgc3RyaW5nIC0gaS5lLiB0aGVyZSBhcmUgbm8gY2hhcmFjdGVycyBpbiB0aGUgY2VsbCwgb25seSBIVE1MIHRhZ3MpXHJcbiAgICogKi9cclxuICBzdGF0aWMgcHJlcGFyZURhdGFDZWxsKGNlbGwsIHJvd0luZGV4LCBjb2x1bW5JbmRleCl7XHJcbiAgIHJldHVybiBSZXBvcnRhbEJhc2UuaXNOdW1iZXIoY2VsbC50ZXh0Q29udGVudC50cmltKCkpO1xyXG4gICAgLypyZXR1cm4ge1xyXG4gICAgICAgIGNlbGwsXHJcbiAgICAgICAgZGF0YTogUmVwb3J0YWxCYXNlLmlzTnVtYmVyKGNlbGwudGV4dENvbnRlbnQudHJpbSgpKSxcclxuICAgICAgICByb3dJbmRleCxcclxuICAgICAgICBjb2x1bW5JbmRleFxyXG4gICAgICB9Ki9cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgdW5pdmVyc2FsIGRhdGEtZXh0cmFjdGlvbiBmdW5jdGlvbi4gSXQgc3RyaXBzIGRhdGEgZnJvbSBhIHRhYmxlJ3MgYm9keS4gRGF0YSBjYW4gYmUgc3RyaXBwZWQgYnkgcm93cyAoaG9yaXpvbnRhbGx5KSBvciBieSBjb2x1bW5zICh2ZXJ0aWNhbGx5KSB3aGljaCBpcyBjb250cm9sbGVkIGJ5IGBkaXJlY3Rpb25gLiBJdCBhY2NvdW50cyBmb3IgYSBzcGFubmluZyBibG9jayBjZWxsIGFuZCBtYXkgZXhjbHVkZSBpdC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSB3YXkgZGF0YSBpcyBzdHJpcHBlZCBvZmYgdGhlIHRhYmxlXHJcbiAgICogQHBhcmFtIHtIVE1MVGFibGVFbGVtZW50fSBvcHRpb25zLnNvdXJjZSAtIHNvdXJjZSB0YWJsZSB0aGF0IHdpbGwgYmUgYW4gaW5wdXQgZm9yIGRhdGEgc3RyaXBwaW5nXHJcbiAgICogQHBhcmFtIHtTdHJpbmc9fSBvcHRpb25zLmRpcmVjdGlvbj0ncm93JyAtIGRpcmVjdGlvbiBpbiB3aGljaCBkYXRhIHN0cmlwcGluZyB3aWxsIG9jY3VyOiBgcm93YCBzdHJpcHMgYWNyb3NzIHJvd3MgYW5kIHByZXNlbnRzIGFuIGFycmF5IHdoZXJlIGVhY2ggYXJyYXkgaXRlbSBpcyBhbiBhcnJheSBvZiBjZWxsIHZhbHVlcy4gYGNvbHVtbmAgc3RyaXBzIHZhbHVlcyB2ZXJ0aWNhbHkgaW4gYSBjb2x1bW4sIHRoZSByZXN1bHRpbmcgYXJyYXkgd2lsbCBjb250YWluIGFycmF5cyAocGVyIGNvbHVtbikgd2l0aCB2YWx1ZXMgcmVzZW1ibGluZyBub3JtYWxpemVkIGRhdGEgZm9yIGNlbGxzIGluIHRoZSBjb2x1bW5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBbb3B0aW9ucy5leGNsdWRlQmxvY2s9dHJ1ZV0gLSBpZiB0YWJsZSBjb250YWlucyBibG9jayBjZWxscyB0aGF0IHJvd3NwYW4gYWNyb3NzIHNldmVyYWwgcm93cywgd2UgbWlnaHQgbmVlZCB0byBleGNsdWRlIHRob3NlIGZyb20gYWN0dWFsIGRhdGFcclxuICAgKiBAcGFyYW0ge0FycmF5fE51bWJlcn0gW29wdGlvbnMuZXhjbHVkZUNvbHVtbnNdIC0gaWYgdGFibGUgY29udGFpbnMgY29sdW1ucyB0aGF0IGFyZSBub3QgdG8gYmUgaW4gZGF0YSwgdGhlbiBwYXNzIGEgc2luZ2xlIGluZGV4IG9yIGFuIGFycmF5IG9mIGNlbGwgaW5kaWNlcyAoMC1iYXNlZCkuIFlvdSBuZWVkIHRvIGNvdW50IGNvbHVtbnMgbm90IGJ5IGhlYWRlcnMgYnV0IGJ5IHRoZSBjZWxscyBpbiByb3dzLlxyXG4gICAqIEBwYXJhbSB7QXJyYXl8TnVtYmVyfSBbb3B0aW9ucy5leGNsdWRlUm93c10gLSBpZiB0YWJsZSBjb250YWlucyByb3dzIHRoYXQgYXJlIG5vdCB0byBiZSBpbiBkYXRhLCB0aGVuIHBhc3MgYSBzaW5nbGUgaW5kZXggb3IgYW4gYXJyYXkgb2Ygcm93IGluZGljZXMgKDAtYmFzZWQpLiBZb3UgbmVlZCB0byBjb3VudCBvbmx5IHJvd3MgdGhhdCBjb250YWluIGRhdGEsIG5vdCB0aGUgdGFibGUtaGVhZGVyIHJvd3MuXHJcbiAgICogQHBhcmFtIHtCb29sZWFuPX0gb3B0aW9ucy5tdWx0aWRpbWVuc2lvbmFsPWZhbHNlIC0gd2hldGhlciB0aGUgdGFibGUgaGFzIGFnZ3JlZ2F0aW5nIGNlbGxzIHRoYXQgYWdncmVnYXRlIHJvd2hlYWRlcnMuIFJlc3VsdCBvZiB7QGxpbmsgVGFibGVEYXRhI2RldGVjdE11bHRpZGltZW5zaW9uYWx9IG1heSBiZSBwYXNzZWQgaGVyZSB0byBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZSBpZiBpdCBoYXMgYWdncmVnYXRpbmcgY2VsbHMuXHJcbiAgICogQHJldHVybnMge0FycmF5fSByZXR1cm5zIGRhdGEgYXJyYXkuXHJcbiAgICogKi9cclxuICBzdGF0aWMgZ2V0RGF0YShvcHRpb25zKXtcclxuICAgIGxldCB7c291cmNlLGV4Y2x1ZGVCbG9jaz10cnVlLGV4Y2x1ZGVDb2x1bW5zLGV4Y2x1ZGVSb3dzLGRpcmVjdGlvbj0ncm93JyxtdWx0aWRpbWVuc2lvbmFsPWZhbHNlfT1vcHRpb25zO1xyXG4gICAgbGV0IGRhdGEgPSBbXTtcclxuICAgIGlmKHNvdXJjZSAmJiBzb3VyY2UudGFnTmFtZSA9PSAnVEFCTEUnKXtcclxuICAgICAgbGV0IHJvd3MgPSBbXS5zbGljZS5jYWxsKHNvdXJjZS5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoYHRhYmxlIyR7c291cmNlLmlkfT50Ym9keT50cmApKTtcclxuICAgICAgaWYocm93cy5sZW5ndGg+MCl7XHJcbiAgICAgICAgbGV0IHRlbXBBcnJheT1bXTtcclxuICAgICAgICAvLyBhY2NvdW50IGZvciBhIG5lZ2F0aXZlIHJvdyBudW1iZXIgKGAtMWApIG1lYW5pbmcgbGFzdCByb3dcclxuICAgICAgICBpZih0eXBlb2YgZXhjbHVkZVJvd3MgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgIGlmKHR5cGVvZiBleGNsdWRlUm93cyA9PSAnbnVtYmVyJyl7XHJcbiAgICAgICAgICAgIC8vIGZvciBub24tYmxvY2sgcm93cyBpbiBtdWx0aWRpbWVuc2lvbmFsXHJcbiAgICAgICAgICAgIGlmKGV4Y2x1ZGVSb3dzPDApeyAvLyBhY2NvdW50IGZvciBhIG5lZ2F0aXZlIGNvbHVtbiBudW1iZXIgKGUuZy5gLTFgKSBtZWFuaW5nIGxhc3QgY29sdW1uXHJcbiAgICAgICAgICAgICAgZXhjbHVkZVJvd3M9IHJvd3MubGVuZ3RoK2V4Y2x1ZGVSb3dzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvd3Muc3BsaWNlKGV4Y2x1ZGVSb3dzLDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShleGNsdWRlUm93cykpe1xyXG4gICAgICAgICAgICBleGNsdWRlUm93cy5zb3J0KChhLGIpPT57cmV0dXJuIGE+Yj8xOi0xfSkucmV2ZXJzZSgpOyAvL3NvcnQgdG8gc3BsaWNlIGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXlcclxuICAgICAgICAgICAgZXhjbHVkZVJvd3MuZm9yRWFjaChpPT57XHJcbiAgICAgICAgICAgICAgaWYoaT49MCl7XHJcbiAgICAgICAgICAgICAgICByb3dzLnNwbGljZShpLDEpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByb3dzLnNwbGljZShyb3dzLmxlbmd0aCtpLDEpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByb3dzLmZvckVhY2goKHJvdyxyb3dJbmRleCk9PntcclxuICAgICAgICAgIGlmKG11bHRpZGltZW5zaW9uYWwpe1xyXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBgdGVtcEFycmF5YCBpcyBub3QgZW1wdHkgYW5kIHB1c2ggaXQgdG8gdGhlIGBkYXRhYCBhcnJheSwgYmVjYXVzZSB3ZSd2ZSBlbmNvdW50ZXJlZCBhIG5ldyBibG9jaywgc28gdGhlIG9sZCBibG9jayBoYXMgdG8gYmUgcHVzaGVkIHRvIGRhdGEuIFRoZW4gd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgYmxvY2sgYXJyYXkgYW5kIHB1c2ggdGhlcmVcclxuICAgICAgICAgICAgaWYocm93LmNsYXNzTGlzdC5jb250YWlucygnZmlyc3RJbkJsb2NrJykpe1xyXG4gICAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkodGVtcEFycmF5KSAmJiB0ZW1wQXJyYXkubGVuZ3RoPjApe2RhdGEucHVzaCh0ZW1wQXJyYXkpO31cclxuICAgICAgICAgICAgICB0ZW1wQXJyYXkgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChkaXJlY3Rpb249PSdyb3cnICYmICFBcnJheS5pc0FycmF5KHRlbXBBcnJheVt0ZW1wQXJyYXkubGVuZ3RoXSkpIHsgLy8gaWYgYSByb3cgaW4gYW4gYXJyYXkgZG9lc24ndCBleGlzdCBjcmVhdGUgaXRcclxuICAgICAgICAgICAgdGVtcEFycmF5W3RlbXBBcnJheS5sZW5ndGhdID0gW107XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHdoaWNoIGNlbGxzIHRvIGV4Y2x1ZGVcclxuICAgICAgICAgIGxldCBjZWxscyA9IFtdLnNsaWNlLmNhbGwocm93LmNoaWxkcmVuKTtcclxuICAgICAgICAgIGxldCB0ZW1wX2V4Y2x1ZGVDb2x1bW5zID0gZXhjbHVkZUNvbHVtbnM7XHJcbiAgICAgICAgICBpZih0eXBlb2YgdGVtcF9leGNsdWRlQ29sdW1ucyAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBpZih0eXBlb2YgdGVtcF9leGNsdWRlQ29sdW1ucyA9PSAnbnVtYmVyJyl7XHJcbiAgICAgICAgICAgICAgLy8gZm9yIG5vbi1ibG9jayByb3dzIGluIG11bHRpZGltZW5zaW9uYWxcclxuICAgICAgICAgICAgICBpZihtdWx0aWRpbWVuc2lvbmFsICYmICFyb3cuY2xhc3NMaXN0LmNvbnRhaW5zKCdmaXJzdEluQmxvY2snKSAmJiAhdGVtcF9leGNsdWRlQ29sdW1uczwwKXtcclxuICAgICAgICAgICAgICAgIHRlbXBfZXhjbHVkZUNvbHVtbnM9dGVtcF9leGNsdWRlQ29sdW1ucysxO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZih0ZW1wX2V4Y2x1ZGVDb2x1bW5zPDApeyAvLyBhY2NvdW50IGZvciBhIG5lZ2F0aXZlIGNvbHVtbiBudW1iZXIgKGUuZy5gLTFgKSBtZWFuaW5nIGxhc3QgY29sdW1uXHJcbiAgICAgICAgICAgICAgICB0ZW1wX2V4Y2x1ZGVDb2x1bW5zPSBjZWxscy5sZW5ndGgrdGVtcF9leGNsdWRlQ29sdW1ucztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgY2VsbHMuc3BsaWNlKHRlbXBfZXhjbHVkZUNvbHVtbnMsMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheSh0ZW1wX2V4Y2x1ZGVDb2x1bW5zKSl7XHJcbiAgICAgICAgICAgICAgdGVtcF9leGNsdWRlQ29sdW1ucy5zb3J0KChhLGIpPT57cmV0dXJuIGE+Yj8xOi0xfSkucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICAgIHRlbXBfZXhjbHVkZUNvbHVtbnMuZm9yRWFjaChpPT57XHJcbiAgICAgICAgICAgICAgICBpZihpPj0wKXtcclxuICAgICAgICAgICAgICAgICAgY2VsbHMuc3BsaWNlKG11bHRpZGltZW5zaW9uYWwgJiYgIXJvdy5jbGFzc0xpc3QuY29udGFpbnMoJ2ZpcnN0SW5CbG9jaycpP2krMTppLDEpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgY2VsbHMuc3BsaWNlKGNlbGxzLmxlbmd0aCtpLDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY2VsbHMuZm9yRWFjaCgoY2VsbCwgaW5kZXgpID0+IHtcclxuXHJcbiAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gcnVuIHRoaXMgZXZlcnkgcm93IGJlY2F1c2UgbnVtYmVyIG9mIGNlbGxzIGluIGVhY2ggcm93IG1heSBkaWZmZXIgYW5kIHdlIHdhbnQgdG8gZXhjbHVkZSB0aGUgbGFzdCBvbmVcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkaXJlY3Rpb24gPT0gJ3N0cmluZycgJiYgZGlyZWN0aW9uID09ICdyb3cnKSB7IC8vaWYgd2Ugc3RyaXAgZGF0YSBob3Jpem9udGFsbHkgYnkgcm93XHJcbiAgICAgICAgICAgICAgaWYoIShtdWx0aWRpbWVuc2lvbmFsICYmIGV4Y2x1ZGVCbG9jayAmJiBjZWxsLnJvd1NwYW4+MSkpeyAvLyBpZiBpdCdzIGEgYmxvY2sgY2VsbCB3ZSdkIGV4Y2x1ZGUgaXQgZnJvbSBkYXRhXHJcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXlbdGVtcEFycmF5Lmxlbmd0aC0xXS5wdXNoKHRoaXMucHJlcGFyZURhdGFDZWxsKGNlbGwscm93SW5kZXgsaW5kZXgpKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRpcmVjdGlvbiA9PSAnc3RyaW5nJyAmJiBkaXJlY3Rpb24gPT0gJ2NvbHVtbicpIHsgLy9pZiB3ZSBzdHJpcCBkYXRhIHZlcnRpY2FsbHkgYnkgY29sdW1uXHJcbiAgICAgICAgICAgICAgbGV0IHJlYWxJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgIGlmKCEobXVsdGlkaW1lbnNpb25hbCAmJiBleGNsdWRlQmxvY2sgJiYgY2VsbC5yb3dTcGFuPjEpKXsgLy9leGNsdWRlIGJsb2NrIGNlbGxcclxuICAgICAgICAgICAgICAgIHJlYWxJbmRleCArPSAhcm93LmNsYXNzTGlzdC5jb250YWlucygnZmlyc3RJbkJsb2NrJyk/IDAgOiAtMTsgLy8gb2Zmc2V0IGNlbGwgdGhhdCBmb2xsb3dzIGJsb2NrIGNlbGwgb25lIHBvc2l0aW9uIGJhY2tcclxuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0ZW1wQXJyYXlbcmVhbEluZGV4XSkpIHsgLy9jcmVhdGUgY29sdW1uIGFycmF5IGZvciBjdXJyZW50IGNvbHVtbiBpZiBub3QgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgICAgICAgIHRlbXBBcnJheVtyZWFsSW5kZXhdID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXlbcmVhbEluZGV4XS5wdXNoKHRoaXMucHJlcGFyZURhdGFDZWxsKGNlbGwscm93SW5kZXgscmVhbEluZGV4KSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RpcmVjdGlvbiBoYXMgdG9iZSBhIFN0cmluZz09YHJvdyB8IGNvbHVtbmAsIG5vdCBhICR7ZGlyZWN0aW9ufScpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vd2UgbmVlZCB0byBwdXNoIHRoZSBsYXN0IGJsb2NrIEFycmF5IGJlY2F1c2UgdGhlcmUnbGwgYmUgbm8gYC5maXJzdEluQmxvY2tgIGFueW1vcmUgdG8gZG8gdGhhdFxyXG4gICAgICAgIGlmKG11bHRpZGltZW5zaW9uYWwgJiYgQXJyYXkuaXNBcnJheSh0ZW1wQXJyYXkpICYmIHRlbXBBcnJheS5sZW5ndGg+MCl7XHJcbiAgICAgICAgICBkYXRhLnB1c2godGVtcEFycmF5KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBkYXRhID0gdGVtcEFycmF5O1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRhYmxlIyR7c291cmNlLmlkfSdzIGJvZHkgbXVzdCBjb250YWluIHJvd3NgKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc291cmNlIG11c3QgYmUgZGVmaW5lZCBhbmQgYmUgYSB0YWJsZScpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGFibGVEYXRhXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vci1hZ2dyZWdhdGVkLXRhYmxlL3NyYy90YWJsZS1kYXRhLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 3 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Created by IvanP on 17.08.2016.\r\n */\n/**\r\n * @property {HTMLTableRowElement} row - reference to the `<tr>` element\r\n * @property {?String} id - internal Reportal id for the rowheader in the row\r\n * @property {!HTMLTableCellElement} nameCell - reference to the `<td>` element that contains the rowheader label/name\r\n * @property {String} [name=nameCell.textContent] - label of the rowheader.\r\n * @property {?Object} [block=null] - the block the row belongs to\r\n * @property {Boolean} firstInBlock - this `row` is first in the `block`, which means it contains the first cell as a block cell\r\n * */\nvar AggregatedTableRowMeta =\n/**\r\n * Builds a prototype for each row of an Aggregated Table\r\n * @param {HTMLTableRowElement} row - reference to the `<tr>` element\r\n * @param {?String} id - internal Reportal id for the rowheader in the row\r\n * @param {!HTMLTableCellElement} nameCell - reference to the `<td>` element that contains the rowheader label/name\r\n * @param {String=} [name=nameCell.textContent] - label of the rowheader.\r\n * @param {?Object} [block=null] - the block the row belongs to\r\n * */\nfunction AggregatedTableRowMeta() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      row = _ref.row,\n      _ref$id = _ref.id,\n      id = _ref$id === undefined ? null : _ref$id,\n      nameCell = _ref.nameCell,\n      name = _ref.name,\n      _ref$block = _ref.block,\n      block = _ref$block === undefined ? null : _ref$block;\n\n  _classCallCheck(this, AggregatedTableRowMeta);\n\n  /*** @property {HTMLTableRowElement} row - reference to the `<tr>` element*/\n  this.row = row;\n  this.id = id;\n  this.nameCell = nameCell;\n  this.name = name || nameCell.textContent.trim();\n  this.block = block;\n  this.firstInBlock = block != null && this.row.rowIndex === this.block.cell.parentNode.rowIndex;\n}\n/*get firstInBlock(){\r\n  return this._firstInBlock;\r\n}\r\nset firstInBlock(val){\r\n  this._firstInBlock = val;\r\n  val?this.row.classList.add('firstInBlock'):this.row.classList.remove('firstInBlock');\r\n}*/\n;\n\nexports.default = AggregatedTableRowMeta;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItYWdncmVnYXRlZC10YWJsZS9zcmMvYWdncmVnYXRlZC10YWJsZS1yb3ctbWV0YS5qcz80NmViIl0sIm5hbWVzIjpbIkFnZ3JlZ2F0ZWRUYWJsZVJvd01ldGEiLCJyb3ciLCJpZCIsIm5hbWVDZWxsIiwibmFtZSIsImJsb2NrIiwidGV4dENvbnRlbnQiLCJ0cmltIiwiZmlyc3RJbkJsb2NrIiwicm93SW5kZXgiLCJjZWxsIiwicGFyZW50Tm9kZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7O0FBR0E7Ozs7Ozs7O0lBUU1BLHNCO0FBQ0o7Ozs7Ozs7O0FBUUEsa0NBQTBEO0FBQUEsaUZBQUgsRUFBRztBQUFBLE1BQTdDQyxHQUE2QyxRQUE3Q0EsR0FBNkM7QUFBQSxxQkFBeENDLEVBQXdDO0FBQUEsTUFBeENBLEVBQXdDLDJCQUFyQyxJQUFxQztBQUFBLE1BQS9CQyxRQUErQixRQUEvQkEsUUFBK0I7QUFBQSxNQUFyQkMsSUFBcUIsUUFBckJBLElBQXFCO0FBQUEsd0JBQWZDLEtBQWU7QUFBQSxNQUFmQSxLQUFlLDhCQUFULElBQVM7O0FBQUE7O0FBQ3hEO0FBQ0EsT0FBS0osR0FBTCxHQUFXQSxHQUFYO0FBQ0EsT0FBS0MsRUFBTCxHQUFVQSxFQUFWO0FBQ0EsT0FBS0MsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxPQUFLQyxJQUFMLEdBQVlBLFFBQVFELFNBQVNHLFdBQVQsQ0FBcUJDLElBQXJCLEVBQXBCO0FBQ0EsT0FBS0YsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsT0FBS0csWUFBTCxHQUFvQkgsU0FBTyxJQUFQLElBQWUsS0FBS0osR0FBTCxDQUFTUSxRQUFULEtBQXNCLEtBQUtKLEtBQUwsQ0FBV0ssSUFBWCxDQUFnQkMsVUFBaEIsQ0FBMkJGLFFBQXBGO0FBQ0Q7QUFDRDs7Ozs7Ozs7O2tCQVFhVCxzQiIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENyZWF0ZWQgYnkgSXZhblAgb24gMTcuMDguMjAxNi5cclxuICovXHJcbi8qKlxyXG4gKiBAcHJvcGVydHkge0hUTUxUYWJsZVJvd0VsZW1lbnR9IHJvdyAtIHJlZmVyZW5jZSB0byB0aGUgYDx0cj5gIGVsZW1lbnRcclxuICogQHByb3BlcnR5IHs/U3RyaW5nfSBpZCAtIGludGVybmFsIFJlcG9ydGFsIGlkIGZvciB0aGUgcm93aGVhZGVyIGluIHRoZSByb3dcclxuICogQHByb3BlcnR5IHshSFRNTFRhYmxlQ2VsbEVsZW1lbnR9IG5hbWVDZWxsIC0gcmVmZXJlbmNlIHRvIHRoZSBgPHRkPmAgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSByb3doZWFkZXIgbGFiZWwvbmFtZVxyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW25hbWU9bmFtZUNlbGwudGV4dENvbnRlbnRdIC0gbGFiZWwgb2YgdGhlIHJvd2hlYWRlci5cclxuICogQHByb3BlcnR5IHs/T2JqZWN0fSBbYmxvY2s9bnVsbF0gLSB0aGUgYmxvY2sgdGhlIHJvdyBiZWxvbmdzIHRvXHJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZmlyc3RJbkJsb2NrIC0gdGhpcyBgcm93YCBpcyBmaXJzdCBpbiB0aGUgYGJsb2NrYCwgd2hpY2ggbWVhbnMgaXQgY29udGFpbnMgdGhlIGZpcnN0IGNlbGwgYXMgYSBibG9jayBjZWxsXHJcbiAqICovXHJcbmNsYXNzIEFnZ3JlZ2F0ZWRUYWJsZVJvd01ldGEge1xyXG4gIC8qKlxyXG4gICAqIEJ1aWxkcyBhIHByb3RvdHlwZSBmb3IgZWFjaCByb3cgb2YgYW4gQWdncmVnYXRlZCBUYWJsZVxyXG4gICAqIEBwYXJhbSB7SFRNTFRhYmxlUm93RWxlbWVudH0gcm93IC0gcmVmZXJlbmNlIHRvIHRoZSBgPHRyPmAgZWxlbWVudFxyXG4gICAqIEBwYXJhbSB7P1N0cmluZ30gaWQgLSBpbnRlcm5hbCBSZXBvcnRhbCBpZCBmb3IgdGhlIHJvd2hlYWRlciBpbiB0aGUgcm93XHJcbiAgICogQHBhcmFtIHshSFRNTFRhYmxlQ2VsbEVsZW1lbnR9IG5hbWVDZWxsIC0gcmVmZXJlbmNlIHRvIHRoZSBgPHRkPmAgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSByb3doZWFkZXIgbGFiZWwvbmFtZVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nPX0gW25hbWU9bmFtZUNlbGwudGV4dENvbnRlbnRdIC0gbGFiZWwgb2YgdGhlIHJvd2hlYWRlci5cclxuICAgKiBAcGFyYW0gez9PYmplY3R9IFtibG9jaz1udWxsXSAtIHRoZSBibG9jayB0aGUgcm93IGJlbG9uZ3MgdG9cclxuICAgKiAqL1xyXG4gIGNvbnN0cnVjdG9yKHtyb3csIGlkPW51bGwsIG5hbWVDZWxsLCBuYW1lLCBibG9jaz1udWxsfT17fSl7XHJcbiAgICAvKioqIEBwcm9wZXJ0eSB7SFRNTFRhYmxlUm93RWxlbWVudH0gcm93IC0gcmVmZXJlbmNlIHRvIHRoZSBgPHRyPmAgZWxlbWVudCovXHJcbiAgICB0aGlzLnJvdyA9IHJvdztcclxuICAgIHRoaXMuaWQgPSBpZDtcclxuICAgIHRoaXMubmFtZUNlbGwgPSBuYW1lQ2VsbDtcclxuICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgbmFtZUNlbGwudGV4dENvbnRlbnQudHJpbSgpO1xyXG4gICAgdGhpcy5ibG9jayA9IGJsb2NrO1xyXG4gICAgdGhpcy5maXJzdEluQmxvY2sgPSBibG9jayE9bnVsbCAmJiB0aGlzLnJvdy5yb3dJbmRleCA9PT0gdGhpcy5ibG9jay5jZWxsLnBhcmVudE5vZGUucm93SW5kZXg7XHJcbiAgfVxyXG4gIC8qZ2V0IGZpcnN0SW5CbG9jaygpe1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZpcnN0SW5CbG9jaztcclxuICB9XHJcbiAgc2V0IGZpcnN0SW5CbG9jayh2YWwpe1xyXG4gICAgdGhpcy5fZmlyc3RJbkJsb2NrID0gdmFsO1xyXG4gICAgdmFsP3RoaXMucm93LmNsYXNzTGlzdC5hZGQoJ2ZpcnN0SW5CbG9jaycpOnRoaXMucm93LmNsYXNzTGlzdC5yZW1vdmUoJ2ZpcnN0SW5CbG9jaycpO1xyXG4gIH0qL1xyXG59XHJcbmV4cG9ydCBkZWZhdWx0IEFnZ3JlZ2F0ZWRUYWJsZVJvd01ldGFcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yLWFnZ3JlZ2F0ZWQtdGFibGUvc3JjL2FnZ3JlZ2F0ZWQtdGFibGUtcm93LW1ldGEuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _tableData = __webpack_require__(2);\n\nvar _tableData2 = _interopRequireDefault(_tableData);\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nvar _rTableColumns = __webpack_require__(10);\n\nvar _rTableColumns2 = _interopRequireDefault(_rTableColumns);\n\nvar _sortTable = __webpack_require__(8);\n\nvar _sortTable2 = _interopRequireDefault(_sortTable);\n\nvar _tableFloatingHeader = __webpack_require__(12);\n\nvar _tableFloatingHeader2 = _interopRequireDefault(_tableFloatingHeader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by IvanP on 27.09.2016.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\nvar styles = __webpack_require__(16);\nvar aggregatedTableCSS = __webpack_require__(15);\n\n/**\r\n * A base class for aggregated tables. Multidimensional property of data is automatically calculated, thus removed from params.\r\n * @extends TableData\r\n * */\n\nvar AggregatedTable = function (_TableData) {\n  _inherits(AggregatedTable, _TableData);\n\n  /*\r\n   * @param {Object} options - options to configure the way data is stripped off the table\r\n   * @param {HTMLTableElement} options.source - source table that will be an input for data stripping\r\n   * @param {HTMLTableElement} [options.refSource] - a reference to a floating header, if any\r\n   * @param {Number} [options.rowheaderColumnIndex=0] - 0-based index of the column that we need to check against to see if it's a multidimentional table\r\n   * @param {Number|Object=} [options.defaultHeaderRow=-1] - index of the row in `thead` (incremented from 0) that will have sorting enabled for columns. If `-1` then last row.\r\n   * @param {String=} options.dataStripDirection='row' - direction in which data stripping will occur: `row` strips across rows and presents an array where each array item is an array of cell values. `column` strips values verticaly in a column, the resulting array will contain arrays (per column) with values resembling normalized data for cells in the column\r\n   * @param {Boolean=} [options.excludeBlock=true] - if table contains block cells that rowspan across several rows, we might need to exclude those from actual data\r\n   * @param {Array|Number} [options.excludeColumns] - if table contains columns that are not to be in data, then pass a single index or an array of cell indices (0-based). You need to count columns not by headers but by the cells in rows.\r\n   * @param {Array|Number} [options.excludeRows] - if table contains rows that are not to be in data, then pass a single index or an array of row indices (0-based). You need to count only rows that contain data, not the table-header rows.\r\n   * @param {SortTable} options.sorting - sorting options, see {@link SortTable}. If you want to leave all options default but enable sorting, pass an empty object(`.., sorting:{}`), or sorting won't be applied.\r\n   * @param {SortTable} options.floatingHeader - floating header, see {@link SortTable}. If you want to leave all options default but enable sorting, pass an empty object(`.., sorting:{}`), or sorting won't be applied.\r\n   * */\n  function AggregatedTable(options) {\n    _classCallCheck(this, AggregatedTable);\n\n    var source = options.source,\n        rowheaderColumnIndex = options.rowheaderColumnIndex,\n        defaultHeaderRow = options.defaultHeaderRow,\n        dataStripDirection = options.dataStripDirection,\n        excludeBlock = options.excludeBlock,\n        excludeColumns = options.excludeColumns,\n        excludeRows = options.excludeRows,\n        sorting = options.sorting,\n        floatingHeader = options.floatingHeader;\n\n    /**\r\n     *  The source table\r\n     *  @type {HTMLTableElement}\r\n     *  @memberOf AggregatedTable\r\n     *  */\n    var _this = _possibleConstructorReturn(this, (AggregatedTable.__proto__ || Object.getPrototypeOf(AggregatedTable)).call(this));\n\n    _this.source = source;\n    var refSource = void 0;\n    if (floatingHeader && (typeof floatingHeader === \"undefined\" ? \"undefined\" : _typeof(floatingHeader)) == 'object') {\n      _this.floatingHeader = new _tableFloatingHeader2.default(source);\n      /**\r\n       *  The floating header\r\n       *  @type {HTMLTableElement}\r\n       *  @memberOf AggregatedTable\r\n       *  */\n      _this.refSource = refSource = _this.floatingHeader.header;\n    }\n\n    /**\r\n     *  Whether data is monodimensional or multidimensional\r\n     *  @type {Boolean}\r\n     *  @memberOf AggregatedTable\r\n     *  */\n\n    _this.multidimensional = _this.constructor.detectMultidimensional(source);\n\n    /**\r\n     *  data Array\r\n     *  @type {Array.<{cell:HTMLTableCellElement, data:?String|?Number, columnIndex:Number}>}\r\n     *  @memberOf AggregatedTable\r\n     *  */\n    _this.data = _this.constructor.getData({ source: source, refSource: refSource, defaultHeaderRow: defaultHeaderRow, excludeBlock: excludeBlock, excludeColumns: excludeColumns, excludeRows: excludeRows, direction: dataStripDirection, multidimensional: _this.multidimensional });\n\n    if (sorting && (typeof sorting === \"undefined\" ? \"undefined\" : _typeof(sorting)) == 'object') {\n      (function () {\n        var reorderFunction = function reorderFunction(e) {\n          return _this.constructor.reorderRows(_this.data, _this.source, _this.multidimensional);\n        };\n        [source, refSource].forEach(function (target) {\n          if (target) {\n            target.addEventListener('reportal-table-sort', reorderFunction);\n          }\n        });\n\n        sorting.source = source;\n        sorting.refSource = refSource;\n        sorting.defaultHeaderRow = defaultHeaderRow;\n        sorting.data = _this.data;\n        sorting.multidimensional = _this.multidimensional;\n\n        /**\r\n         *  sorting object. See {@link SortTable}\r\n         *  @type {SortTable}\r\n         *  @memberOf AggregatedTable\r\n         *  */\n        _this.sorting = new _sortTable2.default(sorting);\n\n        // add listener to do reordering on sorting\n      })();\n    }\n\n    /**\r\n     * table columns array\r\n     * @type {Array.<{index:Number, title:String, colSpan:Number, cell: HTMLTableCellElement, ?refCell:HTMLTableCellElement}>}\r\n     * @memberOf AggregatedTable\r\n     * */\n    _this.columns = _this.sorting && _this.sorting.columns ? _this.sorting.columns : new _rTableColumns2.default({ source: source, refSource: refSource, defaultHeaderRow: defaultHeaderRow });\n    return _this;\n  }\n\n  /**\r\n   * Extracts data from a given cell. Override in an inherited class if you need to add any metadata to it.\r\n   * @param {HTMLTableCellElement} cell - cell element to have data stripped off it\r\n   * @param {HTMLTableCellElement} rowIndex - index of the row it's in\r\n   * @param {HTMLTableCellElement} columnIndex - index of the column it's in\r\n   * @returns {{cell:HTMLTableCellElement, ?data:String|Number, columnIndex:Number}} Returns an object `{cell:HTMLTableCellElement, data:?String|?Number, columnIndex:Number}` (if data is absent in the cell or its text content boils down to an empty string - i.e. there are no characters in the cell, only HTML tags) it returns null in `data`\r\n   * @override\r\n   * */\n\n\n  _createClass(AggregatedTable, null, [{\n    key: \"prepareDataCell\",\n    value: function prepareDataCell(cell, rowIndex, columnIndex) {\n      return {\n        cell: cell,\n        data: _rReportalBase2.default.isNumber(cell.textContent.trim()),\n        columnIndex: columnIndex,\n        rowIndex: rowIndex\n      };\n    }\n\n    /**\r\n     * This function takes care of repositioning rows in the table to match the `data` array in the way it was sorted and if the data is separated into blocks, then move the block piece to the first row in each data block.\r\n     * @param {Array} data - full sorted dataset. Instance of {@link TableData#getData}\r\n     * @param {HTMLTableElement} source - source table\r\n     * @param {Boolean} multidimensional\r\n     * */\n\n  }, {\n    key: \"reorderRows\",\n    value: function reorderRows(data, source, multidimensional) {\n      var fragment = document.createDocumentFragment();\n      AggregatedTable.dimensionalDataIterator(data, multidimensional, function (dataDimension) {\n        if (multidimensional) {\n          AggregatedTable.repositionBlockCell(dataDimension);\n        } // if multidimensional reposition aggregating block cell to the topmost row in sorted array\n        dataDimension.forEach(function (item) {\n          fragment.appendChild(item[0].cell.parentNode);\n        }); // add row to fragment in the array order, this doesn't account for column stripped data yet\n      });\n      source.querySelector('tbody').appendChild(fragment);\n    }\n\n    /*\r\n     * Repositions the rowspanning block cell from the initial row to the new sorted row\r\n     * @param {Array} items - dimension of data\r\n     * */\n\n  }, {\n    key: \"repositionBlockCell\",\n    value: function repositionBlockCell(items) {\n      var blockRowItem = items.filter(function (item) {\n        return item[0].cell.parentNode.classList.contains('firstInBlock');\n      })[0];\n      var blockRow = blockRowItem[0].cell.parentNode;\n      if (items.indexOf(blockRowItem) != 0) {\n        // if block row isn't first in dimension\n        var newFirstRow = items[0][0].cell.parentNode;\n        newFirstRow.insertBefore(blockRow.querySelector('.blockCell'), newFirstRow.firstElementChild); // move block cell\n        newFirstRow.classList.add('firstInBlock');\n        blockRow.classList.remove('firstInBlock');\n      }\n    }\n\n    /**\r\n     * allows to perform action on data based on its multidimensionality\r\n     * @param {Array} data - full dataset. Instance of {@link TableData#getData}\r\n     * @param {Boolean} multidimensional\r\n     * @param {!Function} callback - a function to be executed on a dimension of data. Callback is called with two attributes: `dimension` - the current iteration of data and `index` (optional) if it's multidimensional\r\n     * */\n\n  }, {\n    key: \"dimensionalDataIterator\",\n    value: function dimensionalDataIterator(data, multidimensional, callback) {\n      if (!callback || typeof callback != 'function') {\n        throw new TypeError('`callback` must be passed and be a function');\n      }\n      if (!multidimensional) {\n        return callback(data);\n      } else {\n        // if array has nested array blocks\n        data.forEach(function (dimension, index) {\n          callback(dimension, index);\n        });\n      }\n    }\n  }]);\n\n  return AggregatedTable;\n}(_tableData2.default);\n\nexports.default = AggregatedTable;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItYWdncmVnYXRlZC10YWJsZS9zcmMvYWdncmVnYXRlZC10YWJsZS5qcz8zMDBiIl0sIm5hbWVzIjpbInN0eWxlcyIsInJlcXVpcmUiLCJhZ2dyZWdhdGVkVGFibGVDU1MiLCJBZ2dyZWdhdGVkVGFibGUiLCJvcHRpb25zIiwic291cmNlIiwicm93aGVhZGVyQ29sdW1uSW5kZXgiLCJkZWZhdWx0SGVhZGVyUm93IiwiZGF0YVN0cmlwRGlyZWN0aW9uIiwiZXhjbHVkZUJsb2NrIiwiZXhjbHVkZUNvbHVtbnMiLCJleGNsdWRlUm93cyIsInNvcnRpbmciLCJmbG9hdGluZ0hlYWRlciIsInJlZlNvdXJjZSIsImhlYWRlciIsIm11bHRpZGltZW5zaW9uYWwiLCJjb25zdHJ1Y3RvciIsImRldGVjdE11bHRpZGltZW5zaW9uYWwiLCJkYXRhIiwiZ2V0RGF0YSIsImRpcmVjdGlvbiIsInJlb3JkZXJGdW5jdGlvbiIsInJlb3JkZXJSb3dzIiwiZm9yRWFjaCIsInRhcmdldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJjb2x1bW5zIiwiY2VsbCIsInJvd0luZGV4IiwiY29sdW1uSW5kZXgiLCJpc051bWJlciIsInRleHRDb250ZW50IiwidHJpbSIsImZyYWdtZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiZGltZW5zaW9uYWxEYXRhSXRlcmF0b3IiLCJkYXRhRGltZW5zaW9uIiwicmVwb3NpdGlvbkJsb2NrQ2VsbCIsImFwcGVuZENoaWxkIiwiaXRlbSIsInBhcmVudE5vZGUiLCJxdWVyeVNlbGVjdG9yIiwiaXRlbXMiLCJibG9ja1Jvd0l0ZW0iLCJmaWx0ZXIiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImJsb2NrUm93IiwiaW5kZXhPZiIsIm5ld0ZpcnN0Um93IiwiaW5zZXJ0QmVmb3JlIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJhZGQiLCJyZW1vdmUiLCJjYWxsYmFjayIsIlR5cGVFcnJvciIsImRpbWVuc2lvbiIs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LE1BQU1NLE9BQU4sQ0FBY0wsWUFBZCxLQUE2QixDQUFoQyxFQUFrQztBQUFDO0FBQ2pDLFlBQUlNLGNBQWNQLE1BQU0sQ0FBTixFQUFTLENBQVQsRUFBWWhCLElBQVosQ0FBaUJjLFVBQW5DO0FBQ0FTLG9CQUFZQyxZQUFaLENBQXlCSCxTQUFTTixhQUFULENBQXVCLFlBQXZCLENBQXpCLEVBQThEUSxZQUFZRSxpQkFBMUUsRUFGZ0MsQ0FFNkQ7QUFDN0ZGLG9CQUFZSixTQUFaLENBQXNCTyxHQUF0QixDQUEwQixjQUExQjtBQUNBTCxpQkFBU0YsU0FBVCxDQUFtQlEsTUFBbkIsQ0FBMEIsY0FBMUI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7NENBTStCcEMsSSxFQUFLSCxnQixFQUFpQndDLFEsRUFBUztBQUM1RCxVQUFHLENBQUNBLFFBQUQsSUFBYSxPQUFPQSxRQUFQLElBQW1CLFVBQW5DLEVBQThDO0FBQUMsY0FBTSxJQUFJQyxTQUFKLENBQWMsNkNBQWQsQ0FBTjtBQUFtRTtBQUNsSCxVQUFHLENBQUN6QyxnQkFBSixFQUFxQjtBQUNuQixlQUFPd0MsU0FBU3JDLElBQVQsQ0FBUDtBQUNELE9BRkQsTUFFTztBQUFFO0FBQ1BBLGFBQUtLLE9BQUwsQ0FBYSxVQUFDa0MsU0FBRCxFQUFXQyxLQUFYLEVBQW1CO0FBQzlCSCxtQkFBU0UsU0FBVCxFQUFtQkMsS0FBbkI7QUFDRCxTQUZEO0FBR0Q7QUFDRjs7Ozs7O2tCQUtZeEQsZSIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENyZWF0ZWQgYnkgSXZhblAgb24gMjcuMDkuMjAxNi5cclxuICovXHJcblxyXG5pbXBvcnQgVGFibGVEYXRhIGZyb20gJy4vdGFibGUtZGF0YSc7XHJcbmltcG9ydCBSZXBvcnRhbEJhc2UgZnJvbSBcInItcmVwb3J0YWwtYmFzZVwiO1xyXG5pbXBvcnQgVGFibGVDb2x1bW5zIGZyb20gXCJyLXRhYmxlLWNvbHVtbnNcIjtcclxuaW1wb3J0IFNvcnRUYWJsZSBmcm9tIFwici1zb3J0LXRhYmxlL3NyYy9zb3J0LXRhYmxlXCI7XHJcbmltcG9ydCBUYWJsZUZsb2F0aW5nSGVhZGVyIGZyb20gXCJyLXRhYmxlLWZsb2F0aW5nLWhlYWRlci9zcmMvdGFibGUtZmxvYXRpbmctaGVhZGVyXCI7XHJcblxyXG5sZXQgc3R5bGVzID0gcmVxdWlyZSgnci1zb3J0LXRhYmxlL3NyYy9zb3J0LXRhYmxlLXN0eWxlcy5jc3MnKTtcclxubGV0IGFnZ3JlZ2F0ZWRUYWJsZUNTUyA9IHJlcXVpcmUoJy4vYWdncmVnYXRlZC10YWJsZS5jc3MnKTtcclxuXHJcbi8qKlxyXG4gKiBBIGJhc2UgY2xhc3MgZm9yIGFnZ3JlZ2F0ZWQgdGFibGVzLiBNdWx0aWRpbWVuc2lvbmFsIHByb3BlcnR5IG9mIGRhdGEgaXMgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkLCB0aHVzIHJlbW92ZWQgZnJvbSBwYXJhbXMuXHJcbiAqIEBleHRlbmRzIFRhYmxlRGF0YVxyXG4gKiAqL1xyXG5jbGFzcyBBZ2dyZWdhdGVkVGFibGUgZXh0ZW5kcyBUYWJsZURhdGEge1xyXG4gIC8qXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgd2F5IGRhdGEgaXMgc3RyaXBwZWQgb2ZmIHRoZSB0YWJsZVxyXG4gICAqIEBwYXJhbSB7SFRNTFRhYmxlRWxlbWVudH0gb3B0aW9ucy5zb3VyY2UgLSBzb3VyY2UgdGFibGUgdGhhdCB3aWxsIGJlIGFuIGlucHV0IGZvciBkYXRhIHN0cmlwcGluZ1xyXG4gICAqIEBwYXJhbSB7SFRNTFRhYmxlRWxlbWVudH0gW29wdGlvbnMucmVmU291cmNlXSAtIGEgcmVmZXJlbmNlIHRvIGEgZmxvYXRpbmcgaGVhZGVyLCBpZiBhbnlcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucm93aGVhZGVyQ29sdW1uSW5kZXg9MF0gLSAwLWJhc2VkIGluZGV4IG9mIHRoZSBjb2x1bW4gdGhhdCB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QgdG8gc2VlIGlmIGl0J3MgYSBtdWx0aWRpbWVudGlvbmFsIHRhYmxlXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0PX0gW29wdGlvbnMuZGVmYXVsdEhlYWRlclJvdz0tMV0gLSBpbmRleCBvZiB0aGUgcm93IGluIGB0aGVhZGAgKGluY3JlbWVudGVkIGZyb20gMCkgdGhhdCB3aWxsIGhhdmUgc29ydGluZyBlbmFibGVkIGZvciBjb2x1bW5zLiBJZiBgLTFgIHRoZW4gbGFzdCByb3cuXHJcbiAgICogQHBhcmFtIHtTdHJpbmc9fSBvcHRpb25zLmRhdGFTdHJpcERpcmVjdGlvbj0ncm93JyAtIGRpcmVjdGlvbiBpbiB3aGljaCBkYXRhIHN0cmlwcGluZyB3aWxsIG9jY3VyOiBgcm93YCBzdHJpcHMgYWNyb3NzIHJvd3MgYW5kIHByZXNlbnRzIGFuIGFycmF5IHdoZXJlIGVhY2ggYXJyYXkgaXRlbSBpcyBhbiBhcnJheSBvZiBjZWxsIHZhbHVlcy4gYGNvbHVtbmAgc3RyaXBzIHZhbHVlcyB2ZXJ0aWNhbHkgaW4gYSBjb2x1bW4sIHRoZSByZXN1bHRpbmcgYXJyYXkgd2lsbCBjb250YWluIGFycmF5cyAocGVyIGNvbHVtbikgd2l0aCB2YWx1ZXMgcmVzZW1ibGluZyBub3JtYWxpemVkIGRhdGEgZm9yIGNlbGxzIGluIHRoZSBjb2x1bW5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBbb3B0aW9ucy5leGNsdWRlQmxvY2s9dHJ1ZV0gLSBpZiB0YWJsZSBjb250YWlucyBibG9jayBjZWxscyB0aGF0IHJvd3NwYW4gYWNyb3NzIHNldmVyYWwgcm93cywgd2UgbWlnaHQgbmVlZCB0byBleGNsdWRlIHRob3NlIGZyb20gYWN0dWFsIGRhdGFcclxuICAgKiBAcGFyYW0ge0FycmF5fE51bWJlcn0gW29wdGlvbnMuZXhjbHVkZUNvbHVtbnNdIC0gaWYgdGFibGUgY29udGFpbnMgY29sdW1ucyB0aGF0IGFyZSBub3QgdG8gYmUgaW4gZGF0YSwgdGhlbiBwYXNzIGEgc2luZ2xlIGluZGV4IG9yIGFuIGFycmF5IG9mIGNlbGwgaW5kaWNlcyAoMC1iYXNlZCkuIFlvdSBuZWVkIHRvIGNvdW50IGNvbHVtbnMgbm90IGJ5IGhlYWRlcnMgYnV0IGJ5IHRoZSBjZWxscyBpbiByb3dzLlxyXG4gICAqIEBwYXJhbSB7QXJyYXl8TnVtYmVyfSBbb3B0aW9ucy5leGNsdWRlUm93c10gLSBpZiB0YWJsZSBjb250YWlucyByb3dzIHRoYXQgYXJlIG5vdCB0byBiZSBpbiBkYXRhLCB0aGVuIHBhc3MgYSBzaW5nbGUgaW5kZXggb3IgYW4gYXJyYXkgb2Ygcm93IGluZGljZXMgKDAtYmFzZWQpLiBZb3UgbmVlZCB0byBjb3VudCBvbmx5IHJvd3MgdGhhdCBjb250YWluIGRhdGEsIG5vdCB0aGUgdGFibGUtaGVhZGVyIHJvd3MuXHJcbiAgICogQHBhcmFtIHtTb3J0VGFibGV9IG9wdGlvbnMuc29ydGluZyAtIHNvcnRpbmcgb3B0aW9ucywgc2VlIHtAbGluayBTb3J0VGFibGV9LiBJZiB5b3Ugd2FudCB0byBsZWF2ZSBhbGwgb3B0aW9ucyBkZWZhdWx0IGJ1dCBlbmFibGUgc29ydGluZywgcGFzcyBhbiBlbXB0eSBvYmplY3QoYC4uLCBzb3J0aW5nOnt9YCksIG9yIHNvcnRpbmcgd29uJ3QgYmUgYXBwbGllZC5cclxuICAgKiBAcGFyYW0ge1NvcnRUYWJsZX0gb3B0aW9ucy5mbG9hdGluZ0hlYWRlciAtIGZsb2F0aW5nIGhlYWRlciwgc2VlIHtAbGluayBTb3J0VGFibGV9LiBJZiB5b3Ugd2FudCB0byBsZWF2ZSBhbGwgb3B0aW9ucyBkZWZhdWx0IGJ1dCBlbmFibGUgc29ydGluZywgcGFzcyBhbiBlbXB0eSBvYmplY3QoYC4uLCBzb3J0aW5nOnt9YCksIG9yIHNvcnRpbmcgd29uJ3QgYmUgYXBwbGllZC5cclxuICAgKiAqL1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpe1xyXG4gICAgbGV0IHtcclxuICAgICAgc291cmNlLFxyXG4gICAgICByb3doZWFkZXJDb2x1bW5JbmRleCxkZWZhdWx0SGVhZGVyUm93LGRhdGFTdHJpcERpcmVjdGlvbixleGNsdWRlQmxvY2ssZXhjbHVkZUNvbHVtbnMsZXhjbHVkZVJvd3MsXHJcbiAgICAgIHNvcnRpbmcsXHJcbiAgICAgIGZsb2F0aW5nSGVhZGVyXHJcbiAgICB9ID0gb3B0aW9ucztcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHNvdXJjZSB0YWJsZVxyXG4gICAgICogIEB0eXBlIHtIVE1MVGFibGVFbGVtZW50fVxyXG4gICAgICogIEBtZW1iZXJPZiBBZ2dyZWdhdGVkVGFibGVcclxuICAgICAqICAqL1xyXG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICBsZXQgcmVmU291cmNlO1xyXG4gICAgaWYoZmxvYXRpbmdIZWFkZXIgJiYgdHlwZW9mIGZsb2F0aW5nSGVhZGVyPT0nb2JqZWN0Jyl7XHJcbiAgICAgIHRoaXMuZmxvYXRpbmdIZWFkZXIgPSBuZXcgVGFibGVGbG9hdGluZ0hlYWRlcihzb3VyY2UpO1xyXG4gICAgICAvKipcclxuICAgICAgICogIFRoZSBmbG9hdGluZyBoZWFkZXJcclxuICAgICAgICogIEB0eXBlIHtIVE1MVGFibGVFbGVtZW50fVxyXG4gICAgICAgKiAgQG1lbWJlck9mIEFnZ3JlZ2F0ZWRUYWJsZVxyXG4gICAgICAgKiAgKi9cclxuICAgICAgdGhpcy5yZWZTb3VyY2UgPSByZWZTb3VyY2UgPSB0aGlzLmZsb2F0aW5nSGVhZGVyLmhlYWRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqICBXaGV0aGVyIGRhdGEgaXMgbW9ub2RpbWVuc2lvbmFsIG9yIG11bHRpZGltZW5zaW9uYWxcclxuICAgICAqICBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqICBAbWVtYmVyT2YgQWdncmVnYXRlZFRhYmxlXHJcbiAgICAgKiAgKi9cclxuXHJcbiAgICB0aGlzLm11bHRpZGltZW5zaW9uYWwgPSB0aGlzLmNvbnN0cnVjdG9yLmRldGVjdE11bHRpZGltZW5zaW9uYWwoc291cmNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqICBkYXRhIEFycmF5XHJcbiAgICAgKiAgQHR5cGUge0FycmF5Ljx7Y2VsbDpIVE1MVGFibGVDZWxsRWxlbWVudCwgZGF0YTo/U3RyaW5nfD9OdW1iZXIsIGNvbHVtbkluZGV4Ok51bWJlcn0+fVxyXG4gICAgICogIEBtZW1iZXJPZiBBZ2dyZWdhdGVkVGFibGVcclxuICAgICAqICAqL1xyXG4gICAgdGhpcy5kYXRhID0gdGhpcy5jb25zdHJ1Y3Rvci5nZXREYXRhKHtzb3VyY2UscmVmU291cmNlLGRlZmF1bHRIZWFkZXJSb3csZXhjbHVkZUJsb2NrLGV4Y2x1ZGVDb2x1bW5zLGV4Y2x1ZGVSb3dzLGRpcmVjdGlvbjpkYXRhU3RyaXBEaXJlY3Rpb24sbXVsdGlkaW1lbnNpb25hbDogdGhpcy5tdWx0aWRpbWVuc2lvbmFsfSk7XHJcblxyXG5cclxuICAgIGlmKHNvcnRpbmcgJiYgdHlwZW9mIHNvcnRpbmcgPT0gJ29iamVjdCcpe1xyXG4gICAgICBsZXQgcmVvcmRlckZ1bmN0aW9uID0gZT0+e1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnJlb3JkZXJSb3dzKHRoaXMuZGF0YSx0aGlzLnNvdXJjZSx0aGlzLm11bHRpZGltZW5zaW9uYWwpXHJcbiAgICAgIH07XHJcbiAgICAgIFtzb3VyY2UscmVmU291cmNlXS5mb3JFYWNoKHRhcmdldD0+e1xyXG4gICAgICAgIGlmKHRhcmdldCl7XHJcbiAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigncmVwb3J0YWwtdGFibGUtc29ydCcsIHJlb3JkZXJGdW5jdGlvbilcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgc29ydGluZy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgIHNvcnRpbmcucmVmU291cmNlID0gcmVmU291cmNlO1xyXG4gICAgICBzb3J0aW5nLmRlZmF1bHRIZWFkZXJSb3cgPSBkZWZhdWx0SGVhZGVyUm93O1xyXG4gICAgICBzb3J0aW5nLmRhdGE9dGhpcy5kYXRhO1xyXG4gICAgICBzb3J0aW5nLm11bHRpZGltZW5zaW9uYWwgPSB0aGlzLm11bHRpZGltZW5zaW9uYWw7XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogIHNvcnRpbmcgb2JqZWN0LiBTZWUge0BsaW5rIFNvcnRUYWJsZX1cclxuICAgICAgICogIEB0eXBlIHtTb3J0VGFibGV9XHJcbiAgICAgICAqICBAbWVtYmVyT2YgQWdncmVnYXRlZFRhYmxlXHJcbiAgICAgICAqICAqL1xyXG4gICAgICB0aGlzLnNvcnRpbmcgPSBuZXcgU29ydFRhYmxlKHNvcnRpbmcpO1xyXG5cclxuICAgICAgLy8gYWRkIGxpc3RlbmVyIHRvIGRvIHJlb3JkZXJpbmcgb24gc29ydGluZ1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGFibGUgY29sdW1ucyBhcnJheVxyXG4gICAgICogQHR5cGUge0FycmF5Ljx7aW5kZXg6TnVtYmVyLCB0aXRsZTpTdHJpbmcsIGNvbFNwYW46TnVtYmVyLCBjZWxsOiBIVE1MVGFibGVDZWxsRWxlbWVudCwgP3JlZkNlbGw6SFRNTFRhYmxlQ2VsbEVsZW1lbnR9Pn1cclxuICAgICAqIEBtZW1iZXJPZiBBZ2dyZWdhdGVkVGFibGVcclxuICAgICAqICovXHJcbiAgICB0aGlzLmNvbHVtbnMgPSB0aGlzLnNvcnRpbmcgJiYgdGhpcy5zb3J0aW5nLmNvbHVtbnM/IHRoaXMuc29ydGluZy5jb2x1bW5zIDogbmV3IFRhYmxlQ29sdW1ucyh7c291cmNlLHJlZlNvdXJjZSxkZWZhdWx0SGVhZGVyUm93fSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogRXh0cmFjdHMgZGF0YSBmcm9tIGEgZ2l2ZW4gY2VsbC4gT3ZlcnJpZGUgaW4gYW4gaW5oZXJpdGVkIGNsYXNzIGlmIHlvdSBuZWVkIHRvIGFkZCBhbnkgbWV0YWRhdGEgdG8gaXQuXHJcbiAgICogQHBhcmFtIHtIVE1MVGFibGVDZWxsRWxlbWVudH0gY2VsbCAtIGNlbGwgZWxlbWVudCB0byBoYXZlIGRhdGEgc3RyaXBwZWQgb2ZmIGl0XHJcbiAgICogQHBhcmFtIHtIVE1MVGFibGVDZWxsRWxlbWVudH0gcm93SW5kZXggLSBpbmRleCBvZiB0aGUgcm93IGl0J3MgaW5cclxuICAgKiBAcGFyYW0ge0hUTUxUYWJsZUNlbGxFbGVtZW50fSBjb2x1bW5JbmRleCAtIGluZGV4IG9mIHRoZSBjb2x1bW4gaXQncyBpblxyXG4gICAqIEByZXR1cm5zIHt7Y2VsbDpIVE1MVGFibGVDZWxsRWxlbWVudCwgP2RhdGE6U3RyaW5nfE51bWJlciwgY29sdW1uSW5kZXg6TnVtYmVyfX0gUmV0dXJucyBhbiBvYmplY3QgYHtjZWxsOkhUTUxUYWJsZUNlbGxFbGVtZW50LCBkYXRhOj9TdHJpbmd8P051bWJlciwgY29sdW1uSW5kZXg6TnVtYmVyfWAgKGlmIGRhdGEgaXMgYWJzZW50IGluIHRoZSBjZWxsIG9yIGl0cyB0ZXh0IGNvbnRlbnQgYm9pbHMgZG93biB0byBhbiBlbXB0eSBzdHJpbmcgLSBpLmUuIHRoZXJlIGFyZSBubyBjaGFyYWN0ZXJzIGluIHRoZSBjZWxsLCBvbmx5IEhUTUwgdGFncykgaXQgcmV0dXJucyBudWxsIGluIGBkYXRhYFxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqICovXHJcbiAgc3RhdGljIHByZXBhcmVEYXRhQ2VsbChjZWxsLCByb3dJbmRleCwgY29sdW1uSW5kZXgpe1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2VsbCxcclxuICAgICAgZGF0YTogUmVwb3J0YWxCYXNlLmlzTnVtYmVyKGNlbGwudGV4dENvbnRlbnQudHJpbSgpKSxcclxuICAgICAgY29sdW1uSW5kZXgsXHJcbiAgICAgIHJvd0luZGV4XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGNhcmUgb2YgcmVwb3NpdGlvbmluZyByb3dzIGluIHRoZSB0YWJsZSB0byBtYXRjaCB0aGUgYGRhdGFgIGFycmF5IGluIHRoZSB3YXkgaXQgd2FzIHNvcnRlZCBhbmQgaWYgdGhlIGRhdGEgaXMgc2VwYXJhdGVkIGludG8gYmxvY2tzLCB0aGVuIG1vdmUgdGhlIGJsb2NrIHBpZWNlIHRvIHRoZSBmaXJzdCByb3cgaW4gZWFjaCBkYXRhIGJsb2NrLlxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgLSBmdWxsIHNvcnRlZCBkYXRhc2V0LiBJbnN0YW5jZSBvZiB7QGxpbmsgVGFibGVEYXRhI2dldERhdGF9XHJcbiAgICogQHBhcmFtIHtIVE1MVGFibGVFbGVtZW50fSBzb3VyY2UgLSBzb3VyY2UgdGFibGVcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG11bHRpZGltZW5zaW9uYWxcclxuICAgKiAqL1xyXG4gIHN0YXRpYyByZW9yZGVyUm93cyhkYXRhLHNvdXJjZSxtdWx0aWRpbWVuc2lvbmFsKXtcclxuICAgIGxldCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgIEFnZ3JlZ2F0ZWRUYWJsZS5kaW1lbnNpb25hbERhdGFJdGVyYXRvcihkYXRhLG11bHRpZGltZW5zaW9uYWwsKGRhdGFEaW1lbnNpb24pPT57XHJcbiAgICAgIGlmKG11bHRpZGltZW5zaW9uYWwpe0FnZ3JlZ2F0ZWRUYWJsZS5yZXBvc2l0aW9uQmxvY2tDZWxsKGRhdGFEaW1lbnNpb24pfSAvLyBpZiBtdWx0aWRpbWVuc2lvbmFsIHJlcG9zaXRpb24gYWdncmVnYXRpbmcgYmxvY2sgY2VsbCB0byB0aGUgdG9wbW9zdCByb3cgaW4gc29ydGVkIGFycmF5XHJcbiAgICAgIGRhdGFEaW1lbnNpb24uZm9yRWFjaChpdGVtPT57ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoaXRlbVswXS5jZWxsLnBhcmVudE5vZGUpfSk7IC8vIGFkZCByb3cgdG8gZnJhZ21lbnQgaW4gdGhlIGFycmF5IG9yZGVyLCB0aGlzIGRvZXNuJ3QgYWNjb3VudCBmb3IgY29sdW1uIHN0cmlwcGVkIGRhdGEgeWV0XHJcbiAgICB9KTtcclxuICAgIHNvdXJjZS5xdWVyeVNlbGVjdG9yKCd0Ym9keScpLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcclxuICB9XHJcblxyXG4gIC8qXHJcbiAgICogUmVwb3NpdGlvbnMgdGhlIHJvd3NwYW5uaW5nIGJsb2NrIGNlbGwgZnJvbSB0aGUgaW5pdGlhbCByb3cgdG8gdGhlIG5ldyBzb3J0ZWQgcm93XHJcbiAgICogQHBhcmFtIHtBcnJheX0gaXRlbXMgLSBkaW1lbnNpb24gb2YgZGF0YVxyXG4gICAqICovXHJcbiAgc3RhdGljIHJlcG9zaXRpb25CbG9ja0NlbGwoaXRlbXMpe1xyXG4gICAgbGV0IGJsb2NrUm93SXRlbSA9IGl0ZW1zLmZpbHRlcihpdGVtPT5pdGVtWzBdLmNlbGwucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2ZpcnN0SW5CbG9jaycpKVswXTtcclxuICAgIGxldCBibG9ja1JvdyA9IGJsb2NrUm93SXRlbVswXS5jZWxsLnBhcmVudE5vZGU7XHJcbiAgICBpZihpdGVtcy5pbmRleE9mKGJsb2NrUm93SXRlbSkhPTApey8vIGlmIGJsb2NrIHJvdyBpc24ndCBmaXJzdCBpbiBkaW1lbnNpb25cclxuICAgICAgbGV0IG5ld0ZpcnN0Um93ID0gaXRlbXNbMF1bMF0uY2VsbC5wYXJlbnROb2RlO1xyXG4gICAgICBuZXdGaXJzdFJvdy5pbnNlcnRCZWZvcmUoYmxvY2tSb3cucXVlcnlTZWxlY3RvcignLmJsb2NrQ2VsbCcpLG5ld0ZpcnN0Um93LmZpcnN0RWxlbWVudENoaWxkKTsvLyBtb3ZlIGJsb2NrIGNlbGxcclxuICAgICAgbmV3Rmlyc3RSb3cuY2xhc3NMaXN0LmFkZCgnZmlyc3RJbkJsb2NrJyk7XHJcbiAgICAgIGJsb2NrUm93LmNsYXNzTGlzdC5yZW1vdmUoJ2ZpcnN0SW5CbG9jaycpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogYWxsb3dzIHRvIHBlcmZvcm0gYWN0aW9uIG9uIGRhdGEgYmFzZWQgb24gaXRzIG11bHRpZGltZW5zaW9uYWxpdHlcclxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIC0gZnVsbCBkYXRhc2V0LiBJbnN0YW5jZSBvZiB7QGxpbmsgVGFibGVEYXRhI2dldERhdGF9XHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBtdWx0aWRpbWVuc2lvbmFsXHJcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGNhbGxiYWNrIC0gYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbiBhIGRpbWVuc2lvbiBvZiBkYXRhLiBDYWxsYmFjayBpcyBjYWxsZWQgd2l0aCB0d28gYXR0cmlidXRlczogYGRpbWVuc2lvbmAgLSB0aGUgY3VycmVudCBpdGVyYXRpb24gb2YgZGF0YSBhbmQgYGluZGV4YCAob3B0aW9uYWwpIGlmIGl0J3MgbXVsdGlkaW1lbnNpb25hbFxyXG4gICAqICovXHJcbiAgc3RhdGljIGRpbWVuc2lvbmFsRGF0YUl0ZXJhdG9yKGRhdGEsbXVsdGlkaW1lbnNpb25hbCxjYWxsYmFjayl7XHJcbiAgICBpZighY2FsbGJhY2sgfHwgdHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ2BjYWxsYmFja2AgbXVzdCBiZSBwYXNzZWQgYW5kIGJlIGEgZnVuY3Rpb24nKX1cclxuICAgIGlmKCFtdWx0aWRpbWVuc2lvbmFsKXtcclxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGRhdGEpXHJcbiAgICB9IGVsc2UgeyAvLyBpZiBhcnJheSBoYXMgbmVzdGVkIGFycmF5IGJsb2Nrc1xyXG4gICAgICBkYXRhLmZvckVhY2goKGRpbWVuc2lvbixpbmRleCk9PntcclxuICAgICAgICBjYWxsYmFjayhkaW1lbnNpb24saW5kZXgpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQWdncmVnYXRlZFRhYmxlXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vci1hZ2dyZWdhdGVkLXRhYmxlL3NyYy9hZ2dyZWdhdGVkLXRhYmxlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _tableData = __webpack_require__(2);\n\nvar _tableData2 = _interopRequireDefault(_tableData);\n\nvar _aggregatedTable = __webpack_require__(4);\n\nvar _aggregatedTable2 = _interopRequireDefault(_aggregatedTable);\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nvar _aggregatedTableRowMeta = __webpack_require__(3);\n\nvar _aggregatedTableRowMeta2 = _interopRequireDefault(_aggregatedTableRowMeta);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\r\n * Created by IvanP on 07.09.2016.\r\n */\n\nwindow.Reportal = window.Reportal || {};\n_rReportalBase2.default.mixin(window.Reportal, {\n  TableData: _tableData2.default,\n  AggregatedTable: _aggregatedTable2.default,\n  AggregatedTableRowMeta: _aggregatedTableRowMeta2.default\n});\n\nexports.default = _aggregatedTable2.default;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItYWdncmVnYXRlZC10YWJsZS9zcmMvbWFpbi5qcz85Nzg2Il0sIm5hbWVzIjpbIndpbmRvdyIsIlJlcG9ydGFsIiwibWl4aW4iLCJUYWJsZURhdGEiLCJBZ2dyZWdhdGVkVGFibGUiLCJBZ2dyZWdhdGVkVGFibGVSb3dNZXRhIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFJQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBUEE7Ozs7QUFVQUEsT0FBT0MsUUFBUCxHQUFrQkQsT0FBT0MsUUFBUCxJQUFtQixFQUFyQztBQUNBLHdCQUFhQyxLQUFiLENBQW1CRixPQUFPQyxRQUExQixFQUFtQztBQUNqQ0UsZ0NBRGlDO0FBRWpDQyw0Q0FGaUM7QUFHakNDO0FBSGlDLENBQW5DIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ3JlYXRlZCBieSBJdmFuUCBvbiAwNy4wOS4yMDE2LlxyXG4gKi9cclxuXHJcbmltcG9ydCBUYWJsZURhdGEgZnJvbSBcIi4vdGFibGUtZGF0YVwiO1xyXG5pbXBvcnQgQWdncmVnYXRlZFRhYmxlIGZyb20gXCIuL2FnZ3JlZ2F0ZWQtdGFibGVcIjtcclxuaW1wb3J0IFJlcG9ydGFsQmFzZSBmcm9tIFwici1yZXBvcnRhbC1iYXNlXCI7XHJcbmltcG9ydCBBZ2dyZWdhdGVkVGFibGVSb3dNZXRhIGZyb20gXCIuL2FnZ3JlZ2F0ZWQtdGFibGUtcm93LW1ldGFcIjtcclxuXHJcblxyXG53aW5kb3cuUmVwb3J0YWwgPSB3aW5kb3cuUmVwb3J0YWwgfHwge307XHJcblJlcG9ydGFsQmFzZS5taXhpbih3aW5kb3cuUmVwb3J0YWwse1xyXG4gIFRhYmxlRGF0YSxcclxuICBBZ2dyZWdhdGVkVGFibGUsXHJcbiAgQWdncmVnYXRlZFRhYmxlUm93TWV0YVxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFnZ3JlZ2F0ZWRUYWJsZVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3ItYWdncmVnYXRlZC10YWJsZS9zcmMvbWFpbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by IvanP on 15.12.2016.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * A class that provides utility static methods to load children of a level of hiererachy and a table per a given id\r\n * */\nvar AsyncHierarchyTable = function () {\n  function AsyncHierarchyTable() {\n    _classCallCheck(this, AsyncHierarchyTable);\n  }\n\n  _createClass(AsyncHierarchyTable, null, [{\n    key: 'fetchChildHierarchy',\n\n    /**\r\n     * Queries if each row might contain child rows by quering hierarchy for next level\r\n     * @param {!String} id - rowheader id for current row\r\n     * @param {!Number} hierarchyID - id of Hierarchy in Table Designer\r\n     * @param {!String} hierarchyControlID - id of the Reportal Hierarchy Component instance on the page\r\n     * @param {!String} pageStateID - Reportal state id\r\n     * @param {Number=} languageCode=9 - Language code (according to Confirmit table of language codes) of the language the hierarchy is going to be streamed in at the page load\r\n     * @returns {Array} array of child nodes of the `id` in hierarchy\r\n     * */\n    value: function fetchChildHierarchy(id, hierarchyID, hierarchyControlID, pageStateID) {\n      var languageCode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 9;\n\n      var path = [location.origin, 'reportal', 'Hierarchy', _rReportalBase2.default.getQueryVariable('ReportId'), hierarchyID, languageCode, 'GetChildNodes'];\n\n      var query = ['nodeId=' + id, 'info=' + AsyncHierarchyTable.encode({\n        IsPreview: _rReportalBase2.default.getQueryVariable('Preview') === 'true',\n        HierarchyControlId: hierarchyControlID\n      }), 'isRepBase=false', 'parameter=', 'PageStateId=' + pageStateID];\n\n      var hierarchyItemChildren = _rReportalBase2.default.promiseRequest([path.join('/'), '?', query.join('&')].join(''));\n      return hierarchyItemChildren.then(function (response) {\n        return Promise.resolve(JSON.parse(response));\n      });\n    }\n\n    /**\r\n     * Gets row nodes that are child to the parent row#`id`\r\n     * @param {!String} id - rowheader id for current row\r\n     * @param {?String} parentID - rowheader id for parent row\r\n     * @param {!String} tableID - Reportal Aggregated Table Component id\r\n     * @param {!String} pageStateID - Reportal state id\r\n     * @return {Promise} Returns a thenable promise which result is an `HTMLTableElement` with rows that are children to the row#`id`\r\n     * */\n\n  }, {\n    key: 'fetchChildTable',\n    value: function fetchChildTable(id, parentID, tableID, pageStateID) {\n      parentID = parentID != null ? parentID : id;\n      var path = [location.origin, 'reportal', 'Report', _rReportalBase2.default.getQueryVariable('ReportId'), 'Component', tableID];\n      var query = ['PageId=' + _rReportalBase2.default.getQueryVariable('PageId'), 'Preview=' + _rReportalBase2.default.getQueryVariable('Preview'), 'PageStateId=' + pageStateID, 'pageFilters=' + AsyncHierarchyTable.encode({}), 'customFilters=' + AsyncHierarchyTable.encode({}), 'persNodes=' + AsyncHierarchyTable.encode([{ NodeId: id, Text: null }]), // child node id\n      'origNodes=' + AsyncHierarchyTable.encode([{ NodeId: parentID, Text: null }]) // parent node id\n      ];\n      var tableResult = _rReportalBase2.default.promiseRequest([path.join('/'), '?', query.join('&')].join(''));\n      return tableResult.then(function (response) {\n        var host = document.createElement('span');\n        host.innerHTML = response;\n        return Promise.resolve(host.querySelector('table'));\n      });\n    }\n\n    /**\r\n     * Strips rows from the table received\r\n     * @param {HTMLTableElement} table - Aggregated table element\r\n     * @param {Array} excludedRows - rows excluded from insertion\r\n     * @return {Array} Returns an array of rows {HTMLTableRowElement}\r\n     * */\n\n  }, {\n    key: 'stripRowsFromResponseTable',\n    value: function stripRowsFromResponseTable(table, excludedRows) {\n      var rows = [].slice.call(table.querySelectorAll('tbody>tr'));\n      if (excludedRows && excludedRows.length > 0) {\n        excludedRows.reverse().forEach(function (index) {\n          rows.splice(index, 1);\n        });\n      }\n      return rows;\n    }\n\n    /**\r\n     * Does `JSON.stringify` and `encodeURIComponent` of anything passed to be added to the query string\r\n     * @param {String|Object|Array} toEncode - piece to be URLencoded\r\n     * @returns {String} Returns an encoded string\r\n     * */\n\n  }, {\n    key: 'encode',\n    value: function encode(toEncode) {\n      return encodeURIComponent(JSON.stringify(toEncode));\n    }\n  }]);\n\n  return AsyncHierarchyTable;\n}();\n\nexports.default = AsyncHierarchyTable;\n\n\nwindow.Reportal = window.Reportal || {};\n_rReportalBase2.default.mixin(window.Reportal, {\n  AsyncHierarchyTable: AsyncHierarchyTable\n});\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItYXN5bmMtaGllcmFyY2h5LXRhYmxlL3NyYy9tYWluLmpzPzNiNzUiXSwibmFtZXMiOlsiQXN5bmNIaWVyYXJjaHlUYWJsZSIsImlkIiwiaGllcmFyY2h5SUQiLCJoaWVyYXJjaHlDb250cm9sSUQiLCJwYWdlU3RhdGVJRCIsImxhbmd1YWdlQ29kZSIsInBhdGgiLCJsb2NhdGlvbiIsIm9yaWdpbiIsImdldFF1ZXJ5VmFyaWFibGUiLCJxdWVyeSIsImVuY29kZSIsIklzUHJldmlldyIsIkhpZXJhcmNoeUNvbnRyb2xJZCIsImhpZXJhcmNoeUl0ZW1DaGlsZHJlbiIsInByb21pc2VSZXF1ZXN0Iiwiam9pbiIsInRoZW4iLCJQcm9taXNlIiwicmVzb2x2ZSIsIkpTT04iLCJwYXJzZSIsInJlc3BvbnNlIiwicGFyZW50SUQiLCJ0YWJsZUlEIiwiTm9kZUlkIiwiVGV4dCIsInRhYmxlUmVzdWx0IiwiaG9zdCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsInF1ZXJ5U2VsZWN0b3IiLCJ0YWJsZSIsImV4Y2x1ZGVkUm93cyIsInJvd3MiLCJzbGljZSIsImNhbGwiLCJxdWVyeVNlbGVjdG9yQWxsIiwibGVuZ3RoIiwicmV2ZXJzZSIsImZvckVhY2giLCJzcGxpY2UiLCJpbmRleCIsInRvRW5jb2RlIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic3RyaW5naWZ5Iiwid2luZG93IiwiUmVwb3J0YWwiLCJtaXhpbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O3FqQkFBQTs7Ozs7QUFHQTs7Ozs7Ozs7QUFFQTs7O0lBR01BLG1COzs7Ozs7OztBQUNKOzs7Ozs7Ozs7d0NBUzJCQyxFLEVBQUdDLFcsRUFBWUMsa0IsRUFBbUJDLFcsRUFBMkI7QUFBQSxVQUFmQyxZQUFlLHVFQUFGLENBQUU7O0FBQ3RGLFVBQUlDLE9BQU8sQ0FDVEMsU0FBU0MsTUFEQSxFQUVULFVBRlMsRUFHVCxXQUhTLEVBSVQsd0JBQWFDLGdCQUFiLENBQThC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RDs7Ozs7O2tCQUlZNUMsbUI7OztBQUdmK0MsT0FBT0MsUUFBUCxHQUFrQkQsT0FBT0MsUUFBUCxJQUFtQixFQUFyQztBQUNBLHdCQUFhQyxLQUFiLENBQW1CRixPQUFPQyxRQUExQixFQUFtQztBQUNqQ2hEO0FBRGlDLENBQW5DIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ3JlYXRlZCBieSBJdmFuUCBvbiAxNS4xMi4yMDE2LlxyXG4gKi9cclxuaW1wb3J0IFJlcG9ydGFsQmFzZSBmcm9tIFwici1yZXBvcnRhbC1iYXNlXCI7XHJcblxyXG4vKipcclxuICogQSBjbGFzcyB0aGF0IHByb3ZpZGVzIHV0aWxpdHkgc3RhdGljIG1ldGhvZHMgdG8gbG9hZCBjaGlsZHJlbiBvZiBhIGxldmVsIG9mIGhpZXJlcmFjaHkgYW5kIGEgdGFibGUgcGVyIGEgZ2l2ZW4gaWRcclxuICogKi9cclxuY2xhc3MgQXN5bmNIaWVyYXJjaHlUYWJsZXtcclxuICAvKipcclxuICAgKiBRdWVyaWVzIGlmIGVhY2ggcm93IG1pZ2h0IGNvbnRhaW4gY2hpbGQgcm93cyBieSBxdWVyaW5nIGhpZXJhcmNoeSBmb3IgbmV4dCBsZXZlbFxyXG4gICAqIEBwYXJhbSB7IVN0cmluZ30gaWQgLSByb3doZWFkZXIgaWQgZm9yIGN1cnJlbnQgcm93XHJcbiAgICogQHBhcmFtIHshTnVtYmVyfSBoaWVyYXJjaHlJRCAtIGlkIG9mIEhpZXJhcmNoeSBpbiBUYWJsZSBEZXNpZ25lclxyXG4gICAqIEBwYXJhbSB7IVN0cmluZ30gaGllcmFyY2h5Q29udHJvbElEIC0gaWQgb2YgdGhlIFJlcG9ydGFsIEhpZXJhcmNoeSBDb21wb25lbnQgaW5zdGFuY2Ugb24gdGhlIHBhZ2VcclxuICAgKiBAcGFyYW0geyFTdHJpbmd9IHBhZ2VTdGF0ZUlEIC0gUmVwb3J0YWwgc3RhdGUgaWRcclxuICAgKiBAcGFyYW0ge051bWJlcj19IGxhbmd1YWdlQ29kZT05IC0gTGFuZ3VhZ2UgY29kZSAoYWNjb3JkaW5nIHRvIENvbmZpcm1pdCB0YWJsZSBvZiBsYW5ndWFnZSBjb2Rlcykgb2YgdGhlIGxhbmd1YWdlIHRoZSBoaWVyYXJjaHkgaXMgZ29pbmcgdG8gYmUgc3RyZWFtZWQgaW4gYXQgdGhlIHBhZ2UgbG9hZFxyXG4gICAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXkgb2YgY2hpbGQgbm9kZXMgb2YgdGhlIGBpZGAgaW4gaGllcmFyY2h5XHJcbiAgICogKi9cclxuICBzdGF0aWMgZmV0Y2hDaGlsZEhpZXJhcmNoeShpZCxoaWVyYXJjaHlJRCxoaWVyYXJjaHlDb250cm9sSUQscGFnZVN0YXRlSUQsbGFuZ3VhZ2VDb2RlPTkpe1xyXG4gICAgbGV0IHBhdGggPSBbXHJcbiAgICAgIGxvY2F0aW9uLm9yaWdpbixcclxuICAgICAgJ3JlcG9ydGFsJyxcclxuICAgICAgJ0hpZXJhcmNoeScsXHJcbiAgICAgIFJlcG9ydGFsQmFzZS5nZXRRdWVyeVZhcmlhYmxlKCdSZXBvcnRJZCcpLFxyXG4gICAgICBoaWVyYXJjaHlJRCxcclxuICAgICAgbGFuZ3VhZ2VDb2RlLFxyXG4gICAgICAnR2V0Q2hpbGROb2RlcydcclxuICAgIF07XHJcblxyXG4gICAgbGV0IHF1ZXJ5PVtcclxuICAgICAgYG5vZGVJZD0ke2lkfWAsXHJcbiAgICAgIGBpbmZvPSR7QXN5bmNIaWVyYXJjaHlUYWJsZS5lbmNvZGUoe1xyXG4gICAgICAgIElzUHJldmlldzpSZXBvcnRhbEJhc2UuZ2V0UXVlcnlWYXJpYWJsZSgnUHJldmlldycpPT09J3RydWUnLFxyXG4gICAgICAgIEhpZXJhcmNoeUNvbnRyb2xJZDpoaWVyYXJjaHlDb250cm9sSURcclxuICAgICAgfSl9YCxcclxuICAgICAgJ2lzUmVwQmFzZT1mYWxzZScsXHJcbiAgICAgICdwYXJhbWV0ZXI9JyxcclxuICAgICAgYFBhZ2VTdGF0ZUlkPSR7cGFnZVN0YXRlSUR9YFxyXG4gICAgXTtcclxuXHJcbiAgICBsZXQgaGllcmFyY2h5SXRlbUNoaWxkcmVuID0gUmVwb3J0YWxCYXNlLnByb21pc2VSZXF1ZXN0KFtwYXRoLmpvaW4oJy8nKSwnPycscXVlcnkuam9pbignJicpXS5qb2luKCcnKSk7XHJcbiAgICByZXR1cm4gaGllcmFyY2h5SXRlbUNoaWxkcmVuLnRoZW4ocmVzcG9uc2U9PntyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEpTT04ucGFyc2UocmVzcG9uc2UpKX0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyByb3cgbm9kZXMgdGhhdCBhcmUgY2hpbGQgdG8gdGhlIHBhcmVudCByb3cjYGlkYFxyXG4gICAqIEBwYXJhbSB7IVN0cmluZ30gaWQgLSByb3doZWFkZXIgaWQgZm9yIGN1cnJlbnQgcm93XHJcbiAgICogQHBhcmFtIHs/U3RyaW5nfSBwYXJlbnRJRCAtIHJvd2hlYWRlciBpZCBmb3IgcGFyZW50IHJvd1xyXG4gICAqIEBwYXJhbSB7IVN0cmluZ30gdGFibGVJRCAtIFJlcG9ydGFsIEFnZ3JlZ2F0ZWQgVGFibGUgQ29tcG9uZW50IGlkXHJcbiAgICogQHBhcmFtIHshU3RyaW5nfSBwYWdlU3RhdGVJRCAtIFJlcG9ydGFsIHN0YXRlIGlkXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmV0dXJucyBhIHRoZW5hYmxlIHByb21pc2Ugd2hpY2ggcmVzdWx0IGlzIGFuIGBIVE1MVGFibGVFbGVtZW50YCB3aXRoIHJvd3MgdGhhdCBhcmUgY2hpbGRyZW4gdG8gdGhlIHJvdyNgaWRgXHJcbiAgICogKi9cclxuICBzdGF0aWMgZmV0Y2hDaGlsZFRhYmxlKGlkLCBwYXJlbnRJRCwgdGFibGVJRCxwYWdlU3RhdGVJRCl7XHJcbiAgICBwYXJlbnRJRCA9IHBhcmVudElEIT1udWxsP3BhcmVudElEOmlkO1xyXG4gICAgbGV0IHBhdGggPSBbXHJcbiAgICAgIGxvY2F0aW9uLm9yaWdpbixcclxuICAgICAgJ3JlcG9ydGFsJyxcclxuICAgICAgJ1JlcG9ydCcsXHJcbiAgICAgIFJlcG9ydGFsQmFzZS5nZXRRdWVyeVZhcmlhYmxlKCdSZXBvcnRJZCcpLFxyXG4gICAgICAnQ29tcG9uZW50JyxcclxuICAgICAgdGFibGVJRFxyXG4gICAgXTtcclxuICAgIGxldCBxdWVyeT1bXHJcbiAgICAgIGBQYWdlSWQ9JHtSZXBvcnRhbEJhc2UuZ2V0UXVlcnlWYXJpYWJsZSgnUGFnZUlkJyl9YCxcclxuICAgICAgYFByZXZpZXc9JHtSZXBvcnRhbEJhc2UuZ2V0UXVlcnlWYXJpYWJsZSgnUHJldmlldycpfWAsXHJcbiAgICAgIGBQYWdlU3RhdGVJZD0ke3BhZ2VTdGF0ZUlEfWAsXHJcbiAgICAgIGBwYWdlRmlsdGVycz0ke0FzeW5jSGllcmFyY2h5VGFibGUuZW5jb2RlKHt9KX1gLFxyXG4gICAgICBgY3VzdG9tRmlsdGVycz0ke0FzeW5jSGllcmFyY2h5VGFibGUuZW5jb2RlKHt9KX1gLFxyXG4gICAgICBgcGVyc05vZGVzPSR7QXN5bmNIaWVyYXJjaHlUYWJsZS5lbmNvZGUoW3tOb2RlSWQ6aWQsVGV4dDpudWxsfV0pfWAsIC8vIGNoaWxkIG5vZGUgaWRcclxuICAgICAgYG9yaWdOb2Rlcz0ke0FzeW5jSGllcmFyY2h5VGFibGUuZW5jb2RlKFt7Tm9kZUlkOnBhcmVudElELFRleHQ6bnVsbH1dKX1gIC8vIHBhcmVudCBub2RlIGlkXHJcbiAgICBdO1xyXG4gICAgbGV0IHRhYmxlUmVzdWx0ID0gUmVwb3J0YWxCYXNlLnByb21pc2VSZXF1ZXN0KFtwYXRoLmpvaW4oJy8nKSwnPycscXVlcnkuam9pbignJicpXS5qb2luKCcnKSk7XHJcbiAgICByZXR1cm4gdGFibGVSZXN1bHQudGhlbihyZXNwb25zZT0+e1xyXG4gICAgICBsZXQgaG9zdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICAgICAgaG9zdC5pbm5lckhUTUwgPSByZXNwb25zZTtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShob3N0LnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJykpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdHJpcHMgcm93cyBmcm9tIHRoZSB0YWJsZSByZWNlaXZlZFxyXG4gICAqIEBwYXJhbSB7SFRNTFRhYmxlRWxlbWVudH0gdGFibGUgLSBBZ2dyZWdhdGVkIHRhYmxlIGVsZW1lbnRcclxuICAgKiBAcGFyYW0ge0FycmF5fSBleGNsdWRlZFJvd3MgLSByb3dzIGV4Y2x1ZGVkIGZyb20gaW5zZXJ0aW9uXHJcbiAgICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2Ygcm93cyB7SFRNTFRhYmxlUm93RWxlbWVudH1cclxuICAgKiAqL1xyXG4gIHN0YXRpYyBzdHJpcFJvd3NGcm9tUmVzcG9uc2VUYWJsZSh0YWJsZSxleGNsdWRlZFJvd3Mpe1xyXG4gICAgbGV0IHJvd3MgPSBbXS5zbGljZS5jYWxsKHRhYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3Rib2R5PnRyJykpO1xyXG4gICAgaWYoZXhjbHVkZWRSb3dzICYmIGV4Y2x1ZGVkUm93cy5sZW5ndGg+MCl7XHJcbiAgICAgIGV4Y2x1ZGVkUm93cy5yZXZlcnNlKCkuZm9yRWFjaChpbmRleD0+e1xyXG4gICAgICAgIHJvd3Muc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcm93cztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERvZXMgYEpTT04uc3RyaW5naWZ5YCBhbmQgYGVuY29kZVVSSUNvbXBvbmVudGAgb2YgYW55dGhpbmcgcGFzc2VkIHRvIGJlIGFkZGVkIHRvIHRoZSBxdWVyeSBzdHJpbmdcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8QXJyYXl9IHRvRW5jb2RlIC0gcGllY2UgdG8gYmUgVVJMZW5jb2RlZFxyXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFJldHVybnMgYW4gZW5jb2RlZCBzdHJpbmdcclxuICAgKiAqL1xyXG4gIHN0YXRpYyBlbmNvZGUodG9FbmNvZGUpe1xyXG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh0b0VuY29kZSkpO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFzeW5jSGllcmFyY2h5VGFibGU7XHJcblxyXG5cclxud2luZG93LlJlcG9ydGFsID0gd2luZG93LlJlcG9ydGFsIHx8IHt9O1xyXG5SZXBvcnRhbEJhc2UubWl4aW4od2luZG93LlJlcG9ydGFsLHtcclxuICBBc3luY0hpZXJhcmNoeVRhYmxlXHJcbn0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3ItYXN5bmMtaGllcmFyY2h5LXRhYmxlL3NyYy9tYWluLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 7 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SortOrder = function () {\n  /**\r\n   * Creates a `sortOrder` array\r\n   * @param {Object} options - configuration options\r\n   * @param {Object} options.columns - an array of columns from {@link TableColumns}\r\n   * @param {Function} options.sortCallback - function that performs sorting based on the `sortOrder`\r\n   * @param {Object} options.sortCallbackScope - scope in which sort callback needs to be executed\r\n   * @param {Object} [options.defaultSorting] - an array of objects that specify default sorting\r\n   * @param {Number} options.defaultSorting.column - column index\r\n   * @param {String} options.defaultSorting.direction - sort direction (`asc`|`desc`)\r\n   * @return {Array}\r\n   * */\n  function SortOrder(options) {\n    var _this = this;\n\n    _classCallCheck(this, SortOrder);\n\n    var columns = options.columns,\n        sortCallback = options.sortCallback,\n        _options$defaultSorti = options.defaultSorting,\n        defaultSorting = _options$defaultSorti === undefined ? [] : _options$defaultSorti,\n        _options$sortCallback = options.sortCallbackScope,\n        sortCallbackScope = _options$sortCallback === undefined ? this : _options$sortCallback;\n\n\n    this.sortOrder = [];\n    if ((typeof columns === 'undefined' ? 'undefined' : _typeof(columns)) != undefined && columns != null) {\n      this.columns = columns;\n    } else {\n      throw new TypeError('SortOrder: columns must be specified');\n    }\n    this.sort = function () {\n      if (sortCallback && typeof sortCallback === 'function') {\n        sortCallback.call(sortCallbackScope, _this);\n      }\n    };\n    if (defaultSorting.length > 0) {\n      defaultSorting.forEach(function (item) {\n        return _this.add(item);\n      });\n      this.sort();\n    }\n  }\n\n  /**\r\n   * Returns an array containing a `cell` from the table and a reference cell (`refCell`) from the floating header if any\r\n   * @param {!Number} columnIndex - index of the column from the array of columns from {@link TableColumns}\r\n   * @return {{cell:HTMLTableCellElement, refCell:HTMLTableCellElement}}\r\n   * */\n\n\n  _createClass(SortOrder, [{\n    key: 'getCell',\n    value: function getCell(columnIndex) {\n      if (typeof columnIndex != 'undefined' && columnIndex != null) {\n        var cells = [];\n        if (this.columns[columnIndex].cell) {\n          cells.push(this.columns[columnIndex].cell);\n        }\n        if (this.columns[columnIndex].refCell) {\n          cells.push(this.columns[columnIndex].refCell);\n        }\n        return cells;\n      } else {\n        throw new TypeError('columnIndex parameter should not be null');\n      }\n    }\n\n    /**\r\n     * Adds another column to be sorted\r\n     * @param {!Object} obj - object describing sorting\r\n     * @param {Number} obj.column - column index\r\n     * @param {String} obj.direction - sort direction (`asc`|`desc`)\r\n     * */\n\n  }, {\n    key: 'add',\n    value: function add(obj) {\n      this.getCell(obj.column).forEach(function (cell) {\n        //if(!cell.classList.contains('sorted')){ // this column is not sorted, there might be others that are.\n        ['sorted', obj.direction].forEach(function (className) {\n          return cell.classList.add(className);\n        });\n        //} else { //swaps sorting from asc to desc\n        //  ['asc','desc'].forEach(className=>cell.classList.toggle(className));\n        //}\n      });\n      this.sortOrder.push(obj);\n    }\n\n    /**\r\n     * Removes a column from `sortOrder`\r\n     * @param {Number} column - column index as reference to the item to be removed.\r\n     * @param {Number} index - index of item in `sortOrder` array to be removed\r\n     * */\n\n  }, {\n    key: 'remove',\n    value: function remove(column, index) {\n      var _this2 = this;\n\n      ['sorted', 'asc', 'desc'].forEach(function (className) {\n        _this2.getCell(column).forEach(function (cell) {\n          return cell.classList.remove(className);\n        });\n      });\n      this.sortOrder.splice(index, 1);\n    }\n  }, {\n    key: 'replace',\n\n\n    /**\r\n     * Replaces all items in `sortOrder`\r\n     * @param {!Object} obj - object describing sorting\r\n     * @param {Number} obj.column - column index\r\n     * @param {String} obj.direction - sort direction (`asc`|`desc`)\r\n     * */\n    value: function replace(obj) {\n      var _this3 = this;\n\n      if (this.sortOrder.length > 0) {\n        this.sortOrder.forEach(function (item, index) {\n          _this3.remove(item.column, index);\n        });\n      }\n      this.add(obj);\n      this.sort();\n    }\n  }]);\n\n  return SortOrder;\n}();\n\nexports.default = SortOrder;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Itc29ydC10YWJsZS9zcmMvc29ydC1vcmRlci5qcz8xMGIzIl0sIm5hbWVzIjpbIlNvcnRPcmRlciIsIm9wdGlvbnMiLCJjb2x1bW5zIiwic29ydENhbGxiYWNrIiwiZGVmYXVsdFNvcnRpbmciLCJzb3J0Q2FsbGJhY2tTY29wZSIsInNvcnRPcmRlciIsInVuZGVmaW5lZCIsIlR5cGVFcnJvciIsInNvcnQiLCJjYWxsIiwibGVuZ3RoIiwiZm9yRWFjaCIsImFkZCIsIml0ZW0iLCJjb2x1bW5JbmRleCIsImNlbGxzIiwiY2VsbCIsInB1c2giLCJyZWZDZWxsIiwib2JqIiwiZ2V0Q2VsbCIsImNvbHVtbiIsImRpcmVjdGlvbiIsImNsYXNzTGlzdCIsImNsYXNzTmFtZSIsImluZGV4IiwicmVtb3ZlIiwic3BsaWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFBTUEsUztBQUNKOzs7Ozs7Ozs7OztBQVdBLHFCQUFZQyxPQUFaLEVBQW9CO0FBQUE7O0FBQUE7O0FBQUEsUUFDYkMsT0FEYSxHQUN1REQsT0FEdkQsQ0FDYkMsT0FEYTtBQUFBLFFBQ0pDLFlBREksR0FDdURGLE9BRHZELENBQ0pFLFlBREk7QUFBQSxnQ0FDdURGLE9BRHZELENBQ1VHLGNBRFY7QUFBQSxRQUNVQSxjQURWLHlDQUN5QixFQUR6QjtBQUFBLGdDQUN1REgsT0FEdkQsQ0FDNkJJLGlCQUQ3QjtBQUFBLFFBQzZCQSxpQkFEN0IseUNBQytDLElBRC9DOzs7QUFHbEIsU0FBS0MsU0FBTCxHQUFpQixFQUFqQjtBQUNBLFFBQUcsUUFBT0osT0FBUCx5Q0FBT0EsT0FBUCxNQUFrQkssU0FBbEIsSUFBK0JMLFdBQVcsSUFBN0MsRUFBa0Q7QUFDaEQsV0FBS0EsT0FBTCxHQUFlQSxPQUFmO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsWUFBTSxJQUFJTSxTQUFKLENBQWMsc0NBQWQsQ0FBTjtBQUNEO0FBQ0QsU0FBS0MsSUFBTCxHQUFZLFlBQUk7QUFDZCxVQUFHTixnQkFBZ0IsT0FBT0EsWUFBUCxLQUF3QixVQUEzQyxFQUFzRDtBQUNwREEscUJBQWFPLElBQWIsQ0FBa0JMLGlCQUFsQjtBQUNEO0FBQ0YsS0FKRDtBQUtBLFFBQUdELGVBQWVPLE1BQWYsR0FBc0IsQ0FBekIsRUFBMkI7QUFDekJQLHFCQUFlUSxPQUFmLENBQXVCO0FBQUEsZUFBTSxNQUFLQyxHQUFMLENBQVNDLElBQVQsQ0FBTjtBQUFBLE9BQXZCO0FBQ0EsV0FBS0wsSUFBTDtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs0QkFLUU0sVyxFQUFZO0FBQ2xCLFVBQUcsT0FBT0EsV0FBUCxJQUFzQixXQUF0QixJQUFxQ0EsZUFBYSxJQUFyRCxFQUEwRDtBQUN4RCxZQUFJQyxRQUFRLEVBQVo7QUFDQSxZQUFHLEtBQUtkLE9BQUwsQ0FBYWEsV0FBYixFQUEwQkUsSUFBN0IsRUFBa0M7QUFBQ0QsZ0JBQU1FLElBQU4sQ0FBVyxLQUFLaEIsT0FBTCxDQUFhYSxXQUFiLEVBQTBCRSxJQUFyQztBQUEyQztBQUM5RSxZQUFHLEtBQUtmLE9BQUwsQ0FBYWEsV0FBYixFQUEwQkksT0FBN0IsRUFBcUM7QUFBQ0gsZ0JBQU1FLElBQU4sQ0FBVyxLQUFLaEIsT0FBTCxDQUFhYSxXQUFiLEVBQTBCSSxPQUFyQztBQUE4QztBQUNwRixlQUFPSCxLQUFQO0FBQ0QsT0FMRCxNQUtPO0FBQ0wsY0FBTSxJQUFJUixTQUFKLENBQWMsMENBQWQsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozt3QkFPS1ksRyxFQUFJO0FBQ1AsV0FBS0MsT0FBTCxDQUFhRCxJQUFJRSxNQUFqQixFQUF5QlYsT0FBekIsQ0FBaUMsZ0JBQU07QUFDckM7QUFDRSxTQUFDLFFBQUQsRUFBVVEsSUFBSUcsU0FBZCxFQUF5QlgsT0FBekIsQ0FBaUM7QUFBQSxpQkFBV0ssS0FBS08sU0FBTCxDQUFlWCxHQUFmLENBQW1CWSxTQUFuQixDQUFYO0FBQUEsU0FBakM7QUFDRjtBQUNBO0FBQ0E7QUFDRCxPQU5EO0FBT0EsV0FBS25CLFNBQUwsQ0FBZVksSUFBZixDQUFvQkUsR0FBcEI7QUFDRDs7QUFFRDs7Ozs7Ozs7MkJBS1FFLE0sRUFBT0ksSyxFQUFNO0FBQUE7O0FBQ25CLE9BQUMsUUFBRCxFQUFVLEtBQVYsRUFBZ0IsTUFBaEIsRUFBd0JkLE9BQXhCLENBQWdDLHFCQUFXO0FBQ3pDLGVBQUtTLE9BQUwsQ0FBYUMsTUFBYixFQUFxQlYsT0FBckIsQ0FBNkI7QUFBQSxpQkFBTUssS0FBS08sU0FBTCxDQUFlRyxNQUFmLENBQXNCRixTQUF0QixDQUFOO0FBQUEsU0FBN0I7QUFDRCxPQUZEO0FBR0EsV0FBS25CLFNBQUwsQ0FBZXNCLE1BQWYsQ0FBc0JGLEtBQXRCLEVBQTRCLENBQTVCO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs0QkFNU04sRyxFQUFJO0FBQUE7O0FBQ1gsVUFBRyxLQUFLZCxTQUFMLENBQWVLLE1BQWYsR0FBc0IsQ0FBekIsRUFBMkI7QUFDekIsYUFBS0wsU0FBTCxDQUFlTSxPQUFmLENBQXVCLFVBQUNFLElBQUQsRUFBTVksS0FBTixFQUFjO0FBQ25DLGlCQUFLQyxNQUFMLENBQVliLEtBQUtRLE1BQWpCLEVBQXdCSSxLQUF4QjtBQUNELFNBRkQ7QUFHRDtBQUNELFdBQUtiLEdBQUwsQ0FBU08sR0FBVDtBQUNBLFdBQUtYLElBQUw7QUFDRDs7Ozs7O2tCQUVZVCxTIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBTb3J0T3JkZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBgc29ydE9yZGVyYCBhcnJheVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuY29sdW1ucyAtIGFuIGFycmF5IG9mIGNvbHVtbnMgZnJvbSB7QGxpbmsgVGFibGVDb2x1bW5zfVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuc29ydENhbGxiYWNrIC0gZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBzb3J0aW5nIGJhc2VkIG9uIHRoZSBgc29ydE9yZGVyYFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnNvcnRDYWxsYmFja1Njb3BlIC0gc2NvcGUgaW4gd2hpY2ggc29ydCBjYWxsYmFjayBuZWVkcyB0byBiZSBleGVjdXRlZFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5kZWZhdWx0U29ydGluZ10gLSBhbiBhcnJheSBvZiBvYmplY3RzIHRoYXQgc3BlY2lmeSBkZWZhdWx0IHNvcnRpbmdcclxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kZWZhdWx0U29ydGluZy5jb2x1bW4gLSBjb2x1bW4gaW5kZXhcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5kZWZhdWx0U29ydGluZy5kaXJlY3Rpb24gLSBzb3J0IGRpcmVjdGlvbiAoYGFzY2B8YGRlc2NgKVxyXG4gICAqIEByZXR1cm4ge0FycmF5fVxyXG4gICAqICovXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucyl7XHJcbiAgICBsZXQge2NvbHVtbnMsIHNvcnRDYWxsYmFjaywgZGVmYXVsdFNvcnRpbmc9W10sIHNvcnRDYWxsYmFja1Njb3BlPXRoaXN9ID0gb3B0aW9ucztcclxuXHJcbiAgICB0aGlzLnNvcnRPcmRlciA9IFtdO1xyXG4gICAgaWYodHlwZW9mIGNvbHVtbnMgIT0gdW5kZWZpbmVkICYmIGNvbHVtbnMgIT0gbnVsbCl7XHJcbiAgICAgIHRoaXMuY29sdW1ucyA9IGNvbHVtbnM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTb3J0T3JkZXI6IGNvbHVtbnMgbXVzdCBiZSBzcGVjaWZpZWQnKTtcclxuICAgIH1cclxuICAgIHRoaXMuc29ydCA9ICgpPT57XHJcbiAgICAgIGlmKHNvcnRDYWxsYmFjayAmJiB0eXBlb2Ygc29ydENhbGxiYWNrID09PSAnZnVuY3Rpb24nKXtcclxuICAgICAgICBzb3J0Q2FsbGJhY2suY2FsbChzb3J0Q2FsbGJhY2tTY29wZSx0aGlzKVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYoZGVmYXVsdFNvcnRpbmcubGVuZ3RoPjApe1xyXG4gICAgICBkZWZhdWx0U29ydGluZy5mb3JFYWNoKGl0ZW09PnRoaXMuYWRkKGl0ZW0pKTtcclxuICAgICAgdGhpcy5zb3J0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgYSBgY2VsbGAgZnJvbSB0aGUgdGFibGUgYW5kIGEgcmVmZXJlbmNlIGNlbGwgKGByZWZDZWxsYCkgZnJvbSB0aGUgZmxvYXRpbmcgaGVhZGVyIGlmIGFueVxyXG4gICAqIEBwYXJhbSB7IU51bWJlcn0gY29sdW1uSW5kZXggLSBpbmRleCBvZiB0aGUgY29sdW1uIGZyb20gdGhlIGFycmF5IG9mIGNvbHVtbnMgZnJvbSB7QGxpbmsgVGFibGVDb2x1bW5zfVxyXG4gICAqIEByZXR1cm4ge3tjZWxsOkhUTUxUYWJsZUNlbGxFbGVtZW50LCByZWZDZWxsOkhUTUxUYWJsZUNlbGxFbGVtZW50fX1cclxuICAgKiAqL1xyXG4gIGdldENlbGwoY29sdW1uSW5kZXgpe1xyXG4gICAgaWYodHlwZW9mIGNvbHVtbkluZGV4ICE9ICd1bmRlZmluZWQnICYmIGNvbHVtbkluZGV4IT1udWxsKXtcclxuICAgICAgbGV0IGNlbGxzID0gW107XHJcbiAgICAgIGlmKHRoaXMuY29sdW1uc1tjb2x1bW5JbmRleF0uY2VsbCl7Y2VsbHMucHVzaCh0aGlzLmNvbHVtbnNbY29sdW1uSW5kZXhdLmNlbGwpfVxyXG4gICAgICBpZih0aGlzLmNvbHVtbnNbY29sdW1uSW5kZXhdLnJlZkNlbGwpe2NlbGxzLnB1c2godGhpcy5jb2x1bW5zW2NvbHVtbkluZGV4XS5yZWZDZWxsKX1cclxuICAgICAgcmV0dXJuIGNlbGxzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29sdW1uSW5kZXggcGFyYW1ldGVyIHNob3VsZCBub3QgYmUgbnVsbCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhbm90aGVyIGNvbHVtbiB0byBiZSBzb3J0ZWRcclxuICAgKiBAcGFyYW0geyFPYmplY3R9IG9iaiAtIG9iamVjdCBkZXNjcmliaW5nIHNvcnRpbmdcclxuICAgKiBAcGFyYW0ge051bWJlcn0gb2JqLmNvbHVtbiAtIGNvbHVtbiBpbmRleFxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvYmouZGlyZWN0aW9uIC0gc29ydCBkaXJlY3Rpb24gKGBhc2NgfGBkZXNjYClcclxuICAgKiAqL1xyXG5cclxuICBhZGQgKG9iail7XHJcbiAgICB0aGlzLmdldENlbGwob2JqLmNvbHVtbikuZm9yRWFjaChjZWxsPT57XHJcbiAgICAgIC8vaWYoIWNlbGwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzb3J0ZWQnKSl7IC8vIHRoaXMgY29sdW1uIGlzIG5vdCBzb3J0ZWQsIHRoZXJlIG1pZ2h0IGJlIG90aGVycyB0aGF0IGFyZS5cclxuICAgICAgICBbJ3NvcnRlZCcsb2JqLmRpcmVjdGlvbl0uZm9yRWFjaChjbGFzc05hbWU9PmNlbGwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpKTtcclxuICAgICAgLy99IGVsc2UgeyAvL3N3YXBzIHNvcnRpbmcgZnJvbSBhc2MgdG8gZGVzY1xyXG4gICAgICAvLyAgWydhc2MnLCdkZXNjJ10uZm9yRWFjaChjbGFzc05hbWU9PmNlbGwuY2xhc3NMaXN0LnRvZ2dsZShjbGFzc05hbWUpKTtcclxuICAgICAgLy99XHJcbiAgICB9KTtcclxuICAgIHRoaXMuc29ydE9yZGVyLnB1c2gob2JqKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgYSBjb2x1bW4gZnJvbSBgc29ydE9yZGVyYFxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2x1bW4gLSBjb2x1bW4gaW5kZXggYXMgcmVmZXJlbmNlIHRvIHRoZSBpdGVtIHRvIGJlIHJlbW92ZWQuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gaW5kZXggb2YgaXRlbSBpbiBgc29ydE9yZGVyYCBhcnJheSB0byBiZSByZW1vdmVkXHJcbiAgICogKi9cclxuICByZW1vdmUgKGNvbHVtbixpbmRleCl7XHJcbiAgICBbJ3NvcnRlZCcsJ2FzYycsJ2Rlc2MnXS5mb3JFYWNoKGNsYXNzTmFtZT0+e1xyXG4gICAgICB0aGlzLmdldENlbGwoY29sdW1uKS5mb3JFYWNoKGNlbGw9PmNlbGwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpKVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnNvcnRPcmRlci5zcGxpY2UoaW5kZXgsMSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVwbGFjZXMgYWxsIGl0ZW1zIGluIGBzb3J0T3JkZXJgXHJcbiAgICogQHBhcmFtIHshT2JqZWN0fSBvYmogLSBvYmplY3QgZGVzY3JpYmluZyBzb3J0aW5nXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9iai5jb2x1bW4gLSBjb2x1bW4gaW5kZXhcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqLmRpcmVjdGlvbiAtIHNvcnQgZGlyZWN0aW9uIChgYXNjYHxgZGVzY2ApXHJcbiAgICogKi9cclxuICByZXBsYWNlIChvYmope1xyXG4gICAgaWYodGhpcy5zb3J0T3JkZXIubGVuZ3RoPjApe1xyXG4gICAgICB0aGlzLnNvcnRPcmRlci5mb3JFYWNoKChpdGVtLGluZGV4KT0+e1xyXG4gICAgICAgIHRoaXMucmVtb3ZlKGl0ZW0uY29sdW1uLGluZGV4KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmFkZChvYmopO1xyXG4gICAgdGhpcy5zb3J0KCk7XHJcbiAgfTtcclxufVxyXG5leHBvcnQgZGVmYXVsdCBTb3J0T3JkZXI7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vci1zb3J0LXRhYmxlL3NyYy9zb3J0LW9yZGVyLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nvar _tableColumns = __webpack_require__(9);\n\nvar _tableColumns2 = _interopRequireDefault(_tableColumns);\n\nvar _sortOrder = __webpack_require__(7);\n\nvar _sortOrder2 = _interopRequireDefault(_sortOrder);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Event reporting that a table has been sorted\r\n * @event SortTable~reportal-table-sort\r\n */\n\n/**\r\n * Makes a table sortable, gives API for sorting. It sorts `data` array, but doesn't move rows in the `source` table, because of differences in implementation.\r\n *\r\n * > Note: It's important that every Array item that is going to be sortable was either a `String`, a `Number`, a `null`, or an `Object` that contained `data` property (which was of the previously named types)\r\n *\r\n * @param {Object} options - options passed to configure the Sorting\r\n * @param {HTMLTableElement} options.source - source table sorting will be applied to\r\n * @param {HTMLTableElement} [options.refSource] - the floating header if any, will reflect and trigger sorting on header when scrolled.\r\n * @param {Number} [options.defaultHeaderRow=-1] - index of the row in `thead` (incremented from 0) that will have sorting enabled for columns. If `-1` then last row.\r\n * @param {Array} [options.included] - Array of column indices (incremented from 0) that will have sorting enabled. If not specified, all columns will be sortable. Optionally `excluded` can be specified instead as a shorthand to pass only indices of columns to be excluded from sorting, assumning that others will be made sortable. It's important to count the column index in the defaultHeaderRow\r\n * @param {Array} [options.excluded] - Array of column indices (incremented from 0) that will be excluded from sorting. Can be used as a shorthand instead of `included`.\r\n * @param {Object} [options.defaultSorting] - an array of objects that specify default sorting\r\n * @param {Number} options.defaultSorting.column - column index\r\n * @param {String} options.defaultSorting.direction - sort direction (`asc`|`desc`)\r\n * @param {Array} options.data - data with information for rows to be sorted\r\n * @param {Boolean} [options.multidimensional=false] - if `data` is single-dimensional (contains rows with data to be sorted as immediate array items: `data [rowItem...]`), then it is `false`. If it has blocks of data as items (each block containing an array of rows to be sorted: data [block [rowItem...]...]), then set it to `true`. Currently it supports only a two-level aggregation max (data->block->rowItem).\r\n * @prop {HTMLTableElement} source - source table\r\n * @prop {Array} data - data array to be sorted\r\n * @prop {Boolean} multidimensional - if `data` is mono-dimensional (contains rows with data to be sorted as immediate array items: `data [rowItem...]`), then it is `false`. If it has blocks of data as items (each block containing an array of rows to be sorted: data [block [rowItem...]...]), then set it to `true`. Currently it supports only a two-level aggregation max (data->block->rowItem).\r\n * @prop {SortOrder} sortOrder - instance of {@link SortOrder}\r\n * @prop {TableColumns} columns - instance of {@link TableColumns} with a modified prototype (added `sortable:true` and `.sortable` to sortable columns)\r\n * @class SortTable\r\n * */\nvar SortTable = function () {\n  /**\r\n   *\r\n   *\r\n   *  */\n\n  function SortTable(options) {\n    var _ref,\n        _ref$sortOrder,\n        _this = this;\n\n    _classCallCheck(this, SortTable);\n\n    var source = options.source,\n        refSource = options.refSource,\n        _options$defaultHeade = options.defaultHeaderRow,\n        defaultHeaderRow = _options$defaultHeade === undefined ? -1 : _options$defaultHeade,\n        included = options.included,\n        excluded = options.excluded,\n        _options$defaultSorti = options.defaultSorting,\n        defaultSorting = _options$defaultSorti === undefined ? [] : _options$defaultSorti,\n        _options$data = options.data,\n        data = _options$data === undefined ? [] : _options$data,\n        _options$multidimensi = options.multidimensional,\n        multidimensional = _options$multidimensi === undefined ? false : _options$multidimensi;\n\n    this._sortEvent = _rReportalBase2.default.newEvent('reportal-table-sort');\n\n    if (source) {\n      this.source = source;\n    } else {\n      throw new Error('`source` table is not specified for SortTable');\n    }\n    this.data = data;\n    this.multidimensional = multidimensional;\n\n    //let tableColumns= new TableColumns({source, refSource, defaultHeaderRow});\n    var sortableColumns = SortTable.defineSortableColumns(new _tableColumns2.default({ source: source, refSource: refSource, defaultHeaderRow: defaultHeaderRow }), included, excluded);\n    this.columns = sortableColumns;\n    // setup sort order and do initial default sorting\n    this.sortOrder = (_ref = new _sortOrder2.default({ columns: sortableColumns, sortCallback: this.sort, sortCallbackScope: this, defaultSorting: defaultSorting }), _ref$sortOrder = _toArray(_ref.sortOrder), _ref);\n    [source, refSource].forEach(function (src) {\n      if (src) {\n        SortTable.listenForSort(_tableColumns2.default.getHeader(src), sortableColumns, _this.sortOrder);\n      }\n    }); // set up listeners for headers\n  }\n\n  /**\r\n   * Checks the table columns array against the `included`/`excluded` columns arrays and adds a `sortable:true` property and a `.sortable` class to the sortable ones\r\n   * @param {TableColumns} columns - an instance of {@link TableColumns}\r\n   * @param {Array} [included] - array of included columns indices\r\n   * @param {Array} [excluded] - array of excluded columns indices\r\n   * */\n\n\n  _createClass(SortTable, [{\n    key: \"sort\",\n\n\n    /**\r\n     * Performs channeling of sorting based on whether `this.data` is `multidimensional`\r\n     * @param {SortOrder} sortOrder - instance of {@link SortOrder} passed by the {@link SortOrder#sort} on initial sort\r\n     * @fires SortTable~reportal-table-sort\r\n     * */\n    value: function sort(sortOrder) {\n      var _this2 = this;\n\n      var so = sortOrder.sortOrder || this.sortOrder.sortOrder,\n          columns = this.columns;\n      if (so && so.length > 0) {\n        if (!this.multidimensional) {\n          SortTable.sortDimension(this.data, columns, so);\n        } else {\n          // if array has nested array blocks\n          this.data.forEach(function (dimension) {\n            SortTable.sortDimension(dimension, _this2.columns, so);\n          });\n        }\n        columns[so[0].column].cell.dispatchEvent(this._sortEvent);\n      }\n    }\n    /**\r\n     * Splits sorting into one-column or two-column. The precedence of columns in `sortOrder` is the factor defining sort priority\r\n     * @param {Array} data - array containing row items to be sorted\r\n     * @param {TableColumns} columns - array of table columns from {@link SortTable#defineSortableColumns}\r\n     * @param {SortOrder} sortOrder - instance of {@link SortOrder}\r\n     * */\n\n  }], [{\n    key: \"defineSortableColumns\",\n    value: function defineSortableColumns(columns, included, excluded) {\n      var sortableColumns = [].slice.call(columns);\n      sortableColumns.forEach(function (column, index) {\n        var sortable = !included && !excluded || included && included.indexOf(index) != -1 || excluded && excluded.indexOf(index) == -1;\n        if (sortable) {\n          column.cell.classList.add('sortable');\n          if (column.refCell) {\n            column.refCell.classList.add('sortable');\n          }\n          column.sortable = true;\n        }\n      });\n      return sortableColumns;\n    }\n\n    /**\r\n     * sets up listeners for column headers available for click\r\n     * @param {HTMLElement} delegatedTarget - element that will receive clicks and see if they are valid, `thead` is recommended to boil down to header clicks only\r\n     * @param {TableColumns} columns - array of table columns from {@link SortTable#defineSortableColumns}\r\n     * @param {SortOrder} sortOrder - instance of {@link SortOrder}\r\n     * @listens click\r\n     * */\n\n  }, {\n    key: \"listenForSort\",\n    value: function listenForSort(delegatedTarget, columns, sortOrder) {\n      delegatedTarget.addEventListener('click', function (e) {\n        // if it's a table cell, is in columns array and is sortable\n        var clickedColumn = void 0;\n        for (var i = 0; i < columns.length; i++) {\n          if (e.target == columns[i].cell || e.target == columns[i].refCell) {\n            clickedColumn = columns[i];break;\n          }\n        }\n        if ((e.target.tagName == 'TD' || e.target.tagName == 'TH') && clickedColumn.sortable) {\n          sortOrder.replace({ column: columns.indexOf(clickedColumn), direction: e.target.classList.contains('asc') ? 'desc' : 'asc' });\n        }\n      });\n    }\n  }, {\n    key: \"sortDimension\",\n    value: function sortDimension(data, columns, sortOrder) {\n      var getIndex = function getIndex(i) {\n        return columns[sortOrder[i].column].index;\n      };\n      var getDirection = function getDirection(i) {\n        return sortOrder[i].direction === 'desc' ? -1 : 1;\n      };\n      // TODO: add possibility to sort the data that was stripped by column.\n      data.sort(function (a, b) {\n        // sort rows\n        if (sortOrder.length == 1) {\n          //sort one column only\n          return SortTable.sorter(a[getIndex(0)], b[getIndex(0)], getDirection(0));\n        } else {\n          //sort against two columns\n          return SortTable.sorter(a[getIndex(0)], b[getIndex(0)], getDirection(0)) || SortTable.sorter(a[getIndex(1)], b[getIndex(1)], getDirection(1));\n        }\n      });\n    }\n\n    /**\r\n     * Function that performs case insensitive sorting in the array. It can distinguish between numbers, numbers as strings, HTML and plain strings\r\n     * */\n\n  }, {\n    key: \"sorter\",\n    value: function sorter(a, b, lesser) {\n      var regex = /[<>]/g;\n      if (regex.test(a) || regex.test(b)) {\n        // if we need to sort elements that have HTML like links\n        var tempEl1 = document.createElement('span');tempEl1.innerHTML = a;\n        a = tempEl1.textContent.trim();\n        var tempEl2 = document.createElement('span');tempEl2.innerHTML = b;\n        b = tempEl2.textContent.trim();\n      }\n      if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) == 'object' && _typeof(a.data) != undefined) {\n        a = a.data;\n      }\n      if ((typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) == 'object' && _typeof(b.data) != undefined) {\n        b = b.data;\n      }\n      if (!isNaN(a) && !isNaN(b)) {\n        //they might be numbers or null\n        if (a === null) {\n          return 1;\n        } else if (b === null) {\n          return -1;\n        }\n        return a < b ? lesser : a > b ? -lesser : 0;\n      } else if (!isNaN(parseFloat(a)) && !isNaN(parseFloat(b))) {\n        // they might be number strings\n        return parseFloat(a) < parseFloat(b) ? lesser : parseFloat(a) > parseFloat(b) ? -lesser : 0;\n      } else {\n        //they might be simple strings\n        return a.toLowerCase() < b.toLowerCase() ? lesser : a.toLowerCase() > b.toLowerCase() ? -lesser : 0;\n      }\n    }\n  }]);\n\n  return SortTable;\n}();\n\nexports.default = SortTable;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Itc29ydC10YWJsZS9zcmMvc29ydC10YWJsZS5qcz83MDc4Il0sIm5hbWVzIjpbIlNvcnRUYWJsZSIsIm9wdGlvbnMiLCJzb3VyY2UiLCJyZWZTb3VyY2UiLCJkZWZhdWx0SGVhZGVyUm93IiwiaW5jbHVkZWQiLCJleGNsdWRlZCIsImRlZmF1bHRTb3J0aW5nIiwiZGF0YSIsIm11bHRpZGltZW5zaW9uYWwiLCJfc29ydEV2ZW50IiwibmV3RXZlbnQiLCJFcnJvciIsInNvcnRhYmxlQ29sdW1ucyIsImRlZmluZVNvcnRhYmxlQ29sdW1ucyIsImNvbHVtbnMiLCJzb3J0T3JkZXIiLCJzb3J0Q2FsbGJhY2siLCJzb3J0Iiwic29ydENhbGxiYWNrU2NvcGUiLCJmb3JFYWNoIiwic3JjIiwibGlzdGVuRm9yU29ydCIsImdldEhlYWRlciIsInNvIiwibGVuZ3RoIiwic29ydERpbWVuc2lvbiIsImRpbWVuc2lvbiIsImNvbHVtbiIsImNlbGwiLCJkaXNwYXRjaEV2ZW50Iiwic2xpY2UiLCJjYWxsIiwiaW5kZXgiLCJzb3J0YWJsZSIsImluZGV4T2YiLCJjbGFzc0xpc3QiLCJhZGQiLCJyZWZDZWxsIiwiZGVsZWdhdGVkVGFyZ2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImNsaWNrZWRDb2x1bW4iLCJpIiwiZSIsInRhcmdldCIsInRhZ05hbWUiLCJyZXBsYWNlIiwiZGlyZWN0aW9uIiwiY29udGFpbnMiLCJnZXRJbmRleCIsImdldERpcmVjdGlvbiIsImEiLCJiIiwic29ydGVyIiwibGVzc2VyIiwicmVnZXgiLCJ0ZXN0IiwidGVtcEVsMSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsInRleHRDb250ZW50IiwidHJpbSIsInRlbXBFbDIiLCJ1bmRlZmluZWQiLCJpc05hTiIsInBhcnNlRmxvYXQiLCJ0b0xvd2VyQ2FzZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7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QUFSO0FBQVU7QUFDcEQsZUFBT0QsSUFBS0MsQ0FBTCxHQUFTRSxNQUFULEdBQW1CSCxJQUFLQyxDQUFMLEdBQVMsQ0FBQ0UsTUFBVixHQUFtQixDQUE3QztBQUNELE9BSEQsTUFJSyxJQUFHLENBQUNXLE1BQU1DLFdBQVdmLENBQVgsQ0FBTixDQUFELElBQXlCLENBQUNjLE1BQU1DLFdBQVdkLENBQVgsQ0FBTixDQUE3QixFQUFrRDtBQUFFO0FBQ3ZELGVBQU9jLFdBQVdmLENBQVgsSUFBaUJlLFdBQVdkLENBQVgsQ0FBakIsR0FBaUNFLE1BQWpDLEdBQTJDWSxXQUFXZixDQUFYLElBQWlCZSxXQUFXZCxDQUFYLENBQWpCLEdBQWlDLENBQUNFLE1BQWxDLEdBQTJDLENBQTdGO0FBQ0QsT0FGSSxNQUVFO0FBQUU7QUFDUCxlQUFPSCxFQUFFZ0IsV0FBRixLQUFrQmYsRUFBRWUsV0FBRixFQUFsQixHQUFvQ2IsTUFBcEMsR0FBNkNILEVBQUVnQixXQUFGLEtBQWtCZixFQUFFZSxXQUFGLEVBQWxCLEdBQW9DLENBQUNiLE1BQXJDLEdBQThDLENBQWxHO0FBQ0Q7QUFDRjs7Ozs7O2tCQUlZdEQsUyIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlcG9ydGFsQmFzZSBmcm9tIFwici1yZXBvcnRhbC1iYXNlXCI7XHJcbmltcG9ydCBUYWJsZUNvbHVtbnMgZnJvbSBcIi4vdGFibGUtY29sdW1uc1wiO1xyXG5pbXBvcnQgU29ydE9yZGVyIGZyb20gXCIuL3NvcnQtb3JkZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBFdmVudCByZXBvcnRpbmcgdGhhdCBhIHRhYmxlIGhhcyBiZWVuIHNvcnRlZFxyXG4gKiBAZXZlbnQgU29ydFRhYmxlfnJlcG9ydGFsLXRhYmxlLXNvcnRcclxuICovXHJcblxyXG4vKipcclxuICogTWFrZXMgYSB0YWJsZSBzb3J0YWJsZSwgZ2l2ZXMgQVBJIGZvciBzb3J0aW5nLiBJdCBzb3J0cyBgZGF0YWAgYXJyYXksIGJ1dCBkb2Vzbid0IG1vdmUgcm93cyBpbiB0aGUgYHNvdXJjZWAgdGFibGUsIGJlY2F1c2Ugb2YgZGlmZmVyZW5jZXMgaW4gaW1wbGVtZW50YXRpb24uXHJcbiAqXHJcbiAqID4gTm90ZTogSXQncyBpbXBvcnRhbnQgdGhhdCBldmVyeSBBcnJheSBpdGVtIHRoYXQgaXMgZ29pbmcgdG8gYmUgc29ydGFibGUgd2FzIGVpdGhlciBhIGBTdHJpbmdgLCBhIGBOdW1iZXJgLCBhIGBudWxsYCwgb3IgYW4gYE9iamVjdGAgdGhhdCBjb250YWluZWQgYGRhdGFgIHByb3BlcnR5ICh3aGljaCB3YXMgb2YgdGhlIHByZXZpb3VzbHkgbmFtZWQgdHlwZXMpXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBwYXNzZWQgdG8gY29uZmlndXJlIHRoZSBTb3J0aW5nXHJcbiAqIEBwYXJhbSB7SFRNTFRhYmxlRWxlbWVudH0gb3B0aW9ucy5zb3VyY2UgLSBzb3VyY2UgdGFibGUgc29ydGluZyB3aWxsIGJlIGFwcGxpZWQgdG9cclxuICogQHBhcmFtIHtIVE1MVGFibGVFbGVtZW50fSBbb3B0aW9ucy5yZWZTb3VyY2VdIC0gdGhlIGZsb2F0aW5nIGhlYWRlciBpZiBhbnksIHdpbGwgcmVmbGVjdCBhbmQgdHJpZ2dlciBzb3J0aW5nIG9uIGhlYWRlciB3aGVuIHNjcm9sbGVkLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGVmYXVsdEhlYWRlclJvdz0tMV0gLSBpbmRleCBvZiB0aGUgcm93IGluIGB0aGVhZGAgKGluY3JlbWVudGVkIGZyb20gMCkgdGhhdCB3aWxsIGhhdmUgc29ydGluZyBlbmFibGVkIGZvciBjb2x1bW5zLiBJZiBgLTFgIHRoZW4gbGFzdCByb3cuXHJcbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmluY2x1ZGVkXSAtIEFycmF5IG9mIGNvbHVtbiBpbmRpY2VzIChpbmNyZW1lbnRlZCBmcm9tIDApIHRoYXQgd2lsbCBoYXZlIHNvcnRpbmcgZW5hYmxlZC4gSWYgbm90IHNwZWNpZmllZCwgYWxsIGNvbHVtbnMgd2lsbCBiZSBzb3J0YWJsZS4gT3B0aW9uYWxseSBgZXhjbHVkZWRgIGNhbiBiZSBzcGVjaWZpZWQgaW5zdGVhZCBhcyBhIHNob3J0aGFuZCB0byBwYXNzIG9ubHkgaW5kaWNlcyBvZiBjb2x1bW5zIHRvIGJlIGV4Y2x1ZGVkIGZyb20gc29ydGluZywgYXNzdW1uaW5nIHRoYXQgb3RoZXJzIHdpbGwgYmUgbWFkZSBzb3J0YWJsZS4gSXQncyBpbXBvcnRhbnQgdG8gY291bnQgdGhlIGNvbHVtbiBpbmRleCBpbiB0aGUgZGVmYXVsdEhlYWRlclJvd1xyXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5leGNsdWRlZF0gLSBBcnJheSBvZiBjb2x1bW4gaW5kaWNlcyAoaW5jcmVtZW50ZWQgZnJvbSAwKSB0aGF0IHdpbGwgYmUgZXhjbHVkZWQgZnJvbSBzb3J0aW5nLiBDYW4gYmUgdXNlZCBhcyBhIHNob3J0aGFuZCBpbnN0ZWFkIG9mIGBpbmNsdWRlZGAuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5kZWZhdWx0U29ydGluZ10gLSBhbiBhcnJheSBvZiBvYmplY3RzIHRoYXQgc3BlY2lmeSBkZWZhdWx0IHNvcnRpbmdcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVmYXVsdFNvcnRpbmcuY29sdW1uIC0gY29sdW1uIGluZGV4XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmRlZmF1bHRTb3J0aW5nLmRpcmVjdGlvbiAtIHNvcnQgZGlyZWN0aW9uIChgYXNjYHxgZGVzY2ApXHJcbiAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbnMuZGF0YSAtIGRhdGEgd2l0aCBpbmZvcm1hdGlvbiBmb3Igcm93cyB0byBiZSBzb3J0ZWRcclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tdWx0aWRpbWVuc2lvbmFsPWZhbHNlXSAtIGlmIGBkYXRhYCBpcyBzaW5nbGUtZGltZW5zaW9uYWwgKGNvbnRhaW5zIHJvd3Mgd2l0aCBkYXRhIHRvIGJlIHNvcnRlZCBhcyBpbW1lZGlhdGUgYXJyYXkgaXRlbXM6IGBkYXRhIFtyb3dJdGVtLi4uXWApLCB0aGVuIGl0IGlzIGBmYWxzZWAuIElmIGl0IGhhcyBibG9ja3Mgb2YgZGF0YSBhcyBpdGVtcyAoZWFjaCBibG9jayBjb250YWluaW5nIGFuIGFycmF5IG9mIHJvd3MgdG8gYmUgc29ydGVkOiBkYXRhIFtibG9jayBbcm93SXRlbS4uLl0uLi5dKSwgdGhlbiBzZXQgaXQgdG8gYHRydWVgLiBDdXJyZW50bHkgaXQgc3VwcG9ydHMgb25seSBhIHR3by1sZXZlbCBhZ2dyZWdhdGlvbiBtYXggKGRhdGEtPmJsb2NrLT5yb3dJdGVtKS5cclxuICogQHByb3Age0hUTUxUYWJsZUVsZW1lbnR9IHNvdXJjZSAtIHNvdXJjZSB0YWJsZVxyXG4gKiBAcHJvcCB7QXJyYXl9IGRhdGEgLSBkYXRhIGFycmF5IHRvIGJlIHNvcnRlZFxyXG4gKiBAcHJvcCB7Qm9vbGVhbn0gbXVsdGlkaW1lbnNpb25hbCAtIGlmIGBkYXRhYCBpcyBtb25vLWRpbWVuc2lvbmFsIChjb250YWlucyByb3dzIHdpdGggZGF0YSB0byBiZSBzb3J0ZWQgYXMgaW1tZWRpYXRlIGFycmF5IGl0ZW1zOiBgZGF0YSBbcm93SXRlbS4uLl1gKSwgdGhlbiBpdCBpcyBgZmFsc2VgLiBJZiBpdCBoYXMgYmxvY2tzIG9mIGRhdGEgYXMgaXRlbXMgKGVhY2ggYmxvY2sgY29udGFpbmluZyBhbiBhcnJheSBvZiByb3dzIHRvIGJlIHNvcnRlZDogZGF0YSBbYmxvY2sgW3Jvd0l0ZW0uLi5dLi4uXSksIHRoZW4gc2V0IGl0IHRvIGB0cnVlYC4gQ3VycmVudGx5IGl0IHN1cHBvcnRzIG9ubHkgYSB0d28tbGV2ZWwgYWdncmVnYXRpb24gbWF4IChkYXRhLT5ibG9jay0+cm93SXRlbSkuXHJcbiAqIEBwcm9wIHtTb3J0T3JkZXJ9IHNvcnRPcmRlciAtIGluc3RhbmNlIG9mIHtAbGluayBTb3J0T3JkZXJ9XHJcbiAqIEBwcm9wIHtUYWJsZUNvbHVtbnN9IGNvbHVtbnMgLSBpbnN0YW5jZSBvZiB7QGxpbmsgVGFibGVDb2x1bW5zfSB3aXRoIGEgbW9kaWZpZWQgcHJvdG90eXBlIChhZGRlZCBgc29ydGFibGU6dHJ1ZWAgYW5kIGAuc29ydGFibGVgIHRvIHNvcnRhYmxlIGNvbHVtbnMpXHJcbiAqIEBjbGFzcyBTb3J0VGFibGVcclxuICogKi9cclxuY2xhc3MgU29ydFRhYmxlIHtcclxuICAvKipcclxuICAgKlxyXG4gICAqXHJcbiAgICogICovXHJcblxyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpe1xyXG4gICAgbGV0IHtzb3VyY2UscmVmU291cmNlLGRlZmF1bHRIZWFkZXJSb3c9LTEsaW5jbHVkZWQsZXhjbHVkZWQsZGVmYXVsdFNvcnRpbmc9W10sZGF0YT1bXSxtdWx0aWRpbWVuc2lvbmFsPWZhbHNlfT1vcHRpb25zO1xyXG4gICAgdGhpcy5fc29ydEV2ZW50ID0gUmVwb3J0YWxCYXNlLm5ld0V2ZW50KCdyZXBvcnRhbC10YWJsZS1zb3J0Jyk7XHJcblxyXG4gICAgICBpZihzb3VyY2Upe1xyXG4gICAgICAgIHRoaXMuc291cmNlPXNvdXJjZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bzb3VyY2VgIHRhYmxlIGlzIG5vdCBzcGVjaWZpZWQgZm9yIFNvcnRUYWJsZScpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgIHRoaXMubXVsdGlkaW1lbnNpb25hbCA9IG11bHRpZGltZW5zaW9uYWw7XHJcblxyXG4gICAgICAvL2xldCB0YWJsZUNvbHVtbnM9IG5ldyBUYWJsZUNvbHVtbnMoe3NvdXJjZSwgcmVmU291cmNlLCBkZWZhdWx0SGVhZGVyUm93fSk7XHJcbiAgICAgIGxldCBzb3J0YWJsZUNvbHVtbnM9U29ydFRhYmxlLmRlZmluZVNvcnRhYmxlQ29sdW1ucyhuZXcgVGFibGVDb2x1bW5zKHtzb3VyY2UsIHJlZlNvdXJjZSwgZGVmYXVsdEhlYWRlclJvd30pLCBpbmNsdWRlZCwgZXhjbHVkZWQpO1xyXG4gICAgICB0aGlzLmNvbHVtbnMgPSBzb3J0YWJsZUNvbHVtbnM7XHJcbiAgICAgIC8vIHNldHVwIHNvcnQgb3JkZXIgYW5kIGRvIGluaXRpYWwgZGVmYXVsdCBzb3J0aW5nXHJcbiAgICAgIHRoaXMuc29ydE9yZGVyID0ge3NvcnRPcmRlcjpbXX0gPSBuZXcgU29ydE9yZGVyKHtjb2x1bW5zOnNvcnRhYmxlQ29sdW1ucywgc29ydENhbGxiYWNrOnRoaXMuc29ydCwgc29ydENhbGxiYWNrU2NvcGU6dGhpcywgZGVmYXVsdFNvcnRpbmd9KTtcclxuICAgICAgW3NvdXJjZSxyZWZTb3VyY2VdLmZvckVhY2goc3JjPT57aWYoc3JjKXtTb3J0VGFibGUubGlzdGVuRm9yU29ydChUYWJsZUNvbHVtbnMuZ2V0SGVhZGVyKHNyYyksc29ydGFibGVDb2x1bW5zLCB0aGlzLnNvcnRPcmRlcil9fSk7Ly8gc2V0IHVwIGxpc3RlbmVycyBmb3IgaGVhZGVyc1xyXG5cclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgdGhlIHRhYmxlIGNvbHVtbnMgYXJyYXkgYWdhaW5zdCB0aGUgYGluY2x1ZGVkYC9gZXhjbHVkZWRgIGNvbHVtbnMgYXJyYXlzIGFuZCBhZGRzIGEgYHNvcnRhYmxlOnRydWVgIHByb3BlcnR5IGFuZCBhIGAuc29ydGFibGVgIGNsYXNzIHRvIHRoZSBzb3J0YWJsZSBvbmVzXHJcbiAgICogQHBhcmFtIHtUYWJsZUNvbHVtbnN9IGNvbHVtbnMgLSBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgVGFibGVDb2x1bW5zfVxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtpbmNsdWRlZF0gLSBhcnJheSBvZiBpbmNsdWRlZCBjb2x1bW5zIGluZGljZXNcclxuICAgKiBAcGFyYW0ge0FycmF5fSBbZXhjbHVkZWRdIC0gYXJyYXkgb2YgZXhjbHVkZWQgY29sdW1ucyBpbmRpY2VzXHJcbiAgICogKi9cclxuICBzdGF0aWMgZGVmaW5lU29ydGFibGVDb2x1bW5zKGNvbHVtbnMsIGluY2x1ZGVkLCBleGNsdWRlZCl7XHJcbiAgICBsZXQgc29ydGFibGVDb2x1bW5zID0gW10uc2xpY2UuY2FsbChjb2x1bW5zKTtcclxuICAgIHNvcnRhYmxlQ29sdW1ucy5mb3JFYWNoKChjb2x1bW4saW5kZXgpPT57XHJcbiAgICAgIGxldCBzb3J0YWJsZT0oKCFpbmNsdWRlZCAmJiAhZXhjbHVkZWQpIHx8IChpbmNsdWRlZCAmJiBpbmNsdWRlZC5pbmRleE9mKGluZGV4KSE9LTEpIHx8IChleGNsdWRlZCAmJiBleGNsdWRlZC5pbmRleE9mKGluZGV4KT09LTEpKTtcclxuICAgICAgaWYoc29ydGFibGUpe1xyXG4gICAgICAgIGNvbHVtbi5jZWxsLmNsYXNzTGlzdC5hZGQoJ3NvcnRhYmxlJyk7XHJcbiAgICAgICAgaWYoY29sdW1uLnJlZkNlbGwpe2NvbHVtbi5yZWZDZWxsLmNsYXNzTGlzdC5hZGQoJ3NvcnRhYmxlJyk7fVxyXG4gICAgICAgIGNvbHVtbi5zb3J0YWJsZSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHNvcnRhYmxlQ29sdW1uc1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogc2V0cyB1cCBsaXN0ZW5lcnMgZm9yIGNvbHVtbiBoZWFkZXJzIGF2YWlsYWJsZSBmb3IgY2xpY2tcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkZWxlZ2F0ZWRUYXJnZXQgLSBlbGVtZW50IHRoYXQgd2lsbCByZWNlaXZlIGNsaWNrcyBhbmQgc2VlIGlmIHRoZXkgYXJlIHZhbGlkLCBgdGhlYWRgIGlzIHJlY29tbWVuZGVkIHRvIGJvaWwgZG93biB0byBoZWFkZXIgY2xpY2tzIG9ubHlcclxuICAgKiBAcGFyYW0ge1RhYmxlQ29sdW1uc30gY29sdW1ucyAtIGFycmF5IG9mIHRhYmxlIGNvbHVtbnMgZnJvbSB7QGxpbmsgU29ydFRhYmxlI2RlZmluZVNvcnRhYmxlQ29sdW1uc31cclxuICAgKiBAcGFyYW0ge1NvcnRPcmRlcn0gc29ydE9yZGVyIC0gaW5zdGFuY2Ugb2Yge0BsaW5rIFNvcnRPcmRlcn1cclxuICAgKiBAbGlzdGVucyBjbGlja1xyXG4gICAqICovXHJcbiAgc3RhdGljIGxpc3RlbkZvclNvcnQoZGVsZWdhdGVkVGFyZ2V0LCBjb2x1bW5zLCBzb3J0T3JkZXIpe1xyXG4gICAgZGVsZWdhdGVkVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxlPT57XHJcbiAgICAgIC8vIGlmIGl0J3MgYSB0YWJsZSBjZWxsLCBpcyBpbiBjb2x1bW5zIGFycmF5IGFuZCBpcyBzb3J0YWJsZVxyXG4gICAgICBsZXQgY2xpY2tlZENvbHVtbjtcclxuICAgICAgZm9yKGxldCBpPTA7aTxjb2x1bW5zLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIGlmKGUudGFyZ2V0PT1jb2x1bW5zW2ldLmNlbGwgfHwgZS50YXJnZXQ9PWNvbHVtbnNbaV0ucmVmQ2VsbCl7XHJcbiAgICAgICAgICBjbGlja2VkQ29sdW1uPSBjb2x1bW5zW2ldOyBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYoKGUudGFyZ2V0LnRhZ05hbWUgPT0gJ1REJyB8fCBlLnRhcmdldC50YWdOYW1lID09ICdUSCcpICYmIGNsaWNrZWRDb2x1bW4uc29ydGFibGUpe1xyXG4gICAgICAgIHNvcnRPcmRlci5yZXBsYWNlKHtjb2x1bW46Y29sdW1ucy5pbmRleE9mKGNsaWNrZWRDb2x1bW4pLCBkaXJlY3Rpb246IGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYXNjJyk/J2Rlc2MnOidhc2MnfSk7XHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUGVyZm9ybXMgY2hhbm5lbGluZyBvZiBzb3J0aW5nIGJhc2VkIG9uIHdoZXRoZXIgYHRoaXMuZGF0YWAgaXMgYG11bHRpZGltZW5zaW9uYWxgXHJcbiAgICogQHBhcmFtIHtTb3J0T3JkZXJ9IHNvcnRPcmRlciAtIGluc3RhbmNlIG9mIHtAbGluayBTb3J0T3JkZXJ9IHBhc3NlZCBieSB0aGUge0BsaW5rIFNvcnRPcmRlciNzb3J0fSBvbiBpbml0aWFsIHNvcnRcclxuICAgKiBAZmlyZXMgU29ydFRhYmxlfnJlcG9ydGFsLXRhYmxlLXNvcnRcclxuICAgKiAqL1xyXG4gIHNvcnQoc29ydE9yZGVyKXtcclxuICAgIGxldCBzbyA9IHNvcnRPcmRlci5zb3J0T3JkZXIgfHwgdGhpcy5zb3J0T3JkZXIuc29ydE9yZGVyLFxyXG4gICAgICBjb2x1bW5zID0gdGhpcy5jb2x1bW5zO1xyXG4gICAgaWYoc28gJiYgc28ubGVuZ3RoPjApe1xyXG4gICAgICBpZighdGhpcy5tdWx0aWRpbWVuc2lvbmFsKXtcclxuICAgICAgICBTb3J0VGFibGUuc29ydERpbWVuc2lvbih0aGlzLmRhdGEsIGNvbHVtbnMsIHNvKTtcclxuICAgICAgfSBlbHNlIHsgLy8gaWYgYXJyYXkgaGFzIG5lc3RlZCBhcnJheSBibG9ja3NcclxuICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaChkaW1lbnNpb249PntcclxuICAgICAgICAgIFNvcnRUYWJsZS5zb3J0RGltZW5zaW9uKGRpbWVuc2lvbiwgdGhpcy5jb2x1bW5zLCBzbyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgY29sdW1uc1tzb1swXS5jb2x1bW5dLmNlbGwuZGlzcGF0Y2hFdmVudCh0aGlzLl9zb3J0RXZlbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBTcGxpdHMgc29ydGluZyBpbnRvIG9uZS1jb2x1bW4gb3IgdHdvLWNvbHVtbi4gVGhlIHByZWNlZGVuY2Ugb2YgY29sdW1ucyBpbiBgc29ydE9yZGVyYCBpcyB0aGUgZmFjdG9yIGRlZmluaW5nIHNvcnQgcHJpb3JpdHlcclxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIC0gYXJyYXkgY29udGFpbmluZyByb3cgaXRlbXMgdG8gYmUgc29ydGVkXHJcbiAgICogQHBhcmFtIHtUYWJsZUNvbHVtbnN9IGNvbHVtbnMgLSBhcnJheSBvZiB0YWJsZSBjb2x1bW5zIGZyb20ge0BsaW5rIFNvcnRUYWJsZSNkZWZpbmVTb3J0YWJsZUNvbHVtbnN9XHJcbiAgICogQHBhcmFtIHtTb3J0T3JkZXJ9IHNvcnRPcmRlciAtIGluc3RhbmNlIG9mIHtAbGluayBTb3J0T3JkZXJ9XHJcbiAgICogKi9cclxuICBzdGF0aWMgc29ydERpbWVuc2lvbihkYXRhLGNvbHVtbnMsc29ydE9yZGVyKXtcclxuICAgIGxldCBnZXRJbmRleCA9IChpKT0+e3JldHVybiBjb2x1bW5zW3NvcnRPcmRlcltpXS5jb2x1bW5dLmluZGV4fTtcclxuICAgIGxldCBnZXREaXJlY3Rpb249KGkpPT57cmV0dXJuIHNvcnRPcmRlcltpXS5kaXJlY3Rpb24gPT09ICdkZXNjJyA/IC0xIDogMX07XHJcbiAgICAvLyBUT0RPOiBhZGQgcG9zc2liaWxpdHkgdG8gc29ydCB0aGUgZGF0YSB0aGF0IHdhcyBzdHJpcHBlZCBieSBjb2x1bW4uXHJcbiAgICBkYXRhLnNvcnQoKGEsIGIpPT57IC8vIHNvcnQgcm93c1xyXG4gICAgICBpZihzb3J0T3JkZXIubGVuZ3RoPT0xKXsgLy9zb3J0IG9uZSBjb2x1bW4gb25seVxyXG4gICAgICAgIHJldHVybiBTb3J0VGFibGUuc29ydGVyKCBhW2dldEluZGV4KDApXSwgYltnZXRJbmRleCgwKV0sIGdldERpcmVjdGlvbigwKSApXHJcbiAgICAgIH0gZWxzZSB7IC8vc29ydCBhZ2FpbnN0IHR3byBjb2x1bW5zXHJcbiAgICAgICAgcmV0dXJuIFNvcnRUYWJsZS5zb3J0ZXIoIGFbZ2V0SW5kZXgoMCldLCBiW2dldEluZGV4KDApXSwgZ2V0RGlyZWN0aW9uKDApICkgfHwgU29ydFRhYmxlLnNvcnRlciggYVtnZXRJbmRleCgxKV0sIGJbZ2V0SW5kZXgoMSldLCBnZXREaXJlY3Rpb24oMSkgKVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgY2FzZSBpbnNlbnNpdGl2ZSBzb3J0aW5nIGluIHRoZSBhcnJheS4gSXQgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW4gbnVtYmVycywgbnVtYmVycyBhcyBzdHJpbmdzLCBIVE1MIGFuZCBwbGFpbiBzdHJpbmdzXHJcbiAgICogKi9cclxuICBzdGF0aWMgc29ydGVyKGEsYixsZXNzZXIpe1xyXG4gICAgbGV0IHJlZ2V4ID0gL1s8Pl0vZztcclxuICAgIGlmKHJlZ2V4LnRlc3QoYSkgfHwgcmVnZXgudGVzdChiKSl7IC8vIGlmIHdlIG5lZWQgdG8gc29ydCBlbGVtZW50cyB0aGF0IGhhdmUgSFRNTCBsaWtlIGxpbmtzXHJcbiAgICAgIGxldCB0ZW1wRWwxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpOyB0ZW1wRWwxLmlubmVySFRNTCA9IGE7XHJcbiAgICAgIGE9dGVtcEVsMS50ZXh0Q29udGVudC50cmltKCk7XHJcbiAgICAgIGxldCB0ZW1wRWwyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpOyB0ZW1wRWwyLmlubmVySFRNTCA9IGI7XHJcbiAgICAgIGI9dGVtcEVsMi50ZXh0Q29udGVudC50cmltKCk7XHJcbiAgICB9XHJcbiAgICBpZih0eXBlb2YgYT09J29iamVjdCcgJiYgdHlwZW9mIGEuZGF0YSAhPSB1bmRlZmluZWQpe2E9YS5kYXRhfVxyXG4gICAgaWYodHlwZW9mIGI9PSdvYmplY3QnICYmIHR5cGVvZiBiLmRhdGEgIT0gdW5kZWZpbmVkKXtiPWIuZGF0YX1cclxuICAgIGlmKCFpc05hTihhKSAmJiAhaXNOYU4oYikpeyAvL3RoZXkgbWlnaHQgYmUgbnVtYmVycyBvciBudWxsXHJcbiAgICAgIGlmKGE9PT1udWxsKXtyZXR1cm4gMX0gZWxzZSBpZiAoYj09PW51bGwpe3JldHVybiAtMX1cclxuICAgICAgcmV0dXJuIGEgPCAgYiA/IGxlc3NlciA6ICBhID4gIGIgPyAtbGVzc2VyIDogMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYoIWlzTmFOKHBhcnNlRmxvYXQoYSkpICYmICFpc05hTihwYXJzZUZsb2F0KGIpKSl7IC8vIHRoZXkgbWlnaHQgYmUgbnVtYmVyIHN0cmluZ3NcclxuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYSkgPCAgcGFyc2VGbG9hdChiKSA/IGxlc3NlciA6ICBwYXJzZUZsb2F0KGEpID4gIHBhcnNlRmxvYXQoYikgPyAtbGVzc2VyIDogMDtcclxuICAgIH0gZWxzZSB7IC8vdGhleSBtaWdodCBiZSBzaW1wbGUgc3RyaW5nc1xyXG4gICAgICByZXR1cm4gYS50b0xvd2VyQ2FzZSgpIDwgYi50b0xvd2VyQ2FzZSgpID8gbGVzc2VyIDogYS50b0xvd2VyQ2FzZSgpID4gYi50b0xvd2VyQ2FzZSgpID8gLWxlc3NlciA6IDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU29ydFRhYmxlXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vci1zb3J0LXRhYmxlL3NyYy9zb3J0LXRhYmxlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 9 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Created by IvanP on 09.09.2016.\r\n */\n\nvar TableColumns = function () {\n  /**\r\n   * Creates an array of objects corresponding to the cells of `defaultHeaderRow`, that contain `sortable` property, denoting the column is sortable,\r\n   * `index` of the column and reference to the `cell`. Adds `.sortable` to a sortable cell\r\n   * @param {Object} options - options passed to configure the Sorting\r\n   * @param {HTMLTableElement} options.source - source table sorting will be applied to\r\n   * @param {HTMLTableElement} options.refSource - floating header if any\r\n   * @param {Number|Object} [options.defaultHeaderRow=-1] - index of the row in `thead` (incremented from 0) that will have sorting enabled for columns. If `-1` then last row.\r\n   * @return {{index:Number, title:String, colSpan:Number, cell: HTMLTableCellElement, ?refCell:HTMLTableCellElement}} - an array of objects that have this structure\r\n   * */\n  function TableColumns(options) {\n    _classCallCheck(this, TableColumns);\n\n    var source = options.source,\n        refSource = options.refSource,\n        _options$defaultHeade = options.defaultHeaderRow,\n        defaultHeaderRow = _options$defaultHeade === undefined ? -1 : _options$defaultHeade;\n\n    var thead = void 0,\n        refThead = void 0;\n    if (source) {\n      thead = TableColumns.getHeader(source);\n    } else {\n      throw new TypeError('`source` table is not specified, cannot create TableColumns');\n    }\n    if (refSource) {\n      refThead = TableColumns.getHeader(refSource);\n    }\n    return TableColumns.computeColumns(thead, refThead, defaultHeaderRow);\n  }\n\n  /**\r\n   * Gets a header\r\n   * @param {HTMLTableElement} source - source table headers are created for\r\n   * */\n\n\n  _createClass(TableColumns, null, [{\n    key: 'getHeader',\n    value: function getHeader(source) {\n      if (source && source.tagName == 'TABLE') {\n        var header = source.querySelector(\"thead\");\n        if (header && header.children.length > 0) {\n          return header;\n        } else {\n          throw new TypeError('`source` table has no header or rows');\n        }\n      } else {\n        throw new TypeError('`source` is not specified or is not a table');\n      }\n    }\n\n    /**\r\n     * Calculates defaultHeaderRow for a passed `thead`\r\n     * @param {!HTMLTableElement} thead - source table header\r\n     * @param {!Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n     * @return {{index:Number, row: HTMLTableRowElement}}\r\n     * */\n\n  }, {\n    key: 'getDefaultHeaderRow',\n    value: function getDefaultHeaderRow(thead, defaultHeaderRowIndex) {\n      // calculate default header row\n      var headerRows = thead.children,\n          headerRowIndex = defaultHeaderRowIndex == -1 ? headerRows.length + defaultHeaderRowIndex : defaultHeaderRowIndex;\n      return {\n        index: headerRowIndex,\n        row: headerRows.item(headerRowIndex)\n      };\n    }\n\n    /**\r\n     * Gets an array of header cell nodes from default header row\r\n     * @param {?HTMLTableElement} thead - source table header\r\n     * @param {!Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n     * @return {?Array} Returns an array of header cell nodes or null if `thead` is not specified\r\n     * */\n\n  }, {\n    key: 'getHeaderCells',\n    value: function getHeaderCells(thead, defaultHeaderRowIndex) {\n      if (thead) {\n        if (defaultHeaderRowIndex != null) {\n          var _ret = function () {\n            var defaultHeaderRow = TableColumns.getDefaultHeaderRow(thead, defaultHeaderRowIndex);\n            var headerRows = thead.children;\n            var rowsLength = headerRows.length;\n            var abstr = {};\n\n            var _loop = function _loop(r) {\n              var row = headerRows.item(r);\n              var augmentIndex = 0; // index that will account for colSpan of upper rows' cells\n              [].slice.call(row.children).forEach(function (cell, index) {\n                //iterate through cells\n                for (var rs = 0; rs <= cell.rowSpan - 1; rs++) {\n                  //spread cell across its rowspan\n                  var rowA = abstr[r + rs] = abstr[r + rs] || {}; //create row if not exists\n                  if (!rowA[augmentIndex]) {\n                    //insert cell into slot if not filled\n                    rowA[augmentIndex] = cell;\n                  } else {\n                    //if filled look for the next empty because rowspanned columns fill them in a linear way\n                    var i = 0;\n                    while (true) {\n                      if (!rowA[i]) {\n                        rowA[i] = cell;\n                        augmentIndex = i;\n                        break;\n                      }\n                      i++;\n                    }\n                  }\n                }\n                augmentIndex += cell.colSpan;\n              });\n            };\n\n            for (var r = 0; r < rowsLength; r++) {\n              _loop(r);\n            }\n            return {\n              v: Object.keys(abstr[defaultHeaderRow.index]).map(function (k) {\n                return abstr[defaultHeaderRow.index][k];\n              })\n            };\n          }();\n\n          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n        } else {\n          throw new TypeError('TableColumns.getHeaderCells: defaultHeaderRowIndex is not specified or is not a Number');\n        }\n      }\n      return null;\n    }\n\n    /**\r\n     * Gets an array of columns from the table\r\n     * @param {!HTMLTableElement} thead - source table header\r\n     * @param {!HTMLTableElement} refThead - reference table header from floating header if any\r\n     * @param {Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n     * @return {?Array} Returns an array of header cell nodes or null if `thead` is not specified\r\n     * */\n\n  }, {\n    key: 'computeColumns',\n    value: function computeColumns(thead, refThead, defaultHeaderRowIndex) {\n      var theadCells = TableColumns.getHeaderCells(thead, defaultHeaderRowIndex);\n      var refTheadCells = TableColumns.getHeaderCells(refThead, defaultHeaderRowIndex);\n      var realColumnIndex = 0;\n      return theadCells.map(function (cell, index) {\n        var obj = {\n          index: realColumnIndex,\n          title: cell.textContent,\n          cell: cell,\n          colSpan: cell.colSpan\n        };\n        if (refTheadCells != null) {\n          obj.refCell = refTheadCells[index];\n        }\n        // we need to increment the colspan only for columns that follow rowheader because the block is not in data.\n        realColumnIndex = realColumnIndex > 0 ? realColumnIndex + cell.colSpan : realColumnIndex + 1;\n        return obj;\n      });\n    }\n  }]);\n\n  return TableColumns;\n}();\n\nexports.default = TableColumns;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Itc29ydC10YWJsZS9zcmMvdGFibGUtY29sdW1ucy5qcz9jYWFkIl0sIm5hbWVzIjpbIlRhYmxlQ29sdW1ucyIsIm9wdGlvbnMiLCJzb3VyY2UiLCJyZWZTb3VyY2UiLCJkZWZhdWx0SGVhZGVyUm93IiwidGhlYWQiLCJyZWZUaGVhZCIsImdldEhlYWRlciIsIlR5cGVFcnJvciIsImNvbXB1dGVDb2x1bW5zIiwidGFnTmFtZSIsImhlYWRlciIsInF1ZXJ5U2VsZWN0b3IiLCJjaGlsZHJlbiIsImxlbmd0aCIsImRlZmF1bHRIZWFkZXJSb3dJbmRleCIsImhlYWRlclJvd3MiLCJoZWFkZXJSb3dJbmRleCIsImluZGV4Iiwicm93IiwiaXRlbSIsImdldERlZmF1bHRIZWFkZXJSb3ciLCJyb3dzTGVuZ3RoIiwiYWJzdHIiLCJyIiwiYXVnbWVudEluZGV4Iiwic2xpY2UiLCJjYWxsIiwiZm9yRWFjaCIsImNlbGwiLCJycyIsInJvd1NwYW4iLCJyb3dBIiwiaSIsImNvbFNwYW4iLCJPYmplY3QiLCJrZXlzIiwibWFwIiwiayIsInRoZWFkQ2VsbHMiLCJnZXRIZWFkZXJDZWxscyIsInJlZlRoZWFkQ2VsbHMiLCJyZWFsQ29sdW1uSW5kZXgiLCJvYmoiLCJ0aXRsZSIsInRleHRDb250ZW50IiwicmVmQ2VsbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7SUFJTUEsWTtBQUNKOzs7Ozs7Ozs7QUFTQSx3QkFBWUMsT0FBWixFQUFvQjtBQUFBOztBQUFBLFFBQ2JDLE1BRGEsR0FDMkJELE9BRDNCLENBQ2JDLE1BRGE7QUFBQSxRQUNOQyxTQURNLEdBQzJCRixPQUQzQixDQUNORSxTQURNO0FBQUEsZ0NBQzJCRixPQUQzQixDQUNJRyxnQkFESjtBQUFBLFFBQ0lBLGdCQURKLHlDQUNxQixDQUFDLENBRHRCOztBQUVsQixRQUFJQyxjQUFKO0FBQUEsUUFBVUMsaUJBQVY7QUFDQSxRQUFHSixNQUFILEVBQVU7QUFBQ0csY0FBTUws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aUJBQU9XLE9BQU9DLElBQVAsQ0FBWWIsTUFBTW5CLGlCQUFpQmMsS0FBdkIsQ0FBWixFQUEyQ21CLEdBQTNDLENBQStDO0FBQUEsdUJBQUtkLE1BQU1uQixpQkFBaUJjLEtBQXZCLEVBQThCb0IsQ0FBOUIsQ0FBTDtBQUFBLGVBQS9DO0FBQVA7QUE1QjZCOztBQUFBO0FBNkI5QixTQTdCRCxNQTZCTztBQUNMLGdCQUFNLElBQUk5QixTQUFKLENBQWMsd0ZBQWQsQ0FBTjtBQUNEO0FBQ0Y7QUFDRCxhQUFPLElBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7OzttQ0FPc0JILEssRUFBTUMsUSxFQUFTUyxxQixFQUFzQjtBQUN6RCxVQUFJd0IsYUFBYXZDLGFBQWF3QyxjQUFiLENBQTRCbkMsS0FBNUIsRUFBa0NVLHFCQUFsQyxDQUFqQjtBQUNBLFVBQUkwQixnQkFBZ0J6QyxhQUFhd0MsY0FBYixDQUE0QmxDLFFBQTVCLEVBQXFDUyxxQkFBckMsQ0FBcEI7QUFDQSxVQUFJMkIsa0JBQWdCLENBQXBCO0FBQ0EsYUFBT0gsV0FBV0YsR0FBWCxDQUFlLFVBQUNSLElBQUQsRUFBTVgsS0FBTixFQUFjO0FBQ2xDLFlBQUl5QixNQUFNO0FBQ1J6QixpQkFBT3dCLGVBREM7QUFFUkUsaUJBQU9mLEtBQUtnQixXQUZKO0FBR1JoQixvQkFIUTtBQUlSSyxtQkFBUUwsS0FBS0s7QUFKTCxTQUFWO0FBTUEsWUFBR08saUJBQWUsSUFBbEIsRUFBdUI7QUFBQ0UsY0FBSUcsT0FBSixHQUFjTCxjQUFjdkIsS0FBZCxDQUFkO0FBQW1DO0FBQzNEO0FBQ0F3QiwwQkFBaUJBLGtCQUFnQixDQUFoQixHQUFtQkEsa0JBQWtCYixLQUFLSyxPQUExQyxHQUFtRFEsa0JBQWdCLENBQXBGO0FBQ0EsZUFBT0MsR0FBUDtBQUNELE9BWE0sQ0FBUDtBQVlEOzs7Ozs7a0JBRVkzQyxZIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ3JlYXRlZCBieSBJdmFuUCBvbiAwOS4wOS4yMDE2LlxyXG4gKi9cclxuXHJcbmNsYXNzIFRhYmxlQ29sdW1uc3tcclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG9iamVjdHMgY29ycmVzcG9uZGluZyB0byB0aGUgY2VsbHMgb2YgYGRlZmF1bHRIZWFkZXJSb3dgLCB0aGF0IGNvbnRhaW4gYHNvcnRhYmxlYCBwcm9wZXJ0eSwgZGVub3RpbmcgdGhlIGNvbHVtbiBpcyBzb3J0YWJsZSxcclxuICAgKiBgaW5kZXhgIG9mIHRoZSBjb2x1bW4gYW5kIHJlZmVyZW5jZSB0byB0aGUgYGNlbGxgLiBBZGRzIGAuc29ydGFibGVgIHRvIGEgc29ydGFibGUgY2VsbFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBwYXNzZWQgdG8gY29uZmlndXJlIHRoZSBTb3J0aW5nXHJcbiAgICogQHBhcmFtIHtIVE1MVGFibGVFbGVtZW50fSBvcHRpb25zLnNvdXJjZSAtIHNvdXJjZSB0YWJsZSBzb3J0aW5nIHdpbGwgYmUgYXBwbGllZCB0b1xyXG4gICAqIEBwYXJhbSB7SFRNTFRhYmxlRWxlbWVudH0gb3B0aW9ucy5yZWZTb3VyY2UgLSBmbG9hdGluZyBoZWFkZXIgaWYgYW55XHJcbiAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbb3B0aW9ucy5kZWZhdWx0SGVhZGVyUm93PS0xXSAtIGluZGV4IG9mIHRoZSByb3cgaW4gYHRoZWFkYCAoaW5jcmVtZW50ZWQgZnJvbSAwKSB0aGF0IHdpbGwgaGF2ZSBzb3J0aW5nIGVuYWJsZWQgZm9yIGNvbHVtbnMuIElmIGAtMWAgdGhlbiBsYXN0IHJvdy5cclxuICAgKiBAcmV0dXJuIHt7aW5kZXg6TnVtYmVyLCB0aXRsZTpTdHJpbmcsIGNvbFNwYW46TnVtYmVyLCBjZWxsOiBIVE1MVGFibGVDZWxsRWxlbWVudCwgP3JlZkNlbGw6SFRNTFRhYmxlQ2VsbEVsZW1lbnR9fSAtIGFuIGFycmF5IG9mIG9iamVjdHMgdGhhdCBoYXZlIHRoaXMgc3RydWN0dXJlXHJcbiAgICogKi9cclxuICBjb25zdHJ1Y3RvcihvcHRpb25zKXtcclxuICAgIGxldCB7c291cmNlLHJlZlNvdXJjZSxkZWZhdWx0SGVhZGVyUm93PS0xfSA9IG9wdGlvbnM7XHJcbiAgICBsZXQgdGhlYWQscmVmVGhlYWQ7XHJcbiAgICBpZihzb3VyY2Upe3RoZWFkPVRhYmxlQ29sdW1ucy5nZXRIZWFkZXIoc291cmNlKX0gZWxzZSB7dGhyb3cgbmV3IFR5cGVFcnJvcignYHNvdXJjZWAgdGFibGUgaXMgbm90IHNwZWNpZmllZCwgY2Fubm90IGNyZWF0ZSBUYWJsZUNvbHVtbnMnKX1cclxuICAgIGlmKHJlZlNvdXJjZSl7cmVmVGhlYWQ9VGFibGVDb2x1bW5zLmdldEhlYWRlcihyZWZTb3VyY2UpfVxyXG4gICAgcmV0dXJuIFRhYmxlQ29sdW1ucy5jb21wdXRlQ29sdW1ucyh0aGVhZCxyZWZUaGVhZCxkZWZhdWx0SGVhZGVyUm93KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYSBoZWFkZXJcclxuICAgKiBAcGFyYW0ge0hUTUxUYWJsZUVsZW1lbnR9IHNvdXJjZSAtIHNvdXJjZSB0YWJsZSBoZWFkZXJzIGFyZSBjcmVhdGVkIGZvclxyXG4gICAqICovXHJcbiAgc3RhdGljIGdldEhlYWRlcihzb3VyY2Upe1xyXG4gICAgaWYoc291cmNlICYmIHNvdXJjZS50YWdOYW1lID09ICdUQUJMRScpe1xyXG4gICAgICBsZXQgaGVhZGVyID0gc291cmNlLnF1ZXJ5U2VsZWN0b3IoXCJ0aGVhZFwiKTtcclxuICAgICAgaWYoaGVhZGVyICYmIGhlYWRlci5jaGlsZHJlbi5sZW5ndGg+MCkge1xyXG4gICAgICAgIHJldHVybiBoZWFkZXI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYHNvdXJjZWAgdGFibGUgaGFzIG5vIGhlYWRlciBvciByb3dzJyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Bzb3VyY2VgIGlzIG5vdCBzcGVjaWZpZWQgb3IgaXMgbm90IGEgdGFibGUnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgZGVmYXVsdEhlYWRlclJvdyBmb3IgYSBwYXNzZWQgYHRoZWFkYFxyXG4gICAqIEBwYXJhbSB7IUhUTUxUYWJsZUVsZW1lbnR9IHRoZWFkIC0gc291cmNlIHRhYmxlIGhlYWRlclxyXG4gICAqIEBwYXJhbSB7IU51bWJlcn0gZGVmYXVsdEhlYWRlclJvd0luZGV4IC0gaW5kZXggb2YgdGhlIHJvdyBpbiBgdGhlYWRgIChpbmNyZW1lbnRlZCBmcm9tIDApIHRoYXQgd2lsbCBiZSBjb25zaWRlcmVkIGRlZmF1bHQgdG8gaGF2ZSBhY3Rpb25zIGV4ZWN1dGVkIHVwb24uXHJcbiAgICogQHJldHVybiB7e2luZGV4Ok51bWJlciwgcm93OiBIVE1MVGFibGVSb3dFbGVtZW50fX1cclxuICAgKiAqL1xyXG4gIHN0YXRpYyBnZXREZWZhdWx0SGVhZGVyUm93KHRoZWFkLGRlZmF1bHRIZWFkZXJSb3dJbmRleCl7XHJcbiAgICAvLyBjYWxjdWxhdGUgZGVmYXVsdCBoZWFkZXIgcm93XHJcbiAgICBsZXQgaGVhZGVyUm93cyA9IHRoZWFkLmNoaWxkcmVuLFxyXG4gICAgICBoZWFkZXJSb3dJbmRleCA9IGRlZmF1bHRIZWFkZXJSb3dJbmRleD09LTEgPyBoZWFkZXJSb3dzLmxlbmd0aCArIGRlZmF1bHRIZWFkZXJSb3dJbmRleCA6IGRlZmF1bHRIZWFkZXJSb3dJbmRleDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGluZGV4OmhlYWRlclJvd0luZGV4LFxyXG4gICAgICByb3c6aGVhZGVyUm93cy5pdGVtKGhlYWRlclJvd0luZGV4KVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYW4gYXJyYXkgb2YgaGVhZGVyIGNlbGwgbm9kZXMgZnJvbSBkZWZhdWx0IGhlYWRlciByb3dcclxuICAgKiBAcGFyYW0gez9IVE1MVGFibGVFbGVtZW50fSB0aGVhZCAtIHNvdXJjZSB0YWJsZSBoZWFkZXJcclxuICAgKiBAcGFyYW0geyFOdW1iZXJ9IGRlZmF1bHRIZWFkZXJSb3dJbmRleCAtIGluZGV4IG9mIHRoZSByb3cgaW4gYHRoZWFkYCAoaW5jcmVtZW50ZWQgZnJvbSAwKSB0aGF0IHdpbGwgYmUgY29uc2lkZXJlZCBkZWZhdWx0IHRvIGhhdmUgYWN0aW9ucyBleGVjdXRlZCB1cG9uLlxyXG4gICAqIEByZXR1cm4gez9BcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBoZWFkZXIgY2VsbCBub2RlcyBvciBudWxsIGlmIGB0aGVhZGAgaXMgbm90IHNwZWNpZmllZFxyXG4gICAqICovXHJcbiAgc3RhdGljIGdldEhlYWRlckNlbGxzKHRoZWFkLGRlZmF1bHRIZWFkZXJSb3dJbmRleCl7XHJcbiAgICBpZih0aGVhZCl7XHJcbiAgICAgIGlmKGRlZmF1bHRIZWFkZXJSb3dJbmRleCE9bnVsbCl7XHJcbiAgICAgICAgbGV0IGRlZmF1bHRIZWFkZXJSb3cgPSBUYWJsZUNvbHVtbnMuZ2V0RGVmYXVsdEhlYWRlclJvdyh0aGVhZCxkZWZhdWx0SGVhZGVyUm93SW5kZXgpO1xyXG4gICAgICAgIGxldCBoZWFkZXJSb3dzID0gdGhlYWQuY2hpbGRyZW47XHJcbiAgICAgICAgbGV0IHJvd3NMZW5ndGggPSBoZWFkZXJSb3dzLmxlbmd0aDtcclxuICAgICAgICBsZXQgYWJzdHIgPSB7fTtcclxuICAgICAgICBmb3IobGV0IHI9MDtyPHJvd3NMZW5ndGg7cisrKXtcclxuICAgICAgICAgIGxldCByb3cgPSBoZWFkZXJSb3dzLml0ZW0ocik7XHJcbiAgICAgICAgICBsZXQgYXVnbWVudEluZGV4PTA7IC8vIGluZGV4IHRoYXQgd2lsbCBhY2NvdW50IGZvciBjb2xTcGFuIG9mIHVwcGVyIHJvd3MnIGNlbGxzXHJcbiAgICAgICAgICBbXS5zbGljZS5jYWxsKHJvdy5jaGlsZHJlbikuZm9yRWFjaCgoY2VsbCxpbmRleCk9PnsgLy9pdGVyYXRlIHRocm91Z2ggY2VsbHNcclxuICAgICAgICAgICAgZm9yKGxldCBycz0wOyByczw9Y2VsbC5yb3dTcGFuLTE7cnMrKyl7IC8vc3ByZWFkIGNlbGwgYWNyb3NzIGl0cyByb3dzcGFuXHJcbiAgICAgICAgICAgICAgbGV0IHJvd0EgPSBhYnN0cltyK3JzXSA9IGFic3RyW3IrcnNdIHx8IHt9OyAvL2NyZWF0ZSByb3cgaWYgbm90IGV4aXN0c1xyXG4gICAgICAgICAgICAgIGlmKCFyb3dBW2F1Z21lbnRJbmRleF0peyAvL2luc2VydCBjZWxsIGludG8gc2xvdCBpZiBub3QgZmlsbGVkXHJcbiAgICAgICAgICAgICAgICByb3dBW2F1Z21lbnRJbmRleF09Y2VsbDtcclxuICAgICAgICAgICAgICB9IGVsc2UgeyAvL2lmIGZpbGxlZCBsb29rIGZvciB0aGUgbmV4dCBlbXB0eSBiZWNhdXNlIHJvd3NwYW5uZWQgY29sdW1ucyBmaWxsIHRoZW0gaW4gYSBsaW5lYXIgd2F5XHJcbiAgICAgICAgICAgICAgICBsZXQgaT0wO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUodHJ1ZSl7XHJcbiAgICAgICAgICAgICAgICAgIGlmKCFyb3dBW2ldKXtcclxuICAgICAgICAgICAgICAgICAgICByb3dBW2ldPWNlbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgYXVnbWVudEluZGV4PWk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhdWdtZW50SW5kZXgrPWNlbGwuY29sU3BhbjtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhYnN0cltkZWZhdWx0SGVhZGVyUm93LmluZGV4XSkubWFwKGsgPT4gYWJzdHJbZGVmYXVsdEhlYWRlclJvdy5pbmRleF1ba10pXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGFibGVDb2x1bW5zLmdldEhlYWRlckNlbGxzOiBkZWZhdWx0SGVhZGVyUm93SW5kZXggaXMgbm90IHNwZWNpZmllZCBvciBpcyBub3QgYSBOdW1iZXInKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbiBhcnJheSBvZiBjb2x1bW5zIGZyb20gdGhlIHRhYmxlXHJcbiAgICogQHBhcmFtIHshSFRNTFRhYmxlRWxlbWVudH0gdGhlYWQgLSBzb3VyY2UgdGFibGUgaGVhZGVyXHJcbiAgICogQHBhcmFtIHshSFRNTFRhYmxlRWxlbWVudH0gcmVmVGhlYWQgLSByZWZlcmVuY2UgdGFibGUgaGVhZGVyIGZyb20gZmxvYXRpbmcgaGVhZGVyIGlmIGFueVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWZhdWx0SGVhZGVyUm93SW5kZXggLSBpbmRleCBvZiB0aGUgcm93IGluIGB0aGVhZGAgKGluY3JlbWVudGVkIGZyb20gMCkgdGhhdCB3aWxsIGJlIGNvbnNpZGVyZWQgZGVmYXVsdCB0byBoYXZlIGFjdGlvbnMgZXhlY3V0ZWQgdXBvbi5cclxuICAgKiBAcmV0dXJuIHs/QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgaGVhZGVyIGNlbGwgbm9kZXMgb3IgbnVsbCBpZiBgdGhlYWRgIGlzIG5vdCBzcGVjaWZpZWRcclxuICAgKiAqL1xyXG4gIHN0YXRpYyBjb21wdXRlQ29sdW1ucyh0aGVhZCxyZWZUaGVhZCxkZWZhdWx0SGVhZGVyUm93SW5kZXgpe1xyXG4gICAgbGV0IHRoZWFkQ2VsbHMgPSBUYWJsZUNvbHVtbnMuZ2V0SGVhZGVyQ2VsbHModGhlYWQsZGVmYXVsdEhlYWRlclJvd0luZGV4KTtcclxuICAgIGxldCByZWZUaGVhZENlbGxzID0gVGFibGVDb2x1bW5zLmdldEhlYWRlckNlbGxzKHJlZlRoZWFkLGRlZmF1bHRIZWFkZXJSb3dJbmRleCk7XHJcbiAgICBsZXQgcmVhbENvbHVtbkluZGV4PTA7XHJcbiAgICByZXR1cm4gdGhlYWRDZWxscy5tYXAoKGNlbGwsaW5kZXgpPT57XHJcbiAgICAgIGxldCBvYmogPSB7XHJcbiAgICAgICAgaW5kZXg6IHJlYWxDb2x1bW5JbmRleCxcclxuICAgICAgICB0aXRsZTogY2VsbC50ZXh0Q29udGVudCxcclxuICAgICAgICBjZWxsLFxyXG4gICAgICAgIGNvbFNwYW46Y2VsbC5jb2xTcGFuXHJcbiAgICAgIH07XHJcbiAgICAgIGlmKHJlZlRoZWFkQ2VsbHMhPW51bGwpe29iai5yZWZDZWxsID0gcmVmVGhlYWRDZWxsc1tpbmRleF19XHJcbiAgICAgIC8vIHdlIG5lZWQgdG8gaW5jcmVtZW50IHRoZSBjb2xzcGFuIG9ubHkgZm9yIGNvbHVtbnMgdGhhdCBmb2xsb3cgcm93aGVhZGVyIGJlY2F1c2UgdGhlIGJsb2NrIGlzIG5vdCBpbiBkYXRhLlxyXG4gICAgICByZWFsQ29sdW1uSW5kZXg9IHJlYWxDb2x1bW5JbmRleD4wPyhyZWFsQ29sdW1uSW5kZXggKyBjZWxsLmNvbFNwYW4pOnJlYWxDb2x1bW5JbmRleCsxO1xyXG4gICAgICByZXR1cm4gb2JqO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IFRhYmxlQ29sdW1ucztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yLXNvcnQtdGFibGUvc3JjL3RhYmxlLWNvbHVtbnMuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _tableColumns = __webpack_require__(11);\n\nvar _tableColumns2 = _interopRequireDefault(_tableColumns);\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\r\n * Created by IvanP on 07.09.2016.\r\n */\nwindow.Reportal = window.Reportal || {};\n_rReportalBase2.default.mixin(window.Reportal, {\n  TableColumns: _tableColumns2.default\n});\n\nexports.default = _tableColumns2.default;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItdGFibGUtY29sdW1ucy9zcmMvbWFpbi5qcz8xZjg4Il0sIm5hbWVzIjpbIndpbmRvdyIsIlJlcG9ydGFsIiwibWl4aW4iLCJUYWJsZUNvbHVtbnMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUdBOzs7O0FBQ0E7Ozs7OztBQUpBOzs7QUFNQUEsT0FBT0MsUUFBUCxHQUFrQkQsT0FBT0MsUUFBUCxJQUFtQixFQUFyQztBQUNBLHdCQUFhQyxLQUFiLENBQW1CRixPQUFPQyxRQUExQixFQUFtQztBQUNqQ0U7QUFEaUMsQ0FBbkMiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ3JlYXRlZCBieSBJdmFuUCBvbiAwNy4wOS4yMDE2LlxyXG4gKi9cclxuaW1wb3J0IFRhYmxlQ29sdW1ucyBmcm9tIFwiLi90YWJsZS1jb2x1bW5zXCI7XHJcbmltcG9ydCBSZXBvcnRhbEJhc2UgZnJvbSBcInItcmVwb3J0YWwtYmFzZVwiO1xyXG5cclxud2luZG93LlJlcG9ydGFsID0gd2luZG93LlJlcG9ydGFsIHx8IHt9O1xyXG5SZXBvcnRhbEJhc2UubWl4aW4od2luZG93LlJlcG9ydGFsLHtcclxuICBUYWJsZUNvbHVtbnMsXHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGFibGVDb2x1bW5zO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3ItdGFibGUtY29sdW1ucy9zcmMvbWFpbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 11 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Created by IvanP on 09.09.2016.\r\n */\n\nvar TableColumns = function () {\n  /**\r\n   * Creates an array of objects corresponding to the cells of `defaultHeaderRow`.\r\n   * @param {Object} options - options passed to configure the Sorting\r\n   * @param {HTMLTableElement} options.source - source table sorting will be applied to\r\n   * @param {HTMLTableElement} options.refSource - floating header if any\r\n   * @param {Number|Object} [options.defaultHeaderRow=-1] - index of the row in `thead` (incremented from 0) that will have sorting enabled for columns. If `-1` then last row.\r\n   * @return {{index:Number, title:String, colSpan:Number, cell: HTMLTableCellElement, ?refCell:HTMLTableCellElement}} - an array of objects that have this structure\r\n   * */\n  function TableColumns(options) {\n    _classCallCheck(this, TableColumns);\n\n    var source = options.source,\n        refSource = options.refSource,\n        _options$defaultHeade = options.defaultHeaderRow,\n        defaultHeaderRow = _options$defaultHeade === undefined ? -1 : _options$defaultHeade;\n\n    var thead = void 0,\n        refThead = void 0;\n    if (source) {\n      thead = TableColumns.getHeader(source);\n    } else {\n      throw new TypeError('`source` table is not specified, cannot create TableColumns');\n    }\n    if (refSource) {\n      refThead = TableColumns.getHeader(refSource);\n    }\n    return TableColumns.computeColumns(thead, refThead, defaultHeaderRow);\n  }\n\n  /**\r\n   * Gets a header\r\n   * @param {HTMLTableElement} source - source table headers are created for\r\n   * */\n\n\n  _createClass(TableColumns, null, [{\n    key: 'getHeader',\n    value: function getHeader(source) {\n      if (source && source.tagName == 'TABLE') {\n        var header = source.querySelector(\"thead\");\n        if (header && header.children.length > 0) {\n          return header;\n        } else {\n          throw new TypeError('`source` table has no header or rows');\n        }\n      } else {\n        throw new TypeError('`source` is not specified or is not a table');\n      }\n    }\n\n    /**\r\n     * Calculates defaultHeaderRow for a passed `thead`\r\n     * @param {!HTMLTableElement} thead - source table header\r\n     * @param {!Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n     * @return {{index:Number, row: HTMLTableRowElement}}\r\n     * */\n\n  }, {\n    key: 'getDefaultHeaderRow',\n    value: function getDefaultHeaderRow(thead, defaultHeaderRowIndex) {\n      // calculate default header row\n      var headerRows = thead.children,\n          headerRowIndex = defaultHeaderRowIndex == -1 ? headerRows.length + defaultHeaderRowIndex : defaultHeaderRowIndex;\n      return {\n        index: headerRowIndex,\n        row: headerRows.item(headerRowIndex)\n      };\n    }\n\n    /**\r\n     * Gets an array of header cell nodes from default header row\r\n     * @param {?HTMLTableElement} thead - source table header\r\n     * @param {!Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n     * @return {?Array} Returns an array of header cell nodes or null if `thead` is not specified\r\n     * */\n\n  }, {\n    key: 'getHeaderCells',\n    value: function getHeaderCells(thead, defaultHeaderRowIndex) {\n      if (thead) {\n        if (defaultHeaderRowIndex != null) {\n          var _ret = function () {\n            var defaultHeaderRow = TableColumns.getDefaultHeaderRow(thead, defaultHeaderRowIndex);\n            var headerRows = thead.children;\n            var rowsLength = headerRows.length;\n            var abstr = {};\n\n            var _loop = function _loop(r) {\n              var row = headerRows.item(r);\n              var augmentIndex = 0; // index that will account for colSpan of upper rows' cells\n              [].slice.call(row.children).forEach(function (cell, index) {\n                //iterate through cells\n                for (var rs = 0; rs <= cell.rowSpan - 1; rs++) {\n                  //spread cell across its rowspan\n                  var rowA = abstr[r + rs] = abstr[r + rs] || {}; //create row if not exists\n                  if (!rowA[augmentIndex]) {\n                    //insert cell into slot if not filled\n                    rowA[augmentIndex] = cell;\n                  } else {\n                    //if filled look for the next empty because rowspanned columns fill them in a linear way\n                    var i = 0;\n                    while (true) {\n                      if (!rowA[i]) {\n                        rowA[i] = cell;\n                        augmentIndex = i;\n                        break;\n                      }\n                      i++;\n                    }\n                  }\n                }\n                augmentIndex += cell.colSpan;\n              });\n            };\n\n            for (var r = 0; r < rowsLength; r++) {\n              _loop(r);\n            }\n            return {\n              v: Object.keys(abstr[defaultHeaderRow.index]).map(function (k) {\n                return abstr[defaultHeaderRow.index][k];\n              })\n            };\n          }();\n\n          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n        } else {\n          throw new TypeError('TableColumns.getHeaderCells: defaultHeaderRowIndex is not specified or is not a Number');\n        }\n      }\n      return null;\n    }\n\n    /**\r\n     * Gets an array of columns from the table\r\n     * @param {!HTMLTableElement} thead - source table header\r\n     * @param {!HTMLTableElement} refThead - reference table header from floating header if any\r\n     * @param {Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n     * @return {?Array} Returns an array of header cell nodes or null if `thead` is not specified\r\n     * */\n\n  }, {\n    key: 'computeColumns',\n    value: function computeColumns(thead, refThead, defaultHeaderRowIndex) {\n      var theadCells = TableColumns.getHeaderCells(thead, defaultHeaderRowIndex);\n      var refTheadCells = TableColumns.getHeaderCells(refThead, defaultHeaderRowIndex);\n      var realColumnIndex = 0;\n      return theadCells.map(function (cell, index) {\n        var obj = {\n          index: realColumnIndex,\n          title: cell.textContent,\n          cell: cell,\n          colSpan: cell.colSpan\n        };\n        if (refTheadCells != null) {\n          obj.refCell = refTheadCells[index];\n        }\n        // we need to increment the colspan only for columns that follow rowheader because the block is not in data.\n        realColumnIndex = realColumnIndex > 0 ? realColumnIndex + cell.colSpan : realColumnIndex + 1;\n        return obj;\n      });\n    }\n  }]);\n\n  return TableColumns;\n}();\n\nexports.default = TableColumns;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItdGFibGUtY29sdW1ucy9zcmMvdGFibGUtY29sdW1ucy5qcz9kMjk4Il0sIm5hbWVzIjpbIlRhYmxlQ29sdW1ucyIsIm9wdGlvbnMiLCJzb3VyY2UiLCJyZWZTb3VyY2UiLCJkZWZhdWx0SGVhZGVyUm93IiwidGhlYWQiLCJyZWZUaGVhZCIsImdldEhlYWRlciIsIlR5cGVFcnJvciIsImNvbXB1dGVDb2x1bW5zIiwidGFnTmFtZSIsImhlYWRlciIsInF1ZXJ5U2VsZWN0b3IiLCJjaGlsZHJlbiIsImxlbmd0aCIsImRlZmF1bHRIZWFkZXJSb3dJbmRleCIsImhlYWRlclJvd3MiLCJoZWFkZXJSb3dJbmRleCIsImluZGV4Iiwicm93IiwiaXRlbSIsImdldERlZmF1bHRIZWFkZXJSb3ciLCJyb3dzTGVuZ3RoIiwiYWJzdHIiLCJyIiwiYXVnbWVudEluZGV4Iiwic2xpY2UiLCJjYWxsIiwiZm9yRWFjaCIsImNlbGwiLCJycyIsInJvd1NwYW4iLCJyb3dBIiwiaSIsImNvbFNwYW4iLCJPYmplY3QiLCJrZXlzIiwibWFwIiwiayIsInRoZWFkQ2VsbHMiLCJnZXRIZWFkZXJDZWxscyIsInJlZlRoZWFkQ2VsbHMiLCJyZWFsQ29sdW1uSW5kZXgiLCJvYmoiLCJ0aXRsZSIsInRleHRDb250ZW50IiwicmVmQ2VsbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7SUFJTUEsWTtBQUNKOzs7Ozs7OztBQVFBLHdCQUFZQyxPQUFaLEVBQW9CO0FBQUE7O0FBQUEsUUFDYkMsTUFEYSxHQUMyQkQsT0FEM0IsQ0FDYkMsTUFEYTtBQUFBLFFBQ05DLFNBRE0sR0FDMkJGLE9BRDNCLENBQ05FLFNBRE07QUFBQSxnQ0FDMkJGLE9BRDNCLENBQ0lHLGdCQURKO0FBQUEsUUFDSUEsZ0JBREoseUNBQ3FCLENBQUMsQ0FEdEI7O0FBRWxCLFFBQUlDLGNBQUo7QUFBQSxRQUFVQyxpQkFBVjtBQUNBLFFBQUdKLE1BQUgsRUFBVTtBQUFDRyxjQUFN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QSxpQkFBT1csT0FBT0MsSUFBUCxDQUFZYixNQUFNbkIsaUJBQWlCYyxLQUF2QixDQUFaLEVBQTJDbUIsR0FBM0MsQ0FBK0M7QUFBQSx1QkFBS2QsTUFBTW5CLGlCQUFpQmMsS0FBdkIsRUFBOEJvQixDQUE5QixDQUFMO0FBQUEsZUFBL0M7QUFBUDtBQTVCNkI7O0FBQUE7QUE2QjlCLFNBN0JELE1BNkJPO0FBQ0wsZ0JBQU0sSUFBSTlCLFNBQUosQ0FBYyx3RkFBZCxDQUFOO0FBQ0Q7QUFDRjtBQUNELGFBQU8sSUFBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7O21DQU9zQkgsSyxFQUFNQyxRLEVBQVNTLHFCLEVBQXNCO0FBQ3pELFVBQUl3QixhQUFhdkMsYUFBYXdDLGNBQWIsQ0FBNEJuQyxLQUE1QixFQUFrQ1UscUJBQWxDLENBQWpCO0FBQ0EsVUFBSTBCLGdCQUFnQnpDLGFBQWF3QyxjQUFiLENBQTRCbEMsUUFBNUIsRUFBcUNTLHFCQUFyQyxDQUFwQjtBQUNBLFVBQUkyQixrQkFBZ0IsQ0FBcEI7QUFDQSxhQUFPSCxXQUFXRixHQUFYLENBQWUsVUFBQ1IsSUFBRCxFQUFNWCxLQUFOLEVBQWM7QUFDbEMsWUFBSXlCLE1BQU07QUFDUnpCLGlCQUFPd0IsZUFEQztBQUVSRSxpQkFBT2YsS0FBS2dCLFdBRko7QUFHUmhCLG9CQUhRO0FBSVJLLG1CQUFRTCxLQUFLSztBQUpMLFNBQVY7QUFNQSxZQUFHTyxpQkFBZSxJQUFsQixFQUF1QjtBQUFDRSxjQUFJRyxPQUFKLEdBQWNMLGNBQWN2QixLQUFkLENBQWQ7QUFBbUM7QUFDM0Q7QUFDQXdCLDBCQUFpQkEsa0JBQWdCLENBQWhCLEdBQW1CQSxrQkFBa0JiLEtBQUtLLE9BQTFDLEdBQW1EUSxrQkFBZ0IsQ0FBcEY7QUFDQSxlQUFPQyxHQUFQO0FBQ0QsT0FYTSxDQUFQO0FBWUQ7Ozs7OztrQkFFWTNDLFkiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ3JlYXRlZCBieSBJdmFuUCBvbiAwOS4wOS4yMDE2LlxyXG4gKi9cclxuXHJcbmNsYXNzIFRhYmxlQ29sdW1uc3tcclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG9iamVjdHMgY29ycmVzcG9uZGluZyB0byB0aGUgY2VsbHMgb2YgYGRlZmF1bHRIZWFkZXJSb3dgLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBwYXNzZWQgdG8gY29uZmlndXJlIHRoZSBTb3J0aW5nXHJcbiAgICogQHBhcmFtIHtIVE1MVGFibGVFbGVtZW50fSBvcHRpb25zLnNvdXJjZSAtIHNvdXJjZSB0YWJsZSBzb3J0aW5nIHdpbGwgYmUgYXBwbGllZCB0b1xyXG4gICAqIEBwYXJhbSB7SFRNTFRhYmxlRWxlbWVudH0gb3B0aW9ucy5yZWZTb3VyY2UgLSBmbG9hdGluZyBoZWFkZXIgaWYgYW55XHJcbiAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbb3B0aW9ucy5kZWZhdWx0SGVhZGVyUm93PS0xXSAtIGluZGV4IG9mIHRoZSByb3cgaW4gYHRoZWFkYCAoaW5jcmVtZW50ZWQgZnJvbSAwKSB0aGF0IHdpbGwgaGF2ZSBzb3J0aW5nIGVuYWJsZWQgZm9yIGNvbHVtbnMuIElmIGAtMWAgdGhlbiBsYXN0IHJvdy5cclxuICAgKiBAcmV0dXJuIHt7aW5kZXg6TnVtYmVyLCB0aXRsZTpTdHJpbmcsIGNvbFNwYW46TnVtYmVyLCBjZWxsOiBIVE1MVGFibGVDZWxsRWxlbWVudCwgP3JlZkNlbGw6SFRNTFRhYmxlQ2VsbEVsZW1lbnR9fSAtIGFuIGFycmF5IG9mIG9iamVjdHMgdGhhdCBoYXZlIHRoaXMgc3RydWN0dXJlXHJcbiAgICogKi9cclxuICBjb25zdHJ1Y3RvcihvcHRpb25zKXtcclxuICAgIGxldCB7c291cmNlLHJlZlNvdXJjZSxkZWZhdWx0SGVhZGVyUm93PS0xfSA9IG9wdGlvbnM7XHJcbiAgICBsZXQgdGhlYWQscmVmVGhlYWQ7XHJcbiAgICBpZihzb3VyY2Upe3RoZWFkPVRhYmxlQ29sdW1ucy5nZXRIZWFkZXIoc291cmNlKX0gZWxzZSB7dGhyb3cgbmV3IFR5cGVFcnJvcignYHNvdXJjZWAgdGFibGUgaXMgbm90IHNwZWNpZmllZCwgY2Fubm90IGNyZWF0ZSBUYWJsZUNvbHVtbnMnKX1cclxuICAgIGlmKHJlZlNvdXJjZSl7cmVmVGhlYWQ9VGFibGVDb2x1bW5zLmdldEhlYWRlcihyZWZTb3VyY2UpfVxyXG4gICAgcmV0dXJuIFRhYmxlQ29sdW1ucy5jb21wdXRlQ29sdW1ucyh0aGVhZCxyZWZUaGVhZCxkZWZhdWx0SGVhZGVyUm93KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYSBoZWFkZXJcclxuICAgKiBAcGFyYW0ge0hUTUxUYWJsZUVsZW1lbnR9IHNvdXJjZSAtIHNvdXJjZSB0YWJsZSBoZWFkZXJzIGFyZSBjcmVhdGVkIGZvclxyXG4gICAqICovXHJcbiAgc3RhdGljIGdldEhlYWRlcihzb3VyY2Upe1xyXG4gICAgaWYoc291cmNlICYmIHNvdXJjZS50YWdOYW1lID09ICdUQUJMRScpe1xyXG4gICAgICBsZXQgaGVhZGVyID0gc291cmNlLnF1ZXJ5U2VsZWN0b3IoXCJ0aGVhZFwiKTtcclxuICAgICAgaWYoaGVhZGVyICYmIGhlYWRlci5jaGlsZHJlbi5sZW5ndGg+MCkge1xyXG4gICAgICAgIHJldHVybiBoZWFkZXI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYHNvdXJjZWAgdGFibGUgaGFzIG5vIGhlYWRlciBvciByb3dzJyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Bzb3VyY2VgIGlzIG5vdCBzcGVjaWZpZWQgb3IgaXMgbm90IGEgdGFibGUnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgZGVmYXVsdEhlYWRlclJvdyBmb3IgYSBwYXNzZWQgYHRoZWFkYFxyXG4gICAqIEBwYXJhbSB7IUhUTUxUYWJsZUVsZW1lbnR9IHRoZWFkIC0gc291cmNlIHRhYmxlIGhlYWRlclxyXG4gICAqIEBwYXJhbSB7IU51bWJlcn0gZGVmYXVsdEhlYWRlclJvd0luZGV4IC0gaW5kZXggb2YgdGhlIHJvdyBpbiBgdGhlYWRgIChpbmNyZW1lbnRlZCBmcm9tIDApIHRoYXQgd2lsbCBiZSBjb25zaWRlcmVkIGRlZmF1bHQgdG8gaGF2ZSBhY3Rpb25zIGV4ZWN1dGVkIHVwb24uXHJcbiAgICogQHJldHVybiB7e2luZGV4Ok51bWJlciwgcm93OiBIVE1MVGFibGVSb3dFbGVtZW50fX1cclxuICAgKiAqL1xyXG4gIHN0YXRpYyBnZXREZWZhdWx0SGVhZGVyUm93KHRoZWFkLGRlZmF1bHRIZWFkZXJSb3dJbmRleCl7XHJcbiAgICAvLyBjYWxjdWxhdGUgZGVmYXVsdCBoZWFkZXIgcm93XHJcbiAgICBsZXQgaGVhZGVyUm93cyA9IHRoZWFkLmNoaWxkcmVuLFxyXG4gICAgICBoZWFkZXJSb3dJbmRleCA9IGRlZmF1bHRIZWFkZXJSb3dJbmRleD09LTEgPyBoZWFkZXJSb3dzLmxlbmd0aCArIGRlZmF1bHRIZWFkZXJSb3dJbmRleCA6IGRlZmF1bHRIZWFkZXJSb3dJbmRleDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGluZGV4OmhlYWRlclJvd0luZGV4LFxyXG4gICAgICByb3c6aGVhZGVyUm93cy5pdGVtKGhlYWRlclJvd0luZGV4KVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYW4gYXJyYXkgb2YgaGVhZGVyIGNlbGwgbm9kZXMgZnJvbSBkZWZhdWx0IGhlYWRlciByb3dcclxuICAgKiBAcGFyYW0gez9IVE1MVGFibGVFbGVtZW50fSB0aGVhZCAtIHNvdXJjZSB0YWJsZSBoZWFkZXJcclxuICAgKiBAcGFyYW0geyFOdW1iZXJ9IGRlZmF1bHRIZWFkZXJSb3dJbmRleCAtIGluZGV4IG9mIHRoZSByb3cgaW4gYHRoZWFkYCAoaW5jcmVtZW50ZWQgZnJvbSAwKSB0aGF0IHdpbGwgYmUgY29uc2lkZXJlZCBkZWZhdWx0IHRvIGhhdmUgYWN0aW9ucyBleGVjdXRlZCB1cG9uLlxyXG4gICAqIEByZXR1cm4gez9BcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBoZWFkZXIgY2VsbCBub2RlcyBvciBudWxsIGlmIGB0aGVhZGAgaXMgbm90IHNwZWNpZmllZFxyXG4gICAqICovXHJcbiAgc3RhdGljIGdldEhlYWRlckNlbGxzKHRoZWFkLGRlZmF1bHRIZWFkZXJSb3dJbmRleCl7XHJcbiAgICBpZih0aGVhZCl7XHJcbiAgICAgIGlmKGRlZmF1bHRIZWFkZXJSb3dJbmRleCE9bnVsbCl7XHJcbiAgICAgICAgbGV0IGRlZmF1bHRIZWFkZXJSb3cgPSBUYWJsZUNvbHVtbnMuZ2V0RGVmYXVsdEhlYWRlclJvdyh0aGVhZCxkZWZhdWx0SGVhZGVyUm93SW5kZXgpO1xyXG4gICAgICAgIGxldCBoZWFkZXJSb3dzID0gdGhlYWQuY2hpbGRyZW47XHJcbiAgICAgICAgbGV0IHJvd3NMZW5ndGggPSBoZWFkZXJSb3dzLmxlbmd0aDtcclxuICAgICAgICBsZXQgYWJzdHIgPSB7fTtcclxuICAgICAgICBmb3IobGV0IHI9MDtyPHJvd3NMZW5ndGg7cisrKXtcclxuICAgICAgICAgIGxldCByb3cgPSBoZWFkZXJSb3dzLml0ZW0ocik7XHJcbiAgICAgICAgICBsZXQgYXVnbWVudEluZGV4PTA7IC8vIGluZGV4IHRoYXQgd2lsbCBhY2NvdW50IGZvciBjb2xTcGFuIG9mIHVwcGVyIHJvd3MnIGNlbGxzXHJcbiAgICAgICAgICBbXS5zbGljZS5jYWxsKHJvdy5jaGlsZHJlbikuZm9yRWFjaCgoY2VsbCxpbmRleCk9PnsgLy9pdGVyYXRlIHRocm91Z2ggY2VsbHNcclxuICAgICAgICAgICAgZm9yKGxldCBycz0wOyByczw9Y2VsbC5yb3dTcGFuLTE7cnMrKyl7IC8vc3ByZWFkIGNlbGwgYWNyb3NzIGl0cyByb3dzcGFuXHJcbiAgICAgICAgICAgICAgbGV0IHJvd0EgPSBhYnN0cltyK3JzXSA9IGFic3RyW3IrcnNdIHx8IHt9OyAvL2NyZWF0ZSByb3cgaWYgbm90IGV4aXN0c1xyXG4gICAgICAgICAgICAgIGlmKCFyb3dBW2F1Z21lbnRJbmRleF0peyAvL2luc2VydCBjZWxsIGludG8gc2xvdCBpZiBub3QgZmlsbGVkXHJcbiAgICAgICAgICAgICAgICByb3dBW2F1Z21lbnRJbmRleF09Y2VsbDtcclxuICAgICAgICAgICAgICB9IGVsc2UgeyAvL2lmIGZpbGxlZCBsb29rIGZvciB0aGUgbmV4dCBlbXB0eSBiZWNhdXNlIHJvd3NwYW5uZWQgY29sdW1ucyBmaWxsIHRoZW0gaW4gYSBsaW5lYXIgd2F5XHJcbiAgICAgICAgICAgICAgICBsZXQgaT0wO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUodHJ1ZSl7XHJcbiAgICAgICAgICAgICAgICAgIGlmKCFyb3dBW2ldKXtcclxuICAgICAgICAgICAgICAgICAgICByb3dBW2ldPWNlbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgYXVnbWVudEluZGV4PWk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhdWdtZW50SW5kZXgrPWNlbGwuY29sU3BhbjtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhYnN0cltkZWZhdWx0SGVhZGVyUm93LmluZGV4XSkubWFwKGsgPT4gYWJzdHJbZGVmYXVsdEhlYWRlclJvdy5pbmRleF1ba10pXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGFibGVDb2x1bW5zLmdldEhlYWRlckNlbGxzOiBkZWZhdWx0SGVhZGVyUm93SW5kZXggaXMgbm90IHNwZWNpZmllZCBvciBpcyBub3QgYSBOdW1iZXInKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbiBhcnJheSBvZiBjb2x1bW5zIGZyb20gdGhlIHRhYmxlXHJcbiAgICogQHBhcmFtIHshSFRNTFRhYmxlRWxlbWVudH0gdGhlYWQgLSBzb3VyY2UgdGFibGUgaGVhZGVyXHJcbiAgICogQHBhcmFtIHshSFRNTFRhYmxlRWxlbWVudH0gcmVmVGhlYWQgLSByZWZlcmVuY2UgdGFibGUgaGVhZGVyIGZyb20gZmxvYXRpbmcgaGVhZGVyIGlmIGFueVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWZhdWx0SGVhZGVyUm93SW5kZXggLSBpbmRleCBvZiB0aGUgcm93IGluIGB0aGVhZGAgKGluY3JlbWVudGVkIGZyb20gMCkgdGhhdCB3aWxsIGJlIGNvbnNpZGVyZWQgZGVmYXVsdCB0byBoYXZlIGFjdGlvbnMgZXhlY3V0ZWQgdXBvbi5cclxuICAgKiBAcmV0dXJuIHs/QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgaGVhZGVyIGNlbGwgbm9kZXMgb3IgbnVsbCBpZiBgdGhlYWRgIGlzIG5vdCBzcGVjaWZpZWRcclxuICAgKiAqL1xyXG4gIHN0YXRpYyBjb21wdXRlQ29sdW1ucyh0aGVhZCxyZWZUaGVhZCxkZWZhdWx0SGVhZGVyUm93SW5kZXgpe1xyXG4gICAgbGV0IHRoZWFkQ2VsbHMgPSBUYWJsZUNvbHVtbnMuZ2V0SGVhZGVyQ2VsbHModGhlYWQsZGVmYXVsdEhlYWRlclJvd0luZGV4KTtcclxuICAgIGxldCByZWZUaGVhZENlbGxzID0gVGFibGVDb2x1bW5zLmdldEhlYWRlckNlbGxzKHJlZlRoZWFkLGRlZmF1bHRIZWFkZXJSb3dJbmRleCk7XHJcbiAgICBsZXQgcmVhbENvbHVtbkluZGV4PTA7XHJcbiAgICByZXR1cm4gdGhlYWRDZWxscy5tYXAoKGNlbGwsaW5kZXgpPT57XHJcbiAgICAgIGxldCBvYmogPSB7XHJcbiAgICAgICAgaW5kZXg6IHJlYWxDb2x1bW5JbmRleCxcclxuICAgICAgICB0aXRsZTogY2VsbC50ZXh0Q29udGVudCxcclxuICAgICAgICBjZWxsLFxyXG4gICAgICAgIGNvbFNwYW46Y2VsbC5jb2xTcGFuXHJcbiAgICAgIH07XHJcbiAgICAgIGlmKHJlZlRoZWFkQ2VsbHMhPW51bGwpe29iai5yZWZDZWxsID0gcmVmVGhlYWRDZWxsc1tpbmRleF19XHJcbiAgICAgIC8vIHdlIG5lZWQgdG8gaW5jcmVtZW50IHRoZSBjb2xzcGFuIG9ubHkgZm9yIGNvbHVtbnMgdGhhdCBmb2xsb3cgcm93aGVhZGVyIGJlY2F1c2UgdGhlIGJsb2NrIGlzIG5vdCBpbiBkYXRhLlxyXG4gICAgICByZWFsQ29sdW1uSW5kZXg9IHJlYWxDb2x1bW5JbmRleD4wPyhyZWFsQ29sdW1uSW5kZXggKyBjZWxsLmNvbFNwYW4pOnJlYWxDb2x1bW5JbmRleCsxO1xyXG4gICAgICByZXR1cm4gb2JqO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IFRhYmxlQ29sdW1ucztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yLXRhYmxlLWNvbHVtbnMvc3JjL3RhYmxlLWNvbHVtbnMuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TableFloatingHeaderStyle = __webpack_require__(17);\n\n/**\r\n * FixedHeader class enables a fixed header appear on tables that have `.reportal-fixed-header` class when the table header is scrolled under address bar.\r\n */\n\nvar TableFloatingHeader = function () {\n  /**\r\n   * @param {HTMLTableElement} source - source table that needs a cloned header\r\n   * */\n  function TableFloatingHeader(source) {\n    var _this = this;\n\n    _classCallCheck(this, TableFloatingHeader);\n\n    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) == undefined || source.tagName != 'TABLE') {\n      throw new TypeError('`source` must be defined and must be a table');\n    }\n\n    TableFloatingHeader.wrapTable(source);\n\n    /**\r\n     *  The cloned floating header without TBODY\r\n     *  @type {HTMLTableElement}\r\n     *  @memberOf TableFloatingHeader\r\n     *  */\n    this.header = TableFloatingHeader.cloneHeader(source);\n\n    /**\r\n     *  The source table\r\n     *  @type {HTMLTableElement}\r\n     *  @memberOf TableFloatingHeader\r\n     *  */\n    this.source = source;\n    /**\r\n     *  Visibility status of the table\r\n     *  @type {Boolean}\r\n     *  @memberOf TableFloatingHeader\r\n     *  */\n    this.visible = false;\n\n    this._meta = {\n      lastScrollY: 0,\n      sourceTHEAD: source.querySelector('thead'),\n      ticking: false\n    };\n\n    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n\n    this.resizeFixed();\n\n    window.addEventListener(\"resize\", function () {\n      return _this.resizeFixed.call(_this);\n    }, false); // attach a resize listener to resize the header\n    window.addEventListener(\"scroll\", function () {\n      return _this.scrollFixed.call(_this);\n    }, false); // attach a resize listener to resize the header\n  }\n\n  /**\r\n   * calculates offset height of the table\r\n   * @param {HTMLTableElement} source - source table\r\n   * */\n\n\n  _createClass(TableFloatingHeader, [{\n    key: 'requestTick',\n\n\n    /**\r\n     * function that polls the callback\r\n     * @param {Function} callback - function that's going to be passed to `requestAnimationFrame` for execution\r\n     * */\n    value: function requestTick(callback) {\n      if (!this._meta.ticking) {\n        requestAnimationFrame(callback);\n        this._meta.ticking = true;\n      }\n    }\n  }, {\n    key: 'resizeFixed',\n\n\n    /**\r\n     * Calculates widths for all columns in the fixed header based on the `source`\r\n     * */\n    value: function resizeFixed() {\n      this.requestTick(TableFloatingHeader._resizeCallback.bind(this));\n    }\n  }, {\n    key: 'scrollFixed',\n\n\n    /**\r\n     * Displays a fixed header when the table header is scrolled off the screen\r\n     * */\n    value: function scrollFixed() {\n      this._meta.lastScrollY = window.pageYOffset;\n      this.requestTick(TableFloatingHeader._scrollCallback.bind(this));\n    }\n  }], [{\n    key: 'calcOffsetHeight',\n    value: function calcOffsetHeight(source) {\n      this._meta.tableOffsetTop = source.parentNode.offsetTop;\n      this._meta.tableOffsetBottom = source.parentNode.offsetTop + source.offsetHeight - this._meta.sourceTHEAD.offsetHeight;\n    }\n\n    /**\r\n     * Event reporting that a header is visible\r\n     * @event TableFloatingHeader~reportal-fixed-header-visible\r\n     */\n\n    /**\r\n     * Event reporting that a header is hidden\r\n     * @event TableFloatingHeader~reportal-fixed-header-hidden\r\n     */\n\n    /**\r\n     * sets visibility of the table\r\n     * @param {HTMLTableElement} source - source table\r\n     * @param {HTMLTableElement} header - cloned table with header only\r\n     * @param {Boolean} visible - visibility status\r\n     * @fires TableFloatingHeader~reportal-fixed-header-visible\r\n     * @fires TableFloatingHeader~reportal-fixed-header-visible\r\n     * */\n\n  }, {\n    key: 'setVisibility',\n    value: function setVisibility(source, header, visible) {\n      if (visible) {\n        header.style.display = 'table';\n        source.dispatchEvent(_rReportalBase2.default.newEvent('reportal-fixed-header-visible'));\n      } else {\n        header.style.display = 'none';\n        source.dispatchEvent(_rReportalBase2.default.newEvent('reportal-fixed-header-hidden'));\n      }\n    }\n\n    /**\r\n     * wraps the `source` table into a `div.aggregatedTableContainer`\r\n     * */\n\n  }, {\n    key: 'wrapTable',\n    value: function wrapTable(source) {\n      var wrapper = document.createElement('div');\n      wrapper.classList.add('aggregatedTableContainer');\n      source.parentNode.appendChild(wrapper);\n      wrapper.appendChild(source);\n    }\n\n    /**\r\n     * clones header of `source` table and appends to wrapper\r\n     * */\n\n  }, {\n    key: 'cloneHeader',\n    value: function cloneHeader(source) {\n      var header = source.cloneNode(true);\n      header.classList.add('fixed');\n      source.parentNode.appendChild(header);\n      [].slice.call(header.children).forEach(function (child) {\n        if (child.nodeName == 'TBODY') {\n          header.removeChild(child);\n        }\n      });\n      return header;\n    }\n  }, {\n    key: '_resizeCallback',\n    value: function _resizeCallback() {\n      var initialHeader = this._meta.sourceTHEAD.querySelectorAll('tr>*'),\n          clonedHeader = this.header.querySelectorAll('thead>tr>*'),\n          headerWidth = this.source.offsetWidth + 'px',\n          widths = [];\n      // do reflow\n      for (var i = 0; i < initialHeader.length; i++) {\n        widths.push(initialHeader[i].offsetWidth);\n      }\n      //do repaint\n      for (var c = 0; c < clonedHeader.length; c++) {\n        clonedHeader[c].style.width = widths[c] + 'px';\n      }\n      this.header.style.width = headerWidth;\n\n      TableFloatingHeader.calcOffsetHeight.call(this, this.source); //recalc height of the table after reflow\n      this._meta.ticking = false;\n      this.scrollFixed(); // to compensate top offset in case after resize the table is less in height and top has changed\n    }\n  }, {\n    key: '_scrollCallback',\n    value: function _scrollCallback() {\n      var offset = this._meta.lastScrollY,\n          tableOffsetTop = this._meta.tableOffsetTop,\n          tableOffsetBottom = this._meta.tableOffsetBottom;\n      if ((offset < tableOffsetTop || offset > tableOffsetBottom) && this.visible) {\n        this.visible = false;\n        TableFloatingHeader.setVisibility(this.source, this.header, false);\n      } else if (offset >= tableOffsetTop && offset <= tableOffsetBottom) {\n        this.header.style.top = offset - tableOffsetTop + 'px';\n        if (!this.visible) {\n          this.visible = true;\n          TableFloatingHeader.setVisibility(this.source, this.header, true);\n        }\n      }\n      this._meta.ticking = false;\n    }\n  }]);\n\n  return TableFloatingHeader;\n}();\n\nexports.default = TableFloatingHeader;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItdGFibGUtZmxvYXRpbmctaGVhZGVyL3NyYy90YWJsZS1mbG9hdGluZy1oZWFkZXIuanM/NzdhNyJdLCJuYW1lcyI6WyJUYWJsZUZsb2F0aW5nSGVhZGVyU3R5bGUiLCJyZXF1aXJlIiwiVGFibGVGbG9hdGluZ0hlYWRlciIsInNvdXJjZSIsInVuZGVmaW5lZCIsInRhZ05hbWUiLCJUeXBlRXJyb3IiLCJ3cmFwVGFibGUiLCJoZWFkZXIiLCJjbG9uZUhlYWRlciIsInZpc2libGUiLCJfbWV0YSIsImxhc3RTY3JvbGxZIiwic291cmNlVEhFQUQiLCJxdWVyeVNlbGVjdG9yIiwidGlja2luZyIsIndpbmRvdyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicmVzaXplRml4ZWQiLCJhZGRFdmVudExpc3RlbmVyIiwiY2FsbCIsInNjcm9sbEZpeGVkIiwiY2FsbGJhY2siLCJyZXF1ZXN0VGljayIsIl9yZXNpemVDYWxsYmFjayIsImJpbmQiLCJwYWdlWU9mZnNldCIsIl9zY3JvbGxDYWxsYmFjayIsInRhYmxlT2Zmc2V0VG9wIiwicGFyZW50Tm9kZSIsIm9mZnNldFRvcCIsInRhYmxlT2Zmc2V0Qm90dG9tIiwib2Zmc2V0SGVpZ2h0Iiwic3R5bGUiLCJkaXNwbGF5IiwiZGlzcGF0Y2hFdmVudCIsIm5ld0V2ZW50Iiwid3JhcHBlciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTGlzdCIsImFkZCIsImFwcGVuZENoaWxkIiwiY2xvbmVOb2RlIiwic2xpY2UiLCJjaGlsZHJlbiIsImZvckVhY2giLCJjaGlsZCIsIm5vZGVOYW1lIiwicmVtb3ZlQ2hpbGQiLCJpbml0aWFsSGVhZGVyIiwicXVlcnlTZWxlY3RvckFsbCIsImNsb25lZEhlYWRlciIsImhlYWRlcldpZHRoIiwib2Zmc2V0V2lkdGgiLCJ3aWR0aHMiLCJpIiwibGVuZ3RoIiwicHVzaCIsImMiLCJ3aWR0aCIsImNhbGNPZmZzZXRIZWlnaHQiLCJvZmZzZXQiLCJzZXRWaXNpYmlsaXR5IiwidG9wIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBRUEsSUFBSUEsMkJBQTJCLG1CQUFBQyxDQUFRLEVBQVIsQ0FBL0I7O0FBRUE7Ozs7SUFHTUMsbUI7QUFDSjs7O0FBR0EsK0JBQVlDLE1BQVosRUFBbUI7QUFBQTs7QUFBQTs7QUFDakIsUUFBRyxRQUFPQSxNQUFQLHlDQUFPQSxNQUFQLE1BQWlCQyxTQUFqQixJQUE4QkQsT0FBT0UsT0FBUCxJQUFrQixPQUFuRCxFQUEyRDtBQUN6RCxZQUFNLElBQUlDLFNBQUosQ0FBYyw4Q0FBZCxDQUFOO0FBQ0Q7O0FBRURKLHdCQUFvQkssU0FBcEIsQ0FBOEJKLE1BQTlCOztBQUVBOzs7OztBQUtBLFNBQUtLLE1BQUwsR0FBZU4sb0JBQW9CTyxXQUFwQixDQUFnQ04sTUFBaEMsQ0FBZjs7QUFFQTs7Ozs7QUFLQSxTQUFLQSxNQUFMLEdBQWNBLE1BQWQ7QUFDQTs7Ozs7QUFLQSxTQUFLTyxPQUFMLEdBQWUsS0FBZjs7QUFFQSxTQUFLQyxLQUFMLEdBQWE7QUFDWEMsbUJBQVksQ0FERDtBQUVYQyxtQkFBYVYsT0FBT1csYUFBUCxDQUFxQixPQUFyQixDQUZGO0FBR1hDLGVBQVE7QUFIRyxLQUFiOztBQU1BQyxXQUFPQyxxQkFBUCxHQUErQkQsT0FBT0MscUJBQVAsSUFBZ0NELE9BQU9FLHdCQUF2QyxJQUFtRUYsT0FBT0csMkJBQTFFLElBQXlHSCxPQUFPSSx1QkFBL0k7O0FBRUEsU0FBS0MsV0FBTDs7QUFFQUwsV0FBT00sZ0JBQVAsQ0FBd0IsUUFBeEIsRUFBa0M7QUFBQSxhQUFJLE1BQUtELFdBQUwsQ0FBaUJFLElBQWpCLE9BQUo7QUFBQSxLQUFsQyxFQUFtRSxLQUFuRSxFQXJDaUIsQ0FxQzBEO0FBQzNFUCxXQUFPTSxnQkFBUCxDQUF3QixRQUF4QixFQUFrQztBQUFBLGFBQUksTUFBS0UsV0FBTCxDQUFpQkQsSUFBakIsT0FBSjtBQUFBLEtBQWxDLEVBQW1FLEtBQW5FLEVBdENpQixDQXNDMEQ7QUFDNUU7O0FBRUQ7Ozs7Ozs7Ozs7QUE4REE7Ozs7Z0NBSVlFLFEsRUFBUztBQUNuQixVQUFHLENBQUMsS0FBS2QsS0FBTCxDQUFXSSxPQUFmLEVBQXdCO0FBQ3RCRSw4QkFBc0JRLFFBQXRCO0FBQ0EsYUFBS2QsS0FBTCxDQUFXSSxPQUFYLEdBQXFCLElBQXJCO0FBQ0Q7QUFDRjs7Ozs7QUFzQkQ7OztrQ0FHYTtBQUNYLFdBQUtXLFdBQUwsQ0FBaUJ4QixvQkFBb0J5QixlQUFwQixDQUFvQ0MsSUFBcEMsQ0FBeUMsSUFBekMsQ0FBakI7QUFDRDs7Ozs7QUFzQkQ7OztrQ0FHYztBQUNWLFdBQUtqQixLQUFMLENBQVdDLFdBQVgsR0FBeUJJLE9BQU9hLFdBQWhDO0FBQ0EsV0FBS0gsV0FBTCxDQUFpQnhCLG9CQUFvQjRCLGVBQXBCLENBQW9DRixJQUFwQyxDQUF5QyxJQUF6QyxDQUFqQjtBQUNIOzs7cUNBMUh1QnpCLE0sRUFBTztBQUM3QixXQUFLUSxLQUFMLENBQVdvQixjQUFYLEdBQTRCNUIsT0FBTzZCLFVBQVAsQ0FBa0JDLFNBQTlDO0FBQ0EsV0FBS3RCLEtBQUwsQ0FBV3VCLGlCQUFYLEdBQStCL0IsT0FBTzZCLFVBQVAsQ0FBa0JDLFNBQWxCLEdBQThCOUIsT0FBT2dDLFlBQXJDLEdBQW9ELEtBQUt4QixLQUFMLENBQVdFLFdBQVgsQ0FBdUJzQixZQUExRztBQUNEOztBQUVEOzs7OztBQUtBOzs7OztBQUtBOzs7Ozs7Ozs7OztrQ0FRcUJoQyxNLEVBQVFLLE0sRUFBUUUsTyxFQUFRO0FBQzNDLFVBQUdBLE9BQUgsRUFBVztBQUNURixlQUFPNEIsS0FBUCxDQUFhQyxPQUFiLEdBQXFCLE9BQXJCO0FBQ0FsQyxlQUFPbUMsYUFBUCxDQUFxQix3QkFBYUMsUUFBYixDQUFzQiwrQkFBdEIsQ0FBckI7QUFDRCxPQUhELE1BR087QUFDTC9CLGVBQU80QixLQUFQLENBQWFDLE9BQWIsR0FBcUIsTUFBckI7QUFDQWxDLGVBQU9tQyxhQUFQLENBQXFCLHdCQUFhQyxRQUFiLENBQXNCLDhCQUF0QixDQUFyQjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs4QkFHaUJwQyxNLEVBQU87QUFDdEIsVUFBSXFDLFVBQVVDLFNBQVNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBZDtBQUNBRixjQUFRRyxTQUFSLENBQWtCQyxHQUFsQixDQUFzQiwwQkFBdEI7QUFDQXpDLGFBQU82QixVQUFQLENBQWtCYSxXQUFsQixDQUE4QkwsT0FBOUI7QUFDQUEsY0FBUUssV0FBUixDQUFvQjFDLE1BQXBCO0FBQ0Q7O0FBRUQ7Ozs7OztnQ0FHbUJBLE0sRUFBTztBQUN4QixVQUFJSyxTQUFTTCxPQUFPMkMsU0FBUCxDQUFpQixJQUFqQixDQUFiO0FBQ0F0QyxhQUFPbUMsU0FBUCxDQUFpQkMsR0FBakIsQ0FBcUIsT0FBckI7QUFDQXpDLGFBQU82QixVQUFQLENBQWtCYSxXQUFsQixDQUE4QnJDLE1BQTlCO0FBQ0EsU0FBR3VDLEtBQUgsQ0FBU3hCLElBQVQsQ0FBY2YsT0FBT3dDLFFBQXJCLEVBQStCQyxPQUEvQixDQUF1QyxpQkFBTztBQUM1QyxZQUFHQyxNQUFNQyxRQUFOLElBQWdCLE9BQW5CLEVBQTJCO0FBQ3pCM0MsaUJBQU80QyxXQUFQLENBQW1CRixLQUFuQjtBQUNEO0FBQ0YsT0FKRDtBQUtBLGFBQU8xQyxNQUFQO0FBQ0Q7OztzQ0FhdUI7QUFDdEIsVUFBSTZDLGdCQUFnQixLQUFLMUMsS0FBTCxDQUFXRSxXQUFYLENBQXVCeUMsZ0JBQXZCLENBQXdDLE1BQXhDLENBQXBCO0FBQUEsVUFDRUMsZUFBZSxLQUFLL0MsTUFBTCxDQUFZOEMsZ0JBQVosQ0FBNkIsWUFBN0IsQ0FEakI7QUFBQSxVQUVFRSxjQUFjLEtBQUtyRCxNQUFMLENBQVlzRCxXQUFaLEdBQTBCLElBRjFDO0FBQUEsVUFHRUMsU0FBTyxFQUhUO0FBSUE7QUFDQSxXQUFJLElBQUlDLElBQUUsQ0FBVixFQUFZQSxJQUFFTixjQUFjTyxNQUE1QixFQUFtQ0QsR0FBbkMsRUFBdUM7QUFDckNELGVBQU9HLElBQVAsQ0FBWVIsY0FBY00sQ0FBZCxFQUFpQkYsV0FBN0I7QUFDRDtBQUNEO0FBQ0EsV0FBSSxJQUFJSyxJQUFFLENBQVYsRUFBWUEsSUFBRVAsYUFBYUssTUFBM0IsRUFBa0NFLEdBQWxDLEVBQXNDO0FBQ3BDUCxxQkFBYU8sQ0FBYixFQUFnQjFCLEtBQWhCLENBQXNCMkIsS0FBdEIsR0FBOEJMLE9BQU9JLENBQVAsSUFBWSxJQUExQztBQUNEO0FBQ0QsV0FBS3RELE1BQUwsQ0FBWTRCLEtBQVosQ0FBa0IyQixLQUFsQixHQUEwQlAsV0FBMUI7O0FBRUF0RCwwQkFBb0I4RCxnQkFBcEIsQ0FBcUN6QyxJQUFyQyxDQUEwQyxJQUExQyxFQUErQyxLQUFLcEIsTUFBcEQsRUFmc0IsQ0FldUM7QUFDN0QsV0FBS1EsS0FBTCxDQUFXSSxPQUFYLEdBQW1CLEtBQW5CO0FBQ0EsV0FBS1MsV0FBTCxHQWpCc0IsQ0FpQkY7QUFDckI7OztzQ0FVdUI7QUFDdEIsVUFBSXlDLFNBQVMsS0FBS3RELEtBQUwsQ0FBV0MsV0FBeEI7QUFBQSxVQUNFbUIsaUJBQWlCLEtBQUtwQixLQUFMLENBQVdvQixjQUQ5QjtBQUFBLFVBRUVHLG9CQUFvQixLQUFLdkIsS0FBTCxDQUFXdUIsaUJBRmpDO0FBR0EsVUFBRyxDQUFDK0IsU0FBU2xDLGNBQVQsSUFBMkJrQyxTQUFTL0IsaUJBQXJDLEtBQTJELEtBQUt4QixPQUFuRSxFQUEyRTtBQUN6RSxhQUFLQSxPQUFMLEdBQWUsS0FBZjtBQUNBUiw0QkFBb0JnRSxhQUFwQixDQUFrQyxLQUFLL0QsTUFBdkMsRUFBOEMsS0FBS0ssTUFBbkQsRUFBMEQsS0FBMUQ7QUFDRCxPQUhELE1BSUssSUFBR3lELFVBQVVsQyxjQUFWLElBQTRCa0MsVUFBVS9CLGlCQUF6QyxFQUEyRDtBQUM5RCxhQUFLMUIsTUFBTCxDQUFZNEIsS0FBWixDQUFrQitCLEdBQWxCLEdBQXNCRixTQUFPbEMsY0FBUCxHQUFzQixJQUE1QztBQUNBLFlBQUcsQ0FBQyxLQUFLckIsT0FBVCxFQUFpQjtBQUNmLGVBQUtBLE9BQUwsR0FBYSxJQUFiO0FBQ0FSLDhCQUFvQmdFLGFBQXBCLENBQWtDLEtBQUsvRCxNQUF2QyxFQUE4QyxLQUFLSyxNQUFuRCxFQUEwRCxJQUExRDtBQUNEO0FBQ0Y7QUFDRCxXQUFLRyxLQUFMLENBQVdJLE9BQVgsR0FBbUIsS0FBbkI7QUFDRDs7Ozs7O2tCQWFZYixtQiIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZXBvcnRhbEJhc2UgZnJvbSBcInItcmVwb3J0YWwtYmFzZVwiO1xyXG5cclxudmFyIFRhYmxlRmxvYXRpbmdIZWFkZXJTdHlsZSA9IHJlcXVpcmUoJy4vdGFibGUtZmxvYXRpbmctaGVhZGVyLXN0eWxlcy5jc3MnKTtcclxuXHJcbi8qKlxyXG4gKiBGaXhlZEhlYWRlciBjbGFzcyBlbmFibGVzIGEgZml4ZWQgaGVhZGVyIGFwcGVhciBvbiB0YWJsZXMgdGhhdCBoYXZlIGAucmVwb3J0YWwtZml4ZWQtaGVhZGVyYCBjbGFzcyB3aGVuIHRoZSB0YWJsZSBoZWFkZXIgaXMgc2Nyb2xsZWQgdW5kZXIgYWRkcmVzcyBiYXIuXHJcbiAqL1xyXG5jbGFzcyBUYWJsZUZsb2F0aW5nSGVhZGVyIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge0hUTUxUYWJsZUVsZW1lbnR9IHNvdXJjZSAtIHNvdXJjZSB0YWJsZSB0aGF0IG5lZWRzIGEgY2xvbmVkIGhlYWRlclxyXG4gICAqICovXHJcbiAgY29uc3RydWN0b3Ioc291cmNlKXtcclxuICAgIGlmKHR5cGVvZiBzb3VyY2UgPT0gdW5kZWZpbmVkIHx8IHNvdXJjZS50YWdOYW1lICE9ICdUQUJMRScpe1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgc291cmNlYCBtdXN0IGJlIGRlZmluZWQgYW5kIG11c3QgYmUgYSB0YWJsZScpXHJcbiAgICB9XHJcblxyXG4gICAgVGFibGVGbG9hdGluZ0hlYWRlci53cmFwVGFibGUoc291cmNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqICBUaGUgY2xvbmVkIGZsb2F0aW5nIGhlYWRlciB3aXRob3V0IFRCT0RZXHJcbiAgICAgKiAgQHR5cGUge0hUTUxUYWJsZUVsZW1lbnR9XHJcbiAgICAgKiAgQG1lbWJlck9mIFRhYmxlRmxvYXRpbmdIZWFkZXJcclxuICAgICAqICAqL1xyXG4gICAgdGhpcy5oZWFkZXIgID0gVGFibGVGbG9hdGluZ0hlYWRlci5jbG9uZUhlYWRlcihzb3VyY2UpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBzb3VyY2UgdGFibGVcclxuICAgICAqICBAdHlwZSB7SFRNTFRhYmxlRWxlbWVudH1cclxuICAgICAqICBAbWVtYmVyT2YgVGFibGVGbG9hdGluZ0hlYWRlclxyXG4gICAgICogICovXHJcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgIC8qKlxyXG4gICAgICogIFZpc2liaWxpdHkgc3RhdHVzIG9mIHRoZSB0YWJsZVxyXG4gICAgICogIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogIEBtZW1iZXJPZiBUYWJsZUZsb2F0aW5nSGVhZGVyXHJcbiAgICAgKiAgKi9cclxuICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuX21ldGEgPSB7XHJcbiAgICAgIGxhc3RTY3JvbGxZOjAsXHJcbiAgICAgIHNvdXJjZVRIRUFEOiBzb3VyY2UucXVlcnlTZWxlY3RvcigndGhlYWQnKSxcclxuICAgICAgdGlja2luZzpmYWxzZVxyXG4gICAgfTtcclxuXHJcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xyXG5cclxuICAgIHRoaXMucmVzaXplRml4ZWQoKTtcclxuXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCAoKT0+dGhpcy5yZXNpemVGaXhlZC5jYWxsKHRoaXMpLCBmYWxzZSk7IC8vIGF0dGFjaCBhIHJlc2l6ZSBsaXN0ZW5lciB0byByZXNpemUgdGhlIGhlYWRlclxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgKCk9PnRoaXMuc2Nyb2xsRml4ZWQuY2FsbCh0aGlzKSwgZmFsc2UpOyAvLyBhdHRhY2ggYSByZXNpemUgbGlzdGVuZXIgdG8gcmVzaXplIHRoZSBoZWFkZXJcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGNhbGN1bGF0ZXMgb2Zmc2V0IGhlaWdodCBvZiB0aGUgdGFibGVcclxuICAgKiBAcGFyYW0ge0hUTUxUYWJsZUVsZW1lbnR9IHNvdXJjZSAtIHNvdXJjZSB0YWJsZVxyXG4gICAqICovXHJcbiAgc3RhdGljIGNhbGNPZmZzZXRIZWlnaHQoc291cmNlKXtcclxuICAgIHRoaXMuX21ldGEudGFibGVPZmZzZXRUb3AgPSBzb3VyY2UucGFyZW50Tm9kZS5vZmZzZXRUb3A7XHJcbiAgICB0aGlzLl9tZXRhLnRhYmxlT2Zmc2V0Qm90dG9tID0gc291cmNlLnBhcmVudE5vZGUub2Zmc2V0VG9wICsgc291cmNlLm9mZnNldEhlaWdodCAtIHRoaXMuX21ldGEuc291cmNlVEhFQUQub2Zmc2V0SGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRXZlbnQgcmVwb3J0aW5nIHRoYXQgYSBoZWFkZXIgaXMgdmlzaWJsZVxyXG4gICAqIEBldmVudCBUYWJsZUZsb2F0aW5nSGVhZGVyfnJlcG9ydGFsLWZpeGVkLWhlYWRlci12aXNpYmxlXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEV2ZW50IHJlcG9ydGluZyB0aGF0IGEgaGVhZGVyIGlzIGhpZGRlblxyXG4gICAqIEBldmVudCBUYWJsZUZsb2F0aW5nSGVhZGVyfnJlcG9ydGFsLWZpeGVkLWhlYWRlci1oaWRkZW5cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogc2V0cyB2aXNpYmlsaXR5IG9mIHRoZSB0YWJsZVxyXG4gICAqIEBwYXJhbSB7SFRNTFRhYmxlRWxlbWVudH0gc291cmNlIC0gc291cmNlIHRhYmxlXHJcbiAgICogQHBhcmFtIHtIVE1MVGFibGVFbGVtZW50fSBoZWFkZXIgLSBjbG9uZWQgdGFibGUgd2l0aCBoZWFkZXIgb25seVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSAtIHZpc2liaWxpdHkgc3RhdHVzXHJcbiAgICogQGZpcmVzIFRhYmxlRmxvYXRpbmdIZWFkZXJ+cmVwb3J0YWwtZml4ZWQtaGVhZGVyLXZpc2libGVcclxuICAgKiBAZmlyZXMgVGFibGVGbG9hdGluZ0hlYWRlcn5yZXBvcnRhbC1maXhlZC1oZWFkZXItdmlzaWJsZVxyXG4gICAqICovXHJcbiAgc3RhdGljIHNldFZpc2liaWxpdHkoc291cmNlLCBoZWFkZXIsIHZpc2libGUpe1xyXG4gICAgaWYodmlzaWJsZSl7XHJcbiAgICAgIGhlYWRlci5zdHlsZS5kaXNwbGF5PSd0YWJsZSc7XHJcbiAgICAgIHNvdXJjZS5kaXNwYXRjaEV2ZW50KFJlcG9ydGFsQmFzZS5uZXdFdmVudCgncmVwb3J0YWwtZml4ZWQtaGVhZGVyLXZpc2libGUnKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBoZWFkZXIuc3R5bGUuZGlzcGxheT0nbm9uZSc7XHJcbiAgICAgIHNvdXJjZS5kaXNwYXRjaEV2ZW50KFJlcG9ydGFsQmFzZS5uZXdFdmVudCgncmVwb3J0YWwtZml4ZWQtaGVhZGVyLWhpZGRlbicpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHdyYXBzIHRoZSBgc291cmNlYCB0YWJsZSBpbnRvIGEgYGRpdi5hZ2dyZWdhdGVkVGFibGVDb250YWluZXJgXHJcbiAgICogKi9cclxuICBzdGF0aWMgd3JhcFRhYmxlKHNvdXJjZSl7XHJcbiAgICBsZXQgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdhZ2dyZWdhdGVkVGFibGVDb250YWluZXInKTtcclxuICAgIHNvdXJjZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHdyYXBwZXIpO1xyXG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChzb3VyY2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogY2xvbmVzIGhlYWRlciBvZiBgc291cmNlYCB0YWJsZSBhbmQgYXBwZW5kcyB0byB3cmFwcGVyXHJcbiAgICogKi9cclxuICBzdGF0aWMgY2xvbmVIZWFkZXIoc291cmNlKXtcclxuICAgIGxldCBoZWFkZXIgPSBzb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgaGVhZGVyLmNsYXNzTGlzdC5hZGQoJ2ZpeGVkJyk7XHJcbiAgICBzb3VyY2UucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChoZWFkZXIpO1xyXG4gICAgW10uc2xpY2UuY2FsbChoZWFkZXIuY2hpbGRyZW4pLmZvckVhY2goY2hpbGQ9PntcclxuICAgICAgaWYoY2hpbGQubm9kZU5hbWU9PSdUQk9EWScpe1xyXG4gICAgICAgIGhlYWRlci5yZW1vdmVDaGlsZChjaGlsZCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGhlYWRlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGZ1bmN0aW9uIHRoYXQgcG9sbHMgdGhlIGNhbGxiYWNrXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBmdW5jdGlvbiB0aGF0J3MgZ29pbmcgdG8gYmUgcGFzc2VkIHRvIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGZvciBleGVjdXRpb25cclxuICAgKiAqL1xyXG4gIHJlcXVlc3RUaWNrKGNhbGxiYWNrKXtcclxuICAgIGlmKCF0aGlzLl9tZXRhLnRpY2tpbmcpIHtcclxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcclxuICAgICAgdGhpcy5fbWV0YS50aWNraW5nID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXRpYyBfcmVzaXplQ2FsbGJhY2soKXtcclxuICAgIGxldCBpbml0aWFsSGVhZGVyID0gdGhpcy5fbWV0YS5zb3VyY2VUSEVBRC5xdWVyeVNlbGVjdG9yQWxsKCd0cj4qJyksXHJcbiAgICAgIGNsb25lZEhlYWRlciA9IHRoaXMuaGVhZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RoZWFkPnRyPionKSxcclxuICAgICAgaGVhZGVyV2lkdGggPSB0aGlzLnNvdXJjZS5vZmZzZXRXaWR0aCArICdweCcsXHJcbiAgICAgIHdpZHRocz1bXTtcclxuICAgIC8vIGRvIHJlZmxvd1xyXG4gICAgZm9yKGxldCBpPTA7aTxpbml0aWFsSGVhZGVyLmxlbmd0aDtpKyspe1xyXG4gICAgICB3aWR0aHMucHVzaChpbml0aWFsSGVhZGVyW2ldLm9mZnNldFdpZHRoKTtcclxuICAgIH1cclxuICAgIC8vZG8gcmVwYWludFxyXG4gICAgZm9yKGxldCBjPTA7YzxjbG9uZWRIZWFkZXIubGVuZ3RoO2MrKyl7XHJcbiAgICAgIGNsb25lZEhlYWRlcltjXS5zdHlsZS53aWR0aCA9IHdpZHRoc1tjXSArICdweCc7XHJcbiAgICB9XHJcbiAgICB0aGlzLmhlYWRlci5zdHlsZS53aWR0aCA9IGhlYWRlcldpZHRoO1xyXG5cclxuICAgIFRhYmxlRmxvYXRpbmdIZWFkZXIuY2FsY09mZnNldEhlaWdodC5jYWxsKHRoaXMsdGhpcy5zb3VyY2UpOyAvL3JlY2FsYyBoZWlnaHQgb2YgdGhlIHRhYmxlIGFmdGVyIHJlZmxvd1xyXG4gICAgdGhpcy5fbWV0YS50aWNraW5nPWZhbHNlO1xyXG4gICAgdGhpcy5zY3JvbGxGaXhlZCgpOyAvLyB0byBjb21wZW5zYXRlIHRvcCBvZmZzZXQgaW4gY2FzZSBhZnRlciByZXNpemUgdGhlIHRhYmxlIGlzIGxlc3MgaW4gaGVpZ2h0IGFuZCB0b3AgaGFzIGNoYW5nZWRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgd2lkdGhzIGZvciBhbGwgY29sdW1ucyBpbiB0aGUgZml4ZWQgaGVhZGVyIGJhc2VkIG9uIHRoZSBgc291cmNlYFxyXG4gICAqICovXHJcbiAgcmVzaXplRml4ZWQoKXtcclxuICAgIHRoaXMucmVxdWVzdFRpY2soVGFibGVGbG9hdGluZ0hlYWRlci5fcmVzaXplQ2FsbGJhY2suYmluZCh0aGlzKSlcclxuICB9XHJcblxyXG5cclxuICBzdGF0aWMgX3Njcm9sbENhbGxiYWNrKCl7XHJcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5fbWV0YS5sYXN0U2Nyb2xsWSxcclxuICAgICAgdGFibGVPZmZzZXRUb3AgPSB0aGlzLl9tZXRhLnRhYmxlT2Zmc2V0VG9wLFxyXG4gICAgICB0YWJsZU9mZnNldEJvdHRvbSA9IHRoaXMuX21ldGEudGFibGVPZmZzZXRCb3R0b207XHJcbiAgICBpZigob2Zmc2V0IDwgdGFibGVPZmZzZXRUb3AgfHwgb2Zmc2V0ID4gdGFibGVPZmZzZXRCb3R0b20pICYmIHRoaXMudmlzaWJsZSl7XHJcbiAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICBUYWJsZUZsb2F0aW5nSGVhZGVyLnNldFZpc2liaWxpdHkodGhpcy5zb3VyY2UsdGhpcy5oZWFkZXIsZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZihvZmZzZXQgPj0gdGFibGVPZmZzZXRUb3AgJiYgb2Zmc2V0IDw9IHRhYmxlT2Zmc2V0Qm90dG9tKXtcclxuICAgICAgdGhpcy5oZWFkZXIuc3R5bGUudG9wPW9mZnNldC10YWJsZU9mZnNldFRvcCsncHgnO1xyXG4gICAgICBpZighdGhpcy52aXNpYmxlKXtcclxuICAgICAgICB0aGlzLnZpc2libGU9dHJ1ZTtcclxuICAgICAgICBUYWJsZUZsb2F0aW5nSGVhZGVyLnNldFZpc2liaWxpdHkodGhpcy5zb3VyY2UsdGhpcy5oZWFkZXIsdHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuX21ldGEudGlja2luZz1mYWxzZTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBEaXNwbGF5cyBhIGZpeGVkIGhlYWRlciB3aGVuIHRoZSB0YWJsZSBoZWFkZXIgaXMgc2Nyb2xsZWQgb2ZmIHRoZSBzY3JlZW5cclxuICAgKiAqL1xyXG4gIHNjcm9sbEZpeGVkKCkge1xyXG4gICAgICB0aGlzLl9tZXRhLmxhc3RTY3JvbGxZID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xyXG4gICAgICB0aGlzLnJlcXVlc3RUaWNrKFRhYmxlRmxvYXRpbmdIZWFkZXIuX3Njcm9sbENhbGxiYWNrLmJpbmQodGhpcykpO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRhYmxlRmxvYXRpbmdIZWFkZXI7XHJcblxyXG5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yLXRhYmxlLWZsb2F0aW5nLWhlYWRlci9zcmMvdGFibGUtZmxvYXRpbmctaGVhZGVyLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nvar _rAsyncHierarchyTable = __webpack_require__(6);\n\nvar _rAsyncHierarchyTable2 = _interopRequireDefault(_rAsyncHierarchyTable);\n\nvar _mapHierarchy = __webpack_require__(14);\n\nvar _mapHierarchy2 = _interopRequireDefault(_mapHierarchy);\n\nvar _rAggregatedTable = __webpack_require__(5);\n\nvar _rAggregatedTable2 = _interopRequireDefault(_rAggregatedTable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n__webpack_require__(19);\n\nvar DrilldownMap = function (_MapHierarchy) {\n  _inherits(DrilldownMap, _MapHierarchy);\n\n  /**\n   * Creates a drilldown map. It uses a color function `colorFn` that allows colorcode countries\n   * `colorFn` accepts two attributes: `value` and `target` and must return a color string based on those two attributes.\n   * Make sure hierarchy has `target` loaded from DBDesigner table into each hierarchy level, otherwise a default config `dataClasses` takes precedence on value\n   * Example:\n   *\n   *\n   *    {\n   *    //some constructor configuration above\n   *      colorFn: function(value,target){\n   *        return (value!=null && target!=null)? (value - target >= 0) ? \"#18BC9C\" : ((value >= 0.9*target) ? \"#FF4900\" : \"#E45335\") : undefined;\n   *      }\n   *     //some constructor configuration below\n   *    }\n   *\n    * @param {HTMLTableElement} source - a source drilldown table that contains the initial set of data(with reference group enabled and 1 child level)\n   * @param {String} tableID - id of the `source` table that is the initial source of data (from reportal backend)\n   * @param {Array} rowheaders - a rowheaders array for the loaded table\n   * @param {Object} hierarchy - a hierarchical object for a map to be built upon\n   * @param {String} [initMap=\"custom/world-highres2\"] - the initial map object that's going to be loaded to initialise the map\n   * @param {String} containerID - id of the container the map will be drawn to\n   * @param {Function} mappointCallback - executed when a mappoint (city) is clicked\n   * @param {Function} colorFn - A function that allows custom color coding computation based on value and target.\n   * @param {Number} [valueColumn=1] - Zero-based column index that contains primary value which will be used for map coloring.\n   * @param {Boolean} [fullParentLevelInfo=true] - Display full info of the parent level in right part of the map, rather than the parent level name and the primary value\n   * @param {String} [pageStateId=document.querySelector('#PageStateId').value] - PageStateId\n   * @param {Object} normals - an object where the keys are the names of columns taken from DBDesignerTable and values - their string types: `string`, `number`, `boolean`, `stringArray`, `numberArray`\n   * @param {String} [normalsSeparator=','] - delimiter between values in `stringArray` (`us-ca, us-tx, us-wy`) and `numberArray` (`-31.86,16.38`). They are served as a delimiter-separated string and the delimiter is `,` by default. If you use another one, make sure you specify it here\n   * @param {Object} [options={}] - options passed to HighMap to restyle/reconfigure it\n   * */\n  function DrilldownMap() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        source = _ref.source,\n        rowheaders = _ref.rowheaders,\n        hierarchy = _ref.hierarchy,\n        _ref$initMap = _ref.initMap,\n        initMap = _ref$initMap === undefined ? \"custom/world-highres2\" : _ref$initMap,\n        containerID = _ref.containerID,\n        mappointCallback = _ref.mappointCallback,\n        excludeColumns = _ref.excludeColumns,\n        excludeRows = _ref.excludeRows,\n        _ref$valueColumn = _ref.valueColumn,\n        valueColumn = _ref$valueColumn === undefined ? 1 : _ref$valueColumn,\n        _ref$fullParentLevelI = _ref.fullParentLevelInfo,\n        fullParentLevelInfo = _ref$fullParentLevelI === undefined ? true : _ref$fullParentLevelI,\n        _ref$colorFn = _ref.colorFn,\n        colorFn = _ref$colorFn === undefined ? function (value, target) {\n      return value != null ? value >= 80 ? \"#4caf50\" : value < 80 && value >= 60 ? \"#ffc107\" : \"#ff5722\" : \"blue\";\n    } : _ref$colorFn,\n        _ref$pageStateId = _ref.pageStateId,\n        pageStateId = _ref$pageStateId === undefined ? document.querySelector('#PageStateId') ? document.querySelector('#PageStateId').value : null : _ref$pageStateId,\n        tableID = _ref.tableID,\n        normals = _ref.normals,\n        _ref$normalsSeparator = _ref.normalsSeparator,\n        normalsSeparator = _ref$normalsSeparator === undefined ? \",\" : _ref$normalsSeparator,\n        _ref$options = _ref.options,\n        options = _ref$options === undefined ? {} : _ref$options;\n\n    _classCallCheck(this, DrilldownMap);\n\n    var _this = _possibleConstructorReturn(this, (DrilldownMap.__proto__ || Object.getPrototypeOf(DrilldownMap)).call(this, hierarchy, normals, normalsSeparator));\n\n    _this.constructor.parseTableData({ source: source, excludeRows: excludeRows, excludeColumns: excludeColumns, rowheaders: rowheaders.map(function (rh) {\n        return rh[0];\n      }), flatHierarchy: _this.flatHierarchy });\n    if (colorFn && typeof colorFn == \"function\") {\n      _this.colorFn = colorFn;\n    }\n    _this.valueColumn = valueColumn;\n    _this.pageStateId = pageStateId;\n    _this.tableID = tableID;\n    _this.fullParentLevelInfo = fullParentLevelInfo;\n\n    if (mappointCallback && mappointCallback != null) {\n      if (typeof mappointCallback == 'function') {\n        _this.mappointCallback = mappointCallback;\n      } else {\n        throw new TypeError(\"mappointCallback must be a function\");\n      }\n    }\n    var config = _this.config = _rReportalBase2.default.mixin(options, {/*colorAxis:{dataClasses}*/});\n    if ((typeof Highcharts === \"undefined\" ? \"undefined\" : _typeof(Highcharts)) == undefined) {\n      throw new Error('Highcharts must be declared. Probably they are missing');\n    }\n    if (_typeof(Highcharts.maps) == undefined) {\n      throw new Error('HighMaps must be loaded. Probably they are missing');\n    }\n    //\n    //this.drawMap(rowheaders, containerID, initMap, config);\n    return _this;\n  }\n\n  /**\n   * Parses table passed to it and adds data to `._data` in `hierarchy`\n   * @param {HTMLTableElement} source - source table for data\n   * @param {Number|Array} excludeRows - rows to be excluded from parsing\n   * @param {Array} rowheaders - array of `source` rowheaders\n   * @param {Object} flatHierarchy - flat hierarchy object\n   * */\n\n\n  _createClass(DrilldownMap, [{\n    key: \"initMap\",\n\n\n    /**\n     * Get series for the first time map initialization\n     * @param {Object} curLVL - current level in hierarchy\n     * @param {Array} [series=[]] - series\n     * @returns {Array}\n     * */\n    value: function initMap(curLVL) {\n      var _this2 = this;\n\n      var series = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      curLVL.subcells.forEach(function (subcell) {\n        if (subcell.mapID) {\n          var seriesItem = _this2.composeSeries(subcell);\n          series.push(seriesItem);\n        }\n      });\n      return series;\n    }\n\n    /**\n     * Load map from HighMaps map collection\n     * @param {String} source\n     * @returns {Promise}\n     * */\n\n  }, {\n    key: \"getSeriesData\",\n\n\n    /**\n     * Creates a single series data for HighMap series option\n     * @param {Object} level - a level in hierarchy\n     * @returns {Object}\n     * */\n    value: function getSeriesData(level) {\n      var _this3 = this;\n\n      var drilldown = level.subcells ? level.text : null;\n      if (typeof level.mapID === 'string') {\n        return [{\n          drilldown: drilldown,\n          code: level.mapID,\n          value: DrilldownMap.getPrimaryValue(level, this.valueColumn),\n          data: level._data\n        }];\n      } else if (Array.isArray(level.mapID)) {\n        return level.mapID.map(function (mapID) {\n\n          return {\n            drilldown: drilldown,\n            code: mapID,\n            value: DrilldownMap.getPrimaryValue(level, _this3.valueColumn),\n            data: level._data\n          };\n        });\n      } else {\n        throw new Error(\"Data element is corrupted\");\n      }\n    }\n\n    /**\n     * Executes `colorFn` passed by user to compute color by passing `value` and `target` to it\n     * @param {Function} colorFn - color function\n     * @param {Number} value - value to test\n     * @param {Number} target - target for the level\n     * */\n\n  }, {\n    key: \"getCoordinateSeries\",\n\n\n    /**\n     * Create a single mappoint series\n     * @param {Object} subcell - a single hierarchy element\n     * @param {Object} mapData\n     * @param {Object} chart - reference to chart object\n     * @returns {Object} series for map points\n     * */\n    value: function getCoordinateSeries(subcell, mapData, chart) {\n      var _this4 = this;\n\n      chart.mapTransforms = mapData ? mapData[\"hc-transform\"] : Highcharts.maps[\"custom/world-highres2\"][\"hc-transform\"];\n      var pos = chart.fromLatLonToPoint({ lat: subcell.coordinates[0], lon: subcell.coordinates[1] });\n      var config = {\n        type: \"mappoint\",\n        name: subcell.text,\n        marker: {\n          lineColor: \"black\",\n          lineWidth: 1,\n          radius: 4,\n          symbol: \"circle\"\n        },\n        data: [{\n          color: DrilldownMap.computeColor(this.colorFn, DrilldownMap.getPrimaryValue(subcell, this.valueColumn), subcell.target),\n          name: subcell.text,\n          value: subcell.value,\n          x: pos.x,\n          y: pos.y\n        }]\n      };\n      if (this.mappointCallback) {\n        (function () {\n          var self = _this4;\n          config.events = {\n            click: function click(e) {\n              self.mappointCallback.call(this, e);\n            }\n          };\n        })();\n      }\n      return config;\n    }\n\n    /**\n     * Creates a single series item for Highmaps series option\n     * @param {Object} subcell - a subcell\n     * @param {Object} mapData\n     * @param {Object} chart - reference to chart object\n     * @returns {Object} Returns series\n     * */\n\n  }, {\n    key: \"composeSeries\",\n    value: function composeSeries(subcell, mapData, chart) {\n      if (!subcell.coordinates) {\n        mapData = mapData ? Highcharts.geojson(DrilldownMap.createCustomGeoJSON(mapData, subcell.mapID, subcell.text)) : Highcharts.geojson(DrilldownMap.createCustomGeoJSON(Highcharts.maps['custom/world-highres2'], subcell.mapID, subcell.text));\n        if (subcell.mapID) {\n          var target = subcell.target;\n          if (!target || target == null) {\n            target = this.hierarchy[0].target;\n          }\n          return {\n            name: subcell.text,\n            dataLabels: {\n              enabled: true,\n              formatter: function formatter() {\n                if (this.series.data[0][\"hc-key\"] == this.point[\"hc-key\"]) return this.series.name;\n              }\n            },\n            /*tooltip: {\n             pointFormat: 'NPS : {point.value}'\n             },*/\n            color: DrilldownMap.computeColor(this.colorFn, DrilldownMap.getPrimaryValue(subcell, this.valueColumn), target),\n            allAreas: false,\n            parent: subcell.parent.text,\n            mapData: mapData,\n            joinBy: ['hc-key', 'code'],\n            data: this.getSeriesData(subcell)\n          };\n        }\n      } else {\n        return this.getCoordinateSeries(subcell, mapData, chart);\n      }\n    }\n\n    /**\n     * get subcell by text rather than by id\n     * @param {Object} curLVL - current level\n     * @param {String} name - name of the subcell we're looking for\n     * @returns {Object} Returns a subcell which has that name\n     * */\n\n  }, {\n    key: \"updateMap\",\n\n\n    /**\n     * Updates your map view after drilldown click\n     * @param {Object} curLVL\n     * @param {Object} chart\n     * @param {Object} e - drilldown event object\n     * @returns {Object} Returns curLVL\n     * */\n    value: function updateMap(curLVL, chart, e) {\n      var _this5 = this;\n\n      if (curLVL && curLVL.mapName) {\n        // if we have another map to load\n        var map = DrilldownMap.loadMap(curLVL.mapName);\n        map.then(function (mapData) {\n          _this5.addSeries(curLVL, chart, e, mapData);\n        });\n      } else if (curLVL && !curLVL.mapName) {\n        this.addSeries(curLVL, chart, e);\n      }\n    }\n\n    /**\n     * Composes a series for your HighMaps options config\n     * @param {Object} curLVL\n     * @param {Object} chart\n     * @param {Object} e - drilldown event object\n     * @param {Object} mapData - mapData geoJSON\n     * */\n\n  }, {\n    key: \"addSeries\",\n    value: function addSeries(curLVL, chart, e, mapData) {\n      var _this6 = this;\n\n      if (curLVL.subcells) {\n        // if it's an end point\n        if (curLVL.subcells[0].coordinates) {\n          var seriesItem = this.composeSeries(curLVL, mapData, chart);\n          seriesItem.data.forEach(function (dataItem) {\n            dataItem.drilldown = null;\n            dataItem.value = null;\n          });\n          chart.addSingleSeriesAsDrilldown(e.point, seriesItem);\n        }\n        curLVL.subcells.forEach(function (subcell) {\n          if (!subcell.mapID && !subcell.coordinates) return;\n          var seriesItem = _this6.composeSeries(subcell, mapData, chart);\n          chart.addSingleSeriesAsDrilldown(e.point, seriesItem);\n        });\n        chart.applyDrilldown();\n      } else {\n        var _seriesItem = this.composeSeries(curLVL, mapData, chart);\n        _seriesItem.data.map(function (dataItem) {\n          dataItem.drilldown = null;\n          dataItem.value = null;\n        });\n        chart.addSeriesAsDrilldown(e.point, _seriesItem);\n      }\n    }\n\n    /**\n     * Generates chart subtitle returning region and main value of full info based on `fullParentLevelInfo`\n     * */\n\n  }, {\n    key: \"getTooltip\",\n\n\n    /**\n     * Generates a serialized dataset for a tooltip\n     * */\n    value: function getTooltip() {\n      var data = this.curLVL._data;\n      return data.map(function (item, index) {\n        return \"<span class=\\\"tooltip-level-label\\\">\" + item.title + \":</span><span class=\\\"tooltip-level-value\\\"> {point.data.\" + index + \".value}</span>\";\n      }).join(\"<br />\");\n    }\n\n    /**\n     * @param {Array} rowheaders - a rowheaders array\n     * @param {String} containerID - id of the container to render map to\n     * @param {String} initMap - the initial map object that's going to be loaded to initialise the map\n     * @param {Object} options - options passed to HighMap to restyle/reconfigure it\n     * */\n\n  }, {\n    key: \"drawMap\",\n    value: function drawMap(rowheaders, containerID, initMap, options) {\n      this.curLVL = this.flatHierarchy[rowheaders[0]];\n      var self = this;\n      var config = {\n        lang: {\n          drillUpText: '< to {series.parent}'\n        },\n        tooltip: {\n          pointFormat: self.getTooltip()\n        },\n        title: {\n          text: ''\n        },\n        legend: {\n          enabled: true\n        },\n        plotOptions: {\n          series: {\n            states: {\n              normal: {\n                animation: false\n              }\n            },\n            point: {\n              events: {\n                mouseOver: function mouseOver(e) {\n                  this.series.data.forEach(function (el) {\n                    return el.setState(\"hover\");\n                  });\n                },\n                mouseOut: function mouseOut(e) {\n                  this.series.data.forEach(function (el) {\n                    return el.setState();\n                  });\n                }\n              }\n            }\n          }\n        },\n        mapNavigation: {\n          enabled: true,\n          buttons: {\n            zoomIn: {\n              verticalAlign: \"bottom\"\n            },\n            zoomOut: {\n              verticalAlign: \"bottom\"\n            }\n          }\n        },\n        subtitle: {\n          align: 'right',\n          text: self.subtitle,\n          floating: true\n        },\n        drilldown: {\n          drillUpButton: {\n            position: {\n              align: \"left\",\n              y: 0\n            },\n            relativeTo: 'spacingBox'\n          }\n        },\n        chart: {\n          events: {\n            drilldown: function drilldown(e) {\n              //this == chart reference;\n              //console.log(CircularJSON.parse(CircularJSON.stringify(e.point)));\n              var chart = e.target;\n              self.curLVL = DrilldownMap.getLevelByName(self.curLVL, e.point.series.name);\n              var curLVL = self.curLVL;\n              if (curLVL) {\n                chart.showLoading('fetching data');\n                var table = _rAsyncHierarchyTable2.default.fetchChildTable(curLVL.id, curLVL.parent ? curLVL.parent.id : null, self.tableID, self.pageStateId).then(function (table) {\n                  // parse data loaded from table\n                  DrilldownMap.parseTableData({\n                    source: table,\n                    excludeRows: 0,\n                    rowheaders: curLVL.subcells.map(function (lvl) {\n                      return lvl.id;\n                    }),\n                    flatHierarchy: self.flatHierarchy\n                  });\n                  self.updateMap(curLVL, chart, e);\n                  chart.subtitle.update({ text: self.subtitle });\n                  chart.hideLoading();\n                });\n              }\n            },\n            drillupall: function drillupall(e) {\n              self.curLVL = self.curLVL.parent;\n              if (self.curLVL) {\n                e.target.subtitle.update({ text: self.subtitle });\n              }\n            }\n          }\n        },\n        series: self.initMap(self.curLVL, [{\n          showInLegend: false,\n          mapData: Highcharts.maps[initMap]\n        }])\n      };\n\n      Highcharts.mapChart(containerID, _rReportalBase2.default.mixin(config, options));\n    }\n  }, {\n    key: \"subtitle\",\n    get: function get() {\n      if (this.fullParentLevelInfo) {\n        return this.curLVL._data.map(function (item) {\n          return \"<span class=\\\"tooltip-level-label\\\">\" + item.title + \":</span><span class=\\\"tooltip-level-value\\\"> \" + item.value + \"</span>\";\n        }).join(\"<br />\");\n      } else {\n        return this.curLVL._data[0].title + \": \" + this.curLVL._data[0].value + \"<br> \" + this.curLVL._data[this.valueColumn].title + \": \" + this.curLVL._data[this.valueColumn].value;\n      }\n    }\n  }], [{\n    key: \"parseTableData\",\n    value: function parseTableData() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          source = _ref2.source,\n          excludeRows = _ref2.excludeRows,\n          rowheaders = _ref2.rowheaders,\n          flatHierarchy = _ref2.flatHierarchy,\n          excludeColumns = _ref2.excludeColumns;\n\n      var AT = new _rAggregatedTable2.default({\n        source: source,\n        excludeColumns: excludeColumns, excludeRows: excludeRows\n      });\n      if (rowheaders && rowheaders != null && rowheaders.length > 0) {\n        rowheaders.forEach(function (rh, i) {\n          if (!flatHierarchy[rh]._data) {\n            flatHierarchy[rh]._data = AT.data[i].map(function (dataItem, index) {\n              return {\n                value: dataItem.data,\n                title: index != 0 ? AT.columns[index].title : \"Region\"\n              };\n            });\n          }\n        });\n      } else {\n        throw new Error('rowheaders must be present to parse data');\n      }\n    }\n\n    /**\n     * Creates custom geoJSON file\n     * @param {Object} mapData - initial map\n     * @param {Array}countriesList - list of countries IDs\n     * @param {String} mapName\n     * @returns {Object}\n     * */\n\n  }, {\n    key: \"createCustomGeoJSON\",\n    value: function createCustomGeoJSON(mapData, countriesList, mapName) {\n      var geojson = {\n        title: \"\",\n        version: \"0.1.0\",\n        type: \"FeatureCollection\",\n        copyright: \"Copyright (c) 2015 Highsoft AS, Based on data from Natural Earth\",\n        copyrightShort: \"Natural Earth\",\n        copyrightUrl: \"http://www.naturalearthdata.com\",\n        crs: {\n          type: \"name\",\n          properties: {\n            name: \"urn:ogc:def:crs:EPSG:54003\"\n          }\n        },\n        \"hc-transform\": {\n          default: {\n            crs: \"+proj=mill +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +R_A +datum=WGS84 +units=m +no_defs\",\n            scale: 1.72182781654e-05,\n            jsonres: 15.5,\n            jsonmarginX: -999,\n            jsonmarginY: 9851.0,\n            xoffset: -19495356.3693,\n            yoffset: 12635908.1982\n          }\n        },\n        features: DrilldownMap.getFeatures(countriesList, mapData)\n      };\n\n      geojson.title = mapName;\n      return geojson;\n    }\n\n    /**\n     * Get array of features from geoJSON file\n     * @param {Array|String} countriesList - countries IDs\n     * @param {Object} mapData - your initial map\n     * @param {String} key for geojson features comparing\n     * @returns {Array} features list\n     * */\n\n  }, {\n    key: \"getFeatures\",\n    value: function getFeatures(countriesList, mapData) {\n      var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"hc-key\";\n\n      if (typeof countriesList === 'string') {\n        return mapData.features.filter(function (feature) {\n          return feature.properties[key] === countriesList;\n        });\n      } else if (Array.isArray(countriesList)) {\n        return mapData.features.filter(function (feature) {\n          return countriesList.indexOf(feature.properties[key]) != -1;\n        });\n      }\n    }\n  }, {\n    key: \"loadMap\",\n    value: function loadMap(source) {\n      return new Promise(function (resolve, reject) {\n        jQuery.getScript('https://code.highcharts.com/mapdata/' + source + '.js', function () {\n          resolve(Highcharts.maps[source]);\n        });\n      });\n    }\n\n    /**\n     * Gets the main value that the chart is built on\n     * @param {Object} level - level under examination\n     * @param {Number} valueColumn - Zero-based column index that contains primary value which will be used for map coloring\n     * @returns {Number} Returns primary value\n     * */\n\n  }, {\n    key: \"getPrimaryValue\",\n    value: function getPrimaryValue(level, valueColumn) {\n      return level._data[valueColumn].value;\n    }\n  }, {\n    key: \"computeColor\",\n    value: function computeColor(colorFn, value, target) {\n      if (colorFn) {\n        return colorFn(value, target);\n      } else {\n        return undefined;\n      }\n    }\n  }, {\n    key: \"getLevelByName\",\n    value: function getLevelByName(curLVL, name) {\n      return curLVL.subcells.filter(function (el) {\n        return el.text == name;\n      })[0];\n    }\n  }]);\n\n  return DrilldownMap;\n}(_mapHierarchy2.default);\n\nexports.default = DrilldownMap;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvRHJpbGxkb3duTWFwLmpzP2UwMjkiXSwibmFtZXMiOlsicmVxdWlyZSIsIkRyaWxsZG93bk1hcCIsInNvdXJjZSIsInJvd2hlYWRlcnMiLCJoaWVyYXJjaHkiLCJpbml0TWFwIiwiY29udGFpbmVySUQiLCJtYXBwb2ludENhbGxiYWNrIiwiZXhjbHVkZUNvbHVtbnMiLCJleGNsdWRlUm93cyIsInZhbHVlQ29sdW1uIiwiZnVsbFBhcmVudExldmVsSW5mbyIsImNvbG9yRm4iLCJ2YWx1ZSIsInRhcmdldCIsInBhZ2VTdGF0ZUlkIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwidGFibGVJRCIsIm5vcm1hbHMiLCJub3JtYWxzU2VwYXJhdG9yIiwib3B0aW9ucyIsImNvbnN0cnVjdG9yIiwicGFyc2VUYWJsZURhdGEiLCJtYXAiLCJyaCIsImZsYXRIaWVyYXJjaHkiLCJUeXBlRXJyb3IiLCJjb25maWciLCJtaXhpbiIsIkhpZ2hjaGFydHMiLCJ1bmRlZmluZWQiLCJFcnJvciIsIm1hcHMiLCJjdXJMVkwiLCJzZXJpZXMiLCJzdWJjZWxscyIsImZvckVhY2giLCJzdWJjZWxsIiwibWFwSUQiLCJzZXJpZXNJdGVtIiwiY29tcG9zZVNlcmllcyIsInB1c2giLCJsZXZlbCIsImRyaWxsZG93biIsInRleHQiLCJjb2RlIiwiZ2V0UHJpbWFyeVZhbHVlIiwiZGF0YSIsIl9kYXRhIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwRGF0YSIsImNoYXJ0IiwibWFwVHJhbnNmb3JtcyIsInBvcyIsImZyb21MYXRMb25Ub1BvaW50IiwibGF0IiwiY29vcmRpbmF0ZXMiLCJsb24iLCJ0eXBlIiwibmFtZSIsIm1hcmtlciIsImxpbmVDb2xvciIsImxpbmVXaWR0aCIsInJhZGl1cyIsInN5bWJvbCIsImNvbG9yIiwiY29tcHV0ZUNvbG9yIiwieCIsInkiLCJzZWxmIiwiZXZlbnRzIiwiY2xpY2siLCJlIiwiY2FsbCIsImdlb2pzb24iLCJjcmVhdGVDdXN0b21HZW9KU09OIiwiZGF0YUxhYmVscyIsImVuYWJsZWQiLCJmb3JtYXR0ZXIiLCJwb2ludCIsImFsbEFyZWFzIiwicGFyZW50Iiwiam9pbkJ5IiwiZ2V0U2VyaWVzRGF0YSIsImdldENvb3JkaW5hdGVTZXJpZXMiLCJtYXBOYW1lIiwibG9hZE1hcCIsInRoZW4iLCJhZGRTZXJpZXMiLCJkYXRhSXRlbSIsImFkZFNpbmdsZVNlcmllc0FzRHJpbGxkb3duIiwiYXBwbHlEcmlsbGRvd24iLCJhZGRTZXJpZXNBc0RyaWxsZG93biIsIml0ZW0iLCJpbmRleCIsInRpdGxlIiwiam9pbiIsImxhbmciLCJkcmlsbFVwVGV4dCIsInRvb2x0aXAiLCJwb2ludEZvcm1hdCIsImdldFRvb2x0aXAiLCJsZWdlbmQiLCJwbG90T3B0aW9ucyIsInN0YXRlcyIsIm5vcm1hbCIsImFuaW1hdGlvbiIsIm1vdXNlT3ZlciIsImVsIiwic2V0U3RhdGUiLCJtb3VzZU91dCIsIm1hcE5hdmlnYXRpb24iLCJidXR0b25zIiwiem9vbUluIiwidmVydGljYWxBbGlnbiIsInpvb21PdXQiLCJzdWJ0aXRsZSIsImFsaWduIiwiZmxvYXRpbmciLCJkcmlsbFVwQnV0dG9uIiwicG9zaXRpb24iLCJyZWxhdGl2ZVRvIiwiZ2V0TGV2ZWxCeU5hbWUiLCJzaG93TG9hZGluZyIsInRhYmxlIiwiZmV0Y2hDaGlsZFRhYmxlIiwiaWQiLCJsdmwiLCJ1cGRhdGVNYXAiLCJ1cGRhdGUiLCJoaWRlTG9hZGluZyIsImRyaWxsdXBhbGwiLCJzaG93SW5MZWdlbmQiLCJtYXBDaGFydCIsIkFUIiwibGVuZ3RoIiwiaSIsImNvbHVtbnMiLCJjb3VudHJpZXNMaXN0IiwidmVyc2lvbiIsImNvcHlyaWdodCIsImNvcHlyaWdodFNob3J0IiwiY29weXJpZ2h0VXJsIiwiY3JzIiwicHJvcGVydGllcyIsImRlZmF1bHQiLCJzY2FsZSIsImpzb25yZXMiLCJqc29ubWFyZ2luWCIsImpzb25tYXJnaW5ZIiwieG9mZnNldCIsInlvZmZzZXQiLCJmZWF0dXJlcyIsImdldEZlYXR1cmVzIiwia2V5IiwiZmlsdGVyIiwiZmVhdHVyZSIsImluZGV4T2YiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImpRdWVyeSIsImdldFNjcmlwdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFKQSxtQkFBQUEsQ0FBUSxFQUFSOztJQU1NQyxZOzs7QUFDSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0JBLDBCQVVnRDtBQUFBLG1GQUFILEVBQUc7QUFBQSxRQVQ5Q0MsTUFTOEMsUUFUOUNBLE1BUzhDO0FBQUEsUUFUdkNDLFVBU3VDLFFBVHZDQSxVQVN1QztBQUFBLFFBUjlDQyxTQVE4QyxRQVI5Q0EsU0FROEM7QUFBQSw0QkFSbkNDLE9BUW1DO0FBQUEsUUFSbkNBLE9BUW1DLGdDQVIzQix1QkFRMkI7QUFBQSxRQVJGQyxXQVFFLFFBUkZBLFdBUUU7QUFBQSxRQVJXQyxnQkFRWCxRQVJXQSxnQkFRWDtBQUFBLFFBUDlDQyxjQU84QyxRQVA5Q0EsY0FPOEM7QUFBQSxRQVA5QkMsV0FPOEIsUUFQOUJBLFdBTzhCO0FBQUEsZ0NBUGpCQyxXQU9pQjtBQUFBLFFBUGpCQSxXQU9pQixvQ0FQTCxDQU9LO0FBQUEscUNBTjlDQyxtQkFNOEM7QUFBQSxRQU45Q0EsbUJBTThDLHlDQU54QixJQU13QjtBQUFBLDRCQUw5Q0MsT0FLOEM7QUFBQSxRQUw5Q0EsT0FLOEMsZ0NBTHRDLFVBQVNDLEtBQVQsRUFBZUMsTUFBZixFQUFzQjtBQUMzQixhQUFPRCxTQUFPLElBQVAsR0FBYUEsU0FBUyxFQUFULEdBQWMsU0FBZCxHQUE0QkEsUUFBTyxFQUFQLElBQWFBLFNBQU8sRUFBckIsR0FBNEIsU0FBNUIsR0FBd0MsU0FBaEYsR0FBNkYsTUFBcEc7QUFDRixLQUc2QztBQUFBLGdDQUY5Q0UsV0FFOEM7QUFBQSxRQUY5Q0EsV0FFOEMsb0NBRmpDQyxTQUFTQyxhQUFULENBQXVCLGNBQXZCLElBQXdDRCxTQUFT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UXNHLFFBQVIsQ0FBaUJHLE1BQWpCLENBQXdCO0FBQUEsaUJBQVdqQixjQUFjbUIsT0FBZCxDQUFzQkQsUUFBUVosVUFBUixDQUFtQlUsR0FBbkIsQ0FBdEIsS0FBZ0QsQ0FBQyxDQUE1RDtBQUFBLFNBQXhCLENBQVA7QUFDRDtBQUNGOzs7NEJBd0JjMUosTSxFQUFPO0FBQ3BCLGFBQU8sSUFBSThKLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVNDLE1BQVQsRUFBa0I7QUFDbkNDLGVBQU9DLFNBQVAsQ0FBaUIseUNBQXlDbEssTUFBekMsR0FBa0QsS0FBbkUsRUFBMEUsWUFBWTtBQUNwRitKLGtCQUFRbkksV0FBV0csSUFBWCxDQUFnQi9CLE1BQWhCLENBQVI7QUFDRCxTQUZEO0FBR0QsT0FKTSxDQUFQO0FBS0Q7O0FBRUQ7Ozs7Ozs7OztvQ0FNdUJ5QyxLLEVBQU1qQyxXLEVBQVk7QUFDdkMsYUFBT2lDLE1BQU1NLEtBQU4sQ0FBWXZDLFdBQVosRUFBeUJHLEtBQWhDO0FBQ0Q7OztpQ0FzQ21CRCxPLEVBQVNDLEssRUFBT0MsTSxFQUFPO0FBQ3pDLFVBQUdGLE9BQUgsRUFBVztBQUNULGVBQU9BLFFBQVFDLEtBQVIsRUFBZUMsTUFBZixDQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsZUFBT2lCLFNBQVA7QUFDRDtBQUNGOzs7bUNBb0ZxQkcsTSxFQUFPMkIsSSxFQUFLO0FBQ2hDLGFBQU8zQixPQUFPRSxRQUFQLENBQWdCeUgsTUFBaEIsQ0FBdUI7QUFBQSxlQUFNL0MsR0FBR2pFLElBQUgsSUFBV2dCLElBQWpCO0FBQUEsT0FBdkIsRUFBOEMsQ0FBOUMsQ0FBUDtBQUNEOzs7Ozs7a0JBMkxZNUQsWSIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIuL2RyaWxsZG93bi1tYXAuY3NzXCIpO1xuaW1wb3J0IFJlcG9ydGFsQmFzZSBmcm9tIFwici1yZXBvcnRhbC1iYXNlXCI7XG5pbXBvcnQgQXN5bmNIaWVyYXJjaHlUYWJsZSBmcm9tIFwici1hc3luYy1oaWVyYXJjaHktdGFibGVcIjtcbmltcG9ydCBNYXBIaWVyYXJjaHkgZnJvbSBcIi4vbWFwLWhpZXJhcmNoeVwiO1xuaW1wb3J0IEFnZ3JlZ2F0ZWRUYWJsZSBmcm9tIFwici1hZ2dyZWdhdGVkLXRhYmxlXCI7XG5cbmNsYXNzIERyaWxsZG93bk1hcCBleHRlbmRzIE1hcEhpZXJhcmNoeSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZHJpbGxkb3duIG1hcC4gSXQgdXNlcyBhIGNvbG9yIGZ1bmN0aW9uIGBjb2xvckZuYCB0aGF0IGFsbG93cyBjb2xvcmNvZGUgY291bnRyaWVzXG4gICAqIGBjb2xvckZuYCBhY2NlcHRzIHR3byBhdHRyaWJ1dGVzOiBgdmFsdWVgIGFuZCBgdGFyZ2V0YCBhbmQgbXVzdCByZXR1cm4gYSBjb2xvciBzdHJpbmcgYmFzZWQgb24gdGhvc2UgdHdvIGF0dHJpYnV0ZXMuXG4gICAqIE1ha2Ugc3VyZSBoaWVyYXJjaHkgaGFzIGB0YXJnZXRgIGxvYWRlZCBmcm9tIERCRGVzaWduZXIgdGFibGUgaW50byBlYWNoIGhpZXJhcmNoeSBsZXZlbCwgb3RoZXJ3aXNlIGEgZGVmYXVsdCBjb25maWcgYGRhdGFDbGFzc2VzYCB0YWtlcyBwcmVjZWRlbmNlIG9uIHZhbHVlXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqXG4gICAqICAgIHtcbiAgICogICAgLy9zb21lIGNvbnN0cnVjdG9yIGNvbmZpZ3VyYXRpb24gYWJvdmVcbiAgICogICAgICBjb2xvckZuOiBmdW5jdGlvbih2YWx1ZSx0YXJnZXQpe1xuICAgKiAgICAgICAgcmV0dXJuICh2YWx1ZSE9bnVsbCAmJiB0YXJnZXQhPW51bGwpPyAodmFsdWUgLSB0YXJnZXQgPj0gMCkgPyBcIiMxOEJDOUNcIiA6ICgodmFsdWUgPj0gMC45KnRhcmdldCkgPyBcIiNGRjQ5MDBcIiA6IFwiI0U0NTMzNVwiKSA6IHVuZGVmaW5lZDtcbiAgICogICAgICB9XG4gICAqICAgICAvL3NvbWUgY29uc3RydWN0b3IgY29uZmlndXJhdGlvbiBiZWxvd1xuICAgKiAgICB9XG4gICAqXG5cbiAgICogQHBhcmFtIHtIVE1MVGFibGVFbGVtZW50fSBzb3VyY2UgLSBhIHNvdXJjZSBkcmlsbGRvd24gdGFibGUgdGhhdCBjb250YWlucyB0aGUgaW5pdGlhbCBzZXQgb2YgZGF0YSh3aXRoIHJlZmVyZW5jZSBncm91cCBlbmFibGVkIGFuZCAxIGNoaWxkIGxldmVsKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGFibGVJRCAtIGlkIG9mIHRoZSBgc291cmNlYCB0YWJsZSB0aGF0IGlzIHRoZSBpbml0aWFsIHNvdXJjZSBvZiBkYXRhIChmcm9tIHJlcG9ydGFsIGJhY2tlbmQpXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJvd2hlYWRlcnMgLSBhIHJvd2hlYWRlcnMgYXJyYXkgZm9yIHRoZSBsb2FkZWQgdGFibGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGhpZXJhcmNoeSAtIGEgaGllcmFyY2hpY2FsIG9iamVjdCBmb3IgYSBtYXAgdG8gYmUgYnVpbHQgdXBvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2luaXRNYXA9XCJjdXN0b20vd29ybGQtaGlnaHJlczJcIl0gLSB0aGUgaW5pdGlhbCBtYXAgb2JqZWN0IHRoYXQncyBnb2luZyB0byBiZSBsb2FkZWQgdG8gaW5pdGlhbGlzZSB0aGUgbWFwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb250YWluZXJJRCAtIGlkIG9mIHRoZSBjb250YWluZXIgdGhlIG1hcCB3aWxsIGJlIGRyYXduIHRvXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1hcHBvaW50Q2FsbGJhY2sgLSBleGVjdXRlZCB3aGVuIGEgbWFwcG9pbnQgKGNpdHkpIGlzIGNsaWNrZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29sb3JGbiAtIEEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgY3VzdG9tIGNvbG9yIGNvZGluZyBjb21wdXRhdGlvbiBiYXNlZCBvbiB2YWx1ZSBhbmQgdGFyZ2V0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3ZhbHVlQ29sdW1uPTFdIC0gWmVyby1iYXNlZCBjb2x1bW4gaW5kZXggdGhhdCBjb250YWlucyBwcmltYXJ5IHZhbHVlIHdoaWNoIHdpbGwgYmUgdXNlZCBmb3IgbWFwIGNvbG9yaW5nLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmdWxsUGFyZW50TGV2ZWxJbmZvPXRydWVdIC0gRGlzcGxheSBmdWxsIGluZm8gb2YgdGhlIHBhcmVudCBsZXZlbCBpbiByaWdodCBwYXJ0IG9mIHRoZSBtYXAsIHJhdGhlciB0aGFuIHRoZSBwYXJlbnQgbGV2ZWwgbmFtZSBhbmQgdGhlIHByaW1hcnkgdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYWdlU3RhdGVJZD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjUGFnZVN0YXRlSWQnKS52YWx1ZV0gLSBQYWdlU3RhdGVJZFxuICAgKiBAcGFyYW0ge09iamVjdH0gbm9ybWFscyAtIGFuIG9iamVjdCB3aGVyZSB0aGUga2V5cyBhcmUgdGhlIG5hbWVzIG9mIGNvbHVtbnMgdGFrZW4gZnJvbSBEQkRlc2lnbmVyVGFibGUgYW5kIHZhbHVlcyAtIHRoZWlyIHN0cmluZyB0eXBlczogYHN0cmluZ2AsIGBudW1iZXJgLCBgYm9vbGVhbmAsIGBzdHJpbmdBcnJheWAsIGBudW1iZXJBcnJheWBcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtub3JtYWxzU2VwYXJhdG9yPScsJ10gLSBkZWxpbWl0ZXIgYmV0d2VlbiB2YWx1ZXMgaW4gYHN0cmluZ0FycmF5YCAoYHVzLWNhLCB1cy10eCwgdXMtd3lgKSBhbmQgYG51bWJlckFycmF5YCAoYC0zMS44NiwxNi4zOGApLiBUaGV5IGFyZSBzZXJ2ZWQgYXMgYSBkZWxpbWl0ZXItc2VwYXJhdGVkIHN0cmluZyBhbmQgdGhlIGRlbGltaXRlciBpcyBgLGAgYnkgZGVmYXVsdC4gSWYgeW91IHVzZSBhbm90aGVyIG9uZSwgbWFrZSBzdXJlIHlvdSBzcGVjaWZ5IGl0IGhlcmVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIG9wdGlvbnMgcGFzc2VkIHRvIEhpZ2hNYXAgdG8gcmVzdHlsZS9yZWNvbmZpZ3VyZSBpdFxuICAgKiAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgc291cmNlLHJvd2hlYWRlcnMsXG4gICAgaGllcmFyY2h5LCBpbml0TWFwPVwiY3VzdG9tL3dvcmxkLWhpZ2hyZXMyXCIsIGNvbnRhaW5lcklELCBtYXBwb2ludENhbGxiYWNrLFxuICAgIGV4Y2x1ZGVDb2x1bW5zLCBleGNsdWRlUm93cywgdmFsdWVDb2x1bW49MSxcbiAgICBmdWxsUGFyZW50TGV2ZWxJbmZvID0gdHJ1ZSxcbiAgICBjb2xvckZuPWZ1bmN0aW9uKHZhbHVlLHRhcmdldCl7XG4gICAgICAgcmV0dXJuIHZhbHVlIT1udWxsPyB2YWx1ZSA+PSA4MCA/IFwiIzRjYWY1MFwiIDogKCh2YWx1ZSA8ODAgJiYgdmFsdWU+PTYwICkgPyBcIiNmZmMxMDdcIiA6IFwiI2ZmNTcyMlwiKSA6IFwiYmx1ZVwiO1xuICAgIH0sXG4gICAgcGFnZVN0YXRlSWQ9KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNQYWdlU3RhdGVJZCcpPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjUGFnZVN0YXRlSWQnKS52YWx1ZTogbnVsbCksXG4gICAgdGFibGVJRCxcbiAgICBub3JtYWxzLCBub3JtYWxzU2VwYXJhdG9yPVwiLFwiLCBvcHRpb25zPXt9fT17fSl7XG4gICAgc3VwZXIoaGllcmFyY2h5LG5vcm1hbHMsbm9ybWFsc1NlcGFyYXRvcik7XG5cbiAgICB0aGlzLmNvbnN0cnVjdG9yLnBhcnNlVGFibGVEYXRhKHtzb3VyY2UsZXhjbHVkZVJvd3MsZXhjbHVkZUNvbHVtbnMscm93aGVhZGVyczpyb3doZWFkZXJzLm1hcChyaD0+cmhbMF0pLGZsYXRIaWVyYXJjaHk6dGhpcy5mbGF0SGllcmFyY2h5fSk7XG4gICAgaWYoY29sb3JGbiAmJiB0eXBlb2YgY29sb3JGbiA9PSBcImZ1bmN0aW9uXCIpe1xuICAgICAgdGhpcy5jb2xvckZuID0gY29sb3JGbjtcbiAgICB9XG4gICAgdGhpcy52YWx1ZUNvbHVtbiA9IHZhbHVlQ29sdW1uO1xuICAgIHRoaXMucGFnZVN0YXRlSWQ9cGFnZVN0YXRlSWQ7XG4gICAgdGhpcy50YWJsZUlEID0gdGFibGVJRDtcbiAgICB0aGlzLmZ1bGxQYXJlbnRMZXZlbEluZm8gPSBmdWxsUGFyZW50TGV2ZWxJbmZvO1xuXG4gICAgaWYobWFwcG9pbnRDYWxsYmFjayAmJiBtYXBwb2ludENhbGxiYWNrIT1udWxsKSB7XG4gICAgICBpZiAodHlwZW9mIG1hcHBvaW50Q2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLm1hcHBvaW50Q2FsbGJhY2sgPSBtYXBwb2ludENhbGxiYWNrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibWFwcG9pbnRDYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb25cIilcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnID0gUmVwb3J0YWxCYXNlLm1peGluKG9wdGlvbnMsIHsvKmNvbG9yQXhpczp7ZGF0YUNsYXNzZXN9Ki99KTtcbiAgICBpZih0eXBlb2YgSGlnaGNoYXJ0cyA9PSB1bmRlZmluZWQpe3Rocm93IG5ldyBFcnJvcignSGlnaGNoYXJ0cyBtdXN0IGJlIGRlY2xhcmVkLiBQcm9iYWJseSB0aGV5IGFyZSBtaXNzaW5nJyl9XG4gICAgaWYodHlwZW9mIEhpZ2hjaGFydHMubWFwcyA9PSB1bmRlZmluZWQpe3Rocm93IG5ldyBFcnJvcignSGlnaE1hcHMgbXVzdCBiZSBsb2FkZWQuIFByb2JhYmx5IHRoZXkgYXJlIG1pc3NpbmcnKX1cbiAgICAvL1xuICAgIC8vdGhpcy5kcmF3TWFwKHJvd2hlYWRlcnMsIGNvbnRhaW5lcklELCBpbml0TWFwLCBjb25maWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0YWJsZSBwYXNzZWQgdG8gaXQgYW5kIGFkZHMgZGF0YSB0byBgLl9kYXRhYCBpbiBgaGllcmFyY2h5YFxuICAgKiBAcGFyYW0ge0hUTUxUYWJsZUVsZW1lbnR9IHNvdXJjZSAtIHNvdXJjZSB0YWJsZSBmb3IgZGF0YVxuICAgKiBAcGFyYW0ge051bWJlcnxBcnJheX0gZXhjbHVkZVJvd3MgLSByb3dzIHRvIGJlIGV4Y2x1ZGVkIGZyb20gcGFyc2luZ1xuICAgKiBAcGFyYW0ge0FycmF5fSByb3doZWFkZXJzIC0gYXJyYXkgb2YgYHNvdXJjZWAgcm93aGVhZGVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZmxhdEhpZXJhcmNoeSAtIGZsYXQgaGllcmFyY2h5IG9iamVjdFxuICAgKiAqL1xuICBzdGF0aWMgcGFyc2VUYWJsZURhdGEoe3NvdXJjZSxleGNsdWRlUm93cyxyb3doZWFkZXJzLCBmbGF0SGllcmFyY2h5LGV4Y2x1ZGVDb2x1bW5zfT17fSl7XG4gICAgbGV0IEFUID0gbmV3IEFnZ3JlZ2F0ZWRUYWJsZSh7XG4gICAgICBzb3VyY2UsXG4gICAgICBleGNsdWRlQ29sdW1ucyxleGNsdWRlUm93c1xuICAgIH0pO1xuICAgIGlmKHJvd2hlYWRlcnMgJiYgcm93aGVhZGVycyE9bnVsbCAmJiByb3doZWFkZXJzLmxlbmd0aD4wKXtcbiAgICAgIHJvd2hlYWRlcnMuZm9yRWFjaCgocmgsaSk9PntcbiAgICAgICAgaWYoIWZsYXRIaWVyYXJjaHlbcmhdLl9kYXRhKXtcbiAgICAgICAgICBmbGF0SGllcmFyY2h5W3JoXS5fZGF0YT1BVC5kYXRhW2ldLm1hcCgoZGF0YUl0ZW0saW5kZXgpPT57XG4gICAgICAgICAgICByZXR1cm57XG4gICAgICAgICAgICAgIHZhbHVlOiBkYXRhSXRlbS5kYXRhLFxuICAgICAgICAgICAgICB0aXRsZTogaW5kZXghPTA/QVQuY29sdW1uc1tpbmRleF0udGl0bGU6XCJSZWdpb25cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncm93aGVhZGVycyBtdXN0IGJlIHByZXNlbnQgdG8gcGFyc2UgZGF0YScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGN1c3RvbSBnZW9KU09OIGZpbGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcERhdGEgLSBpbml0aWFsIG1hcFxuICAgKiBAcGFyYW0ge0FycmF5fWNvdW50cmllc0xpc3QgLSBsaXN0IG9mIGNvdW50cmllcyBJRHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1hcE5hbWVcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICogKi9cbiAgc3RhdGljIGNyZWF0ZUN1c3RvbUdlb0pTT04obWFwRGF0YSwgY291bnRyaWVzTGlzdCwgbWFwTmFtZSkge1xuICAgIGxldCBnZW9qc29uID0ge1xuICAgICAgdGl0bGU6XCJcIixcbiAgICAgIHZlcnNpb246XCIwLjEuMFwiLFxuICAgICAgdHlwZTpcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gICAgICBjb3B5cmlnaHQ6XCJDb3B5cmlnaHQgKGMpIDIwMTUgSGlnaHNvZnQgQVMsIEJhc2VkIG9uIGRhdGEgZnJvbSBOYXR1cmFsIEVhcnRoXCIsXG4gICAgICBjb3B5cmlnaHRTaG9ydDpcIk5hdHVyYWwgRWFydGhcIixcbiAgICAgIGNvcHlyaWdodFVybDpcImh0dHA6Ly93d3cubmF0dXJhbGVhcnRoZGF0YS5jb21cIixcbiAgICAgIGNyczp7XG4gICAgICAgIHR5cGU6XCJuYW1lXCIsXG4gICAgICAgIHByb3BlcnRpZXM6e1xuICAgICAgICAgIG5hbWU6XCJ1cm46b2djOmRlZjpjcnM6RVBTRzo1NDAwM1wiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImhjLXRyYW5zZm9ybVwiOntcbiAgICAgICAgZGVmYXVsdDp7XG4gICAgICAgICAgY3JzOlwiK3Byb2o9bWlsbCArbGF0XzA9MCArbG9uXzA9MCAreF8wPTAgK3lfMD0wICtSX0EgK2RhdHVtPVdHUzg0ICt1bml0cz1tICtub19kZWZzXCIsXG4gICAgICAgICAgc2NhbGU6MS43MjE4Mjc4MTY1NGUtMDUsXG4gICAgICAgICAganNvbnJlczoxNS41LFxuICAgICAgICAgIGpzb25tYXJnaW5YOi05OTksXG4gICAgICAgICAganNvbm1hcmdpblk6OTg1MS4wLFxuICAgICAgICAgIHhvZmZzZXQ6LTE5NDk1MzU2LjM2OTMsXG4gICAgICAgICAgeW9mZnNldDoxMjYzNTkwOC4xOTgyXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmZWF0dXJlczogRHJpbGxkb3duTWFwLmdldEZlYXR1cmVzKGNvdW50cmllc0xpc3QsbWFwRGF0YSlcbiAgICB9O1xuXG4gICAgZ2VvanNvbi50aXRsZSA9IG1hcE5hbWU7XG4gICAgcmV0dXJuIGdlb2pzb247XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFycmF5IG9mIGZlYXR1cmVzIGZyb20gZ2VvSlNPTiBmaWxlXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBjb3VudHJpZXNMaXN0IC0gY291bnRyaWVzIElEc1xuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwRGF0YSAtIHlvdXIgaW5pdGlhbCBtYXBcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBmb3IgZ2VvanNvbiBmZWF0dXJlcyBjb21wYXJpbmdcbiAgICogQHJldHVybnMge0FycmF5fSBmZWF0dXJlcyBsaXN0XG4gICAqICovXG4gIHN0YXRpYyBnZXRGZWF0dXJlcyhjb3VudHJpZXNMaXN0LG1hcERhdGEsa2V5PVwiaGMta2V5XCIpe1xuICAgIGlmICh0eXBlb2YgY291bnRyaWVzTGlzdCA9PT0gJ3N0cmluZycpe1xuICAgICAgcmV0dXJuIG1hcERhdGEuZmVhdHVyZXMuZmlsdGVyKGZlYXR1cmUgPT4gZmVhdHVyZS5wcm9wZXJ0aWVzW2tleV0gPT09IGNvdW50cmllc0xpc3QpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb3VudHJpZXNMaXN0KSl7XG4gICAgICByZXR1cm4gbWFwRGF0YS5mZWF0dXJlcy5maWx0ZXIoZmVhdHVyZSA9PiBjb3VudHJpZXNMaXN0LmluZGV4T2YoZmVhdHVyZS5wcm9wZXJ0aWVzW2tleV0pIT0tMSk7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogR2V0IHNlcmllcyBmb3IgdGhlIGZpcnN0IHRpbWUgbWFwIGluaXRpYWxpemF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjdXJMVkwgLSBjdXJyZW50IGxldmVsIGluIGhpZXJhcmNoeVxuICAgKiBAcGFyYW0ge0FycmF5fSBbc2VyaWVzPVtdXSAtIHNlcmllc1xuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqICovXG4gIGluaXRNYXAoY3VyTFZMLCBzZXJpZXMgPSBbXSl7XG4gICAgY3VyTFZMLnN1YmNlbGxzLmZvckVhY2goIHN1YmNlbGwgPT4ge1xuICAgICAgaWYgKHN1YmNlbGwubWFwSUQpIHtcbiAgICAgICAgbGV0IHNlcmllc0l0ZW0gPSB0aGlzLmNvbXBvc2VTZXJpZXMoc3ViY2VsbCk7XG4gICAgICAgIHNlcmllcy5wdXNoKHNlcmllc0l0ZW0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZXJpZXM7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBtYXAgZnJvbSBIaWdoTWFwcyBtYXAgY29sbGVjdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKiAqL1xuICBzdGF0aWMgbG9hZE1hcChzb3VyY2Upe1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSxyZWplY3QpPT57XG4gICAgICBqUXVlcnkuZ2V0U2NyaXB0KCdodHRwczovL2NvZGUuaGlnaGNoYXJ0cy5jb20vbWFwZGF0YS8nICsgc291cmNlICsgJy5qcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzb2x2ZShIaWdoY2hhcnRzLm1hcHNbc291cmNlXSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBtYWluIHZhbHVlIHRoYXQgdGhlIGNoYXJ0IGlzIGJ1aWx0IG9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZXZlbCAtIGxldmVsIHVuZGVyIGV4YW1pbmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZUNvbHVtbiAtIFplcm8tYmFzZWQgY29sdW1uIGluZGV4IHRoYXQgY29udGFpbnMgcHJpbWFyeSB2YWx1ZSB3aGljaCB3aWxsIGJlIHVzZWQgZm9yIG1hcCBjb2xvcmluZ1xuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIHByaW1hcnkgdmFsdWVcbiAgICogKi9cbiAgc3RhdGljIGdldFByaW1hcnlWYWx1ZShsZXZlbCx2YWx1ZUNvbHVtbil7XG4gICAgcmV0dXJuIGxldmVsLl9kYXRhW3ZhbHVlQ29sdW1uXS52YWx1ZTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzaW5nbGUgc2VyaWVzIGRhdGEgZm9yIEhpZ2hNYXAgc2VyaWVzIG9wdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gbGV2ZWwgLSBhIGxldmVsIGluIGhpZXJhcmNoeVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiAqL1xuICBnZXRTZXJpZXNEYXRhKGxldmVsKXtcbiAgICBsZXQgZHJpbGxkb3duID0gbGV2ZWwuc3ViY2VsbHMgPyBsZXZlbC50ZXh0IDogbnVsbDtcbiAgICBpZiAodHlwZW9mIGxldmVsLm1hcElEID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIGRyaWxsZG93bjogZHJpbGxkb3duLFxuICAgICAgICBjb2RlOiBsZXZlbC5tYXBJRCxcbiAgICAgICAgdmFsdWU6IERyaWxsZG93bk1hcC5nZXRQcmltYXJ5VmFsdWUobGV2ZWwsdGhpcy52YWx1ZUNvbHVtbiksXG4gICAgICAgIGRhdGE6IGxldmVsLl9kYXRhLFxuICAgICAgfV1cbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobGV2ZWwubWFwSUQpKXtcbiAgICAgIHJldHVybiBsZXZlbC5tYXBJRC5tYXAobWFwSUQ9PiB7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkcmlsbGRvd246IGRyaWxsZG93bixcbiAgICAgICAgICBjb2RlOiBtYXBJRCxcbiAgICAgICAgICB2YWx1ZTogRHJpbGxkb3duTWFwLmdldFByaW1hcnlWYWx1ZShsZXZlbCx0aGlzLnZhbHVlQ29sdW1uKSxcbiAgICAgICAgICBkYXRhOiBsZXZlbC5fZGF0YSxcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgZWxlbWVudCBpcyBjb3JydXB0ZWRcIik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGBjb2xvckZuYCBwYXNzZWQgYnkgdXNlciB0byBjb21wdXRlIGNvbG9yIGJ5IHBhc3NpbmcgYHZhbHVlYCBhbmQgYHRhcmdldGAgdG8gaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29sb3JGbiAtIGNvbG9yIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRhcmdldCAtIHRhcmdldCBmb3IgdGhlIGxldmVsXG4gICAqICovXG4gIHN0YXRpYyBjb21wdXRlQ29sb3IoY29sb3JGbiwgdmFsdWUsIHRhcmdldCl7XG4gICAgaWYoY29sb3JGbil7XG4gICAgICByZXR1cm4gY29sb3JGbih2YWx1ZSwgdGFyZ2V0KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNpbmdsZSBtYXBwb2ludCBzZXJpZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHN1YmNlbGwgLSBhIHNpbmdsZSBoaWVyYXJjaHkgZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwRGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhcnQgLSByZWZlcmVuY2UgdG8gY2hhcnQgb2JqZWN0XG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHNlcmllcyBmb3IgbWFwIHBvaW50c1xuICAgKiAqL1xuICBnZXRDb29yZGluYXRlU2VyaWVzKHN1YmNlbGwsbWFwRGF0YSxjaGFydCl7XG4gICAgY2hhcnQubWFwVHJhbnNmb3JtcyA9IG1hcERhdGEgPyAgbWFwRGF0YVtcImhjLXRyYW5zZm9ybVwiXSA6IEhpZ2hjaGFydHMubWFwc1tcImN1c3RvbS93b3JsZC1oaWdocmVzMlwiXVtcImhjLXRyYW5zZm9ybVwiXTtcbiAgICBsZXQgcG9zID0gY2hhcnQuZnJvbUxhdExvblRvUG9pbnQoeyBsYXQ6IHN1YmNlbGwuY29vcmRpbmF0ZXNbMF0sIGxvbjogc3ViY2VsbC5jb29yZGluYXRlc1sxXSB9KTtcbiAgICBsZXQgY29uZmlnID0ge1xuICAgICAgdHlwZTogXCJtYXBwb2ludFwiLFxuICAgICAgbmFtZTogc3ViY2VsbC50ZXh0LFxuICAgICAgbWFya2VyOiB7XG4gICAgICAgIGxpbmVDb2xvcjogXCJibGFja1wiLFxuICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgIHJhZGl1czogNCxcbiAgICAgICAgc3ltYm9sOiBcImNpcmNsZVwiLFxuICAgICAgfSxcbiAgICAgIGRhdGE6IFt7XG4gICAgICAgIGNvbG9yOiBEcmlsbGRvd25NYXAuY29tcHV0ZUNvbG9yKHRoaXMuY29sb3JGbixEcmlsbGRvd25NYXAuZ2V0UHJpbWFyeVZhbHVlKHN1YmNlbGwsdGhpcy52YWx1ZUNvbHVtbiksc3ViY2VsbC50YXJnZXQpLFxuICAgICAgICBuYW1lOiBzdWJjZWxsLnRleHQsXG4gICAgICAgIHZhbHVlOiBzdWJjZWxsLnZhbHVlLFxuICAgICAgICB4OiBwb3MueCxcbiAgICAgICAgeTogcG9zLnlcbiAgICAgIH1dXG4gICAgfTtcbiAgICBpZih0aGlzLm1hcHBvaW50Q2FsbGJhY2spe1xuICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgY29uZmlnLmV2ZW50cyA9IHtcbiAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKGUpe1xuICAgICAgICAgIHNlbGYubWFwcG9pbnRDYWxsYmFjay5jYWxsKHRoaXMsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzaW5nbGUgc2VyaWVzIGl0ZW0gZm9yIEhpZ2htYXBzIHNlcmllcyBvcHRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IHN1YmNlbGwgLSBhIHN1YmNlbGxcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcERhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IGNoYXJ0IC0gcmVmZXJlbmNlIHRvIGNoYXJ0IG9iamVjdFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHNlcmllc1xuICAgKiAqL1xuICBjb21wb3NlU2VyaWVzKHN1YmNlbGwsbWFwRGF0YSxjaGFydCl7XG4gICAgaWYoIXN1YmNlbGwuY29vcmRpbmF0ZXMpIHtcbiAgICAgIG1hcERhdGEgPSBtYXBEYXRhID8gSGlnaGNoYXJ0cy5nZW9qc29uKERyaWxsZG93bk1hcC5jcmVhdGVDdXN0b21HZW9KU09OKG1hcERhdGEsIHN1YmNlbGwubWFwSUQsIHN1YmNlbGwudGV4dCkpIDogSGlnaGNoYXJ0cy5nZW9qc29uKERyaWxsZG93bk1hcC5jcmVhdGVDdXN0b21HZW9KU09OKEhpZ2hjaGFydHMubWFwc1snY3VzdG9tL3dvcmxkLWhpZ2hyZXMyJ10sIHN1YmNlbGwubWFwSUQsIHN1YmNlbGwudGV4dCkpO1xuICAgICAgaWYgKHN1YmNlbGwubWFwSUQpIHtcbiAgICAgICAgbGV0IHRhcmdldCA9IHN1YmNlbGwudGFyZ2V0O1xuICAgICAgICBpZighdGFyZ2V0IHx8IHRhcmdldCA9PSBudWxsKXtcbiAgICAgICAgICB0YXJnZXQgPSB0aGlzLmhpZXJhcmNoeVswXS50YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBzdWJjZWxsLnRleHQsXG4gICAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgICAgZW5hYmxlZDrCoHRydWUsXG4gICAgICAgICAgICBmb3JtYXR0ZXI6wqBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBpZsKgKHRoaXMuc2VyaWVzLmRhdGFbMF1bXCJoYy1rZXlcIl3CoD09wqB0aGlzLnBvaW50W1wiaGMta2V5XCJdKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmllcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAvKnRvb2x0aXA6IHtcbiAgICAgICAgICAgcG9pbnRGb3JtYXQ6ICdOUFMgOiB7cG9pbnQudmFsdWV9J1xuICAgICAgICAgICB9LCovXG4gICAgICAgICAgY29sb3I6RHJpbGxkb3duTWFwLmNvbXB1dGVDb2xvcih0aGlzLmNvbG9yRm4sRHJpbGxkb3duTWFwLmdldFByaW1hcnlWYWx1ZShzdWJjZWxsLHRoaXMudmFsdWVDb2x1bW4pLHRhcmdldCksXG4gICAgICAgICAgYWxsQXJlYXM6IGZhbHNlLFxuICAgICAgICAgIHBhcmVudDogc3ViY2VsbC5wYXJlbnQudGV4dCxcbiAgICAgICAgICBtYXBEYXRhLFxuICAgICAgICAgIGpvaW5CeTogWydoYy1rZXknLCAnY29kZSddLFxuICAgICAgICAgIGRhdGE6IHRoaXMuZ2V0U2VyaWVzRGF0YShzdWJjZWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcmllcyhzdWJjZWxsLG1hcERhdGEsY2hhcnQpfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldCBzdWJjZWxsIGJ5IHRleHQgcmF0aGVyIHRoYW4gYnkgaWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGN1ckxWTCAtIGN1cnJlbnQgbGV2ZWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBuYW1lIG9mIHRoZSBzdWJjZWxsIHdlJ3JlIGxvb2tpbmcgZm9yXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYSBzdWJjZWxsIHdoaWNoIGhhcyB0aGF0IG5hbWVcbiAgICogKi9cbiAgc3RhdGljIGdldExldmVsQnlOYW1lKGN1ckxWTCxuYW1lKXtcbiAgICByZXR1cm4gY3VyTFZMLnN1YmNlbGxzLmZpbHRlcihlbCA9PiBlbC50ZXh0ID09IG5hbWUpWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgeW91ciBtYXAgdmlldyBhZnRlciBkcmlsbGRvd24gY2xpY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IGN1ckxWTFxuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhcnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGUgLSBkcmlsbGRvd24gZXZlbnQgb2JqZWN0XG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgY3VyTFZMXG4gICAqICovXG4gIHVwZGF0ZU1hcChjdXJMVkwsIGNoYXJ0LCBlKXtcbiAgICBpZihjdXJMVkwgJiYgY3VyTFZMLm1hcE5hbWUpey8vIGlmIHdlIGhhdmUgYW5vdGhlciBtYXAgdG8gbG9hZFxuICAgICAgbGV0IG1hcCA9IERyaWxsZG93bk1hcC5sb2FkTWFwKGN1ckxWTC5tYXBOYW1lKTtcbiAgICAgIG1hcC50aGVuKG1hcERhdGE9PntcbiAgICAgICAgdGhpcy5hZGRTZXJpZXMoY3VyTFZMLGNoYXJ0LGUsbWFwRGF0YSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZihjdXJMVkwgJiYgIWN1ckxWTC5tYXBOYW1lKXtcbiAgICAgIHRoaXMuYWRkU2VyaWVzKGN1ckxWTCxjaGFydCxlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29tcG9zZXMgYSBzZXJpZXMgZm9yIHlvdXIgSGlnaE1hcHMgb3B0aW9ucyBjb25maWdcbiAgICogQHBhcmFtIHtPYmplY3R9IGN1ckxWTFxuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhcnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGUgLSBkcmlsbGRvd24gZXZlbnQgb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBEYXRhIC0gbWFwRGF0YSBnZW9KU09OXG4gICAqICovXG4gIGFkZFNlcmllcyhjdXJMVkwsY2hhcnQsZSxtYXBEYXRhKXtcbiAgICBpZiAoY3VyTFZMLnN1YmNlbGxzKXsgLy8gaWYgaXQncyBhbiBlbmQgcG9pbnRcbiAgICAgIGlmKGN1ckxWTC5zdWJjZWxsc1swXS5jb29yZGluYXRlcyl7XG4gICAgICAgIGxldCBzZXJpZXNJdGVtID0gdGhpcy5jb21wb3NlU2VyaWVzKGN1ckxWTCxtYXBEYXRhLCBjaGFydCk7XG4gICAgICAgIHNlcmllc0l0ZW0uZGF0YS5mb3JFYWNoKGRhdGFJdGVtID0+IHtcbiAgICAgICAgICBkYXRhSXRlbS5kcmlsbGRvd24gPSBudWxsO1xuICAgICAgICAgIGRhdGFJdGVtLnZhbHVlID0gbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgY2hhcnQuYWRkU2luZ2xlU2VyaWVzQXNEcmlsbGRvd24oZS5wb2ludCwgc2VyaWVzSXRlbSk7XG4gICAgICB9XG4gICAgICBjdXJMVkwuc3ViY2VsbHMuZm9yRWFjaChzdWJjZWxsID0+IHtcbiAgICAgICAgaWYoIXN1YmNlbGwubWFwSUQgJiYgIXN1YmNlbGwuY29vcmRpbmF0ZXMpIHJldHVybjtcbiAgICAgICAgbGV0IHNlcmllc0l0ZW0gPSB0aGlzLmNvbXBvc2VTZXJpZXMoc3ViY2VsbCxtYXBEYXRhLCBjaGFydCk7XG4gICAgICAgIGNoYXJ0LmFkZFNpbmdsZVNlcmllc0FzRHJpbGxkb3duKGUucG9pbnQsIHNlcmllc0l0ZW0pO1xuICAgICAgfSk7XG4gICAgICBjaGFydC5hcHBseURyaWxsZG93bigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgc2VyaWVzSXRlbSA9IHRoaXMuY29tcG9zZVNlcmllcyhjdXJMVkwsIG1hcERhdGEsIGNoYXJ0KTtcbiAgICAgIHNlcmllc0l0ZW0uZGF0YS5tYXAoZGF0YUl0ZW0gPT4ge1xuICAgICAgICBkYXRhSXRlbS5kcmlsbGRvd24gPSBudWxsO1xuICAgICAgICBkYXRhSXRlbS52YWx1ZSA9IG51bGxcbiAgICAgIH0pO1xuICAgICAgY2hhcnQuYWRkU2VyaWVzQXNEcmlsbGRvd24oZS5wb2ludCwgc2VyaWVzSXRlbSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBjaGFydCBzdWJ0aXRsZSByZXR1cm5pbmcgcmVnaW9uIGFuZCBtYWluIHZhbHVlIG9mIGZ1bGwgaW5mbyBiYXNlZCBvbiBgZnVsbFBhcmVudExldmVsSW5mb2BcbiAgICogKi9cbiAgZ2V0IHN1YnRpdGxlKCl7XG4gICAgaWYodGhpcy5mdWxsUGFyZW50TGV2ZWxJbmZvKXtcbiAgICAgIHJldHVybiB0aGlzLmN1ckxWTC5fZGF0YS5tYXAoKGl0ZW0pPT57XG4gICAgICAgIHJldHVybiBgPHNwYW4gY2xhc3M9XCJ0b29sdGlwLWxldmVsLWxhYmVsXCI+JHtpdGVtLnRpdGxlfTo8L3NwYW4+PHNwYW4gY2xhc3M9XCJ0b29sdGlwLWxldmVsLXZhbHVlXCI+ICR7aXRlbS52YWx1ZX08L3NwYW4+YFxuICAgICAgfSkuam9pbihcIjxiciAvPlwiKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5jdXJMVkwuX2RhdGFbMF0udGl0bGV9OiAke3RoaXMuY3VyTFZMLl9kYXRhWzBdLnZhbHVlfTxicj4gJHt0aGlzLmN1ckxWTC5fZGF0YVt0aGlzLnZhbHVlQ29sdW1uXS50aXRsZX06ICR7dGhpcy5jdXJMVkwuX2RhdGFbdGhpcy52YWx1ZUNvbHVtbl0udmFsdWV9YFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBzZXJpYWxpemVkIGRhdGFzZXQgZm9yIGEgdG9vbHRpcFxuICAgKiAqL1xuICBnZXRUb29sdGlwKCl7XG4gICAgbGV0IGRhdGEgPSB0aGlzLmN1ckxWTC5fZGF0YTtcbiAgICByZXR1cm4gZGF0YS5tYXAoKGl0ZW0saW5kZXgpPT5gPHNwYW4gY2xhc3M9XCJ0b29sdGlwLWxldmVsLWxhYmVsXCI+JHtpdGVtLnRpdGxlfTo8L3NwYW4+PHNwYW4gY2xhc3M9XCJ0b29sdGlwLWxldmVsLXZhbHVlXCI+IHtwb2ludC5kYXRhLiR7aW5kZXh9LnZhbHVlfTwvc3Bhbj5gKS5qb2luKFwiPGJyIC8+XCIpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheX0gcm93aGVhZGVycyAtIGEgcm93aGVhZGVycyBhcnJheVxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29udGFpbmVySUQgLSBpZCBvZiB0aGUgY29udGFpbmVyIHRvIHJlbmRlciBtYXAgdG9cbiAgICogQHBhcmFtIHtTdHJpbmd9IGluaXRNYXAgLSB0aGUgaW5pdGlhbCBtYXAgb2JqZWN0IHRoYXQncyBnb2luZyB0byBiZSBsb2FkZWQgdG8gaW5pdGlhbGlzZSB0aGUgbWFwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBwYXNzZWQgdG8gSGlnaE1hcCB0byByZXN0eWxlL3JlY29uZmlndXJlIGl0XG4gICAqICovXG4gIGRyYXdNYXAocm93aGVhZGVycywgY29udGFpbmVySUQsIGluaXRNYXAsIG9wdGlvbnMpe1xuICAgIHRoaXMuY3VyTFZMID0gdGhpcy5mbGF0SGllcmFyY2h5W3Jvd2hlYWRlcnNbMF1dO1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgY29uZmlnID0ge1xuICAgICAgbGFuZzoge1xuICAgICAgICBkcmlsbFVwVGV4dDogJzwgdG8ge3Nlcmllcy5wYXJlbnR9J1xuICAgICAgfSxcbiAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgcG9pbnRGb3JtYXQ6IHNlbGYuZ2V0VG9vbHRpcCgpXG4gICAgICB9LFxuICAgICAgdGl0bGU6IHtcbiAgICAgICAgdGV4dDogJydcbiAgICAgIH0sXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHBsb3RPcHRpb25zOntcbiAgICAgICAgc2VyaWVzOiB7XG4gICAgICAgICAgc3RhdGVzOntcbiAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICBhbmltYXRpb246wqBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgICBtb3VzZU92ZXI6wqBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmllcy5kYXRhLmZvckVhY2goXG4gICAgICAgICAgICAgICAgICBlbCA9PiBlbC5zZXRTdGF0ZShcImhvdmVyXCIpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtb3VzZU91dDrCoGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWVzLmRhdGEuZm9yRWFjaChcbiAgICAgICAgICAgICAgICAgIGVsID0+IGVsLnNldFN0YXRlKClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtYXBOYXZpZ2F0aW9uOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGJ1dHRvbnM6e1xuICAgICAgICAgIHpvb21Jbjp7XG4gICAgICAgICAgICB2ZXJ0aWNhbEFsaWduOlwiYm90dG9tXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHpvb21PdXQ6e1xuICAgICAgICAgICAgdmVydGljYWxBbGlnbjpcImJvdHRvbVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3VidGl0bGU6e1xuICAgICAgICBhbGlnbjogJ3JpZ2h0JyxcbiAgICAgICAgdGV4dDogc2VsZi5zdWJ0aXRsZSxcbiAgICAgICAgZmxvYXRpbmc6dHJ1ZVxuICAgICAgfSxcbiAgICAgIGRyaWxsZG93bjp7XG4gICAgICAgIGRyaWxsVXBCdXR0b246IHtcbiAgICAgICAgICBwb3NpdGlvbjp7XG4gICAgICAgICAgICBhbGlnbjpcImxlZnRcIixcbiAgICAgICAgICAgIHk6MFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVsYXRpdmVUbzonc3BhY2luZ0JveCdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNoYXJ0OntcbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgZHJpbGxkb3duOiBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgIC8vdGhpcyA9PSBjaGFydCByZWZlcmVuY2U7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKENpcmN1bGFySlNPTi5wYXJzZShDaXJjdWxhckpTT04uc3RyaW5naWZ5KGUucG9pbnQpKSk7XG4gICAgICAgICAgICBsZXQgY2hhcnQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgIHNlbGYuY3VyTFZMID0gRHJpbGxkb3duTWFwLmdldExldmVsQnlOYW1lKHNlbGYuY3VyTFZMLGUucG9pbnQuc2VyaWVzLm5hbWUpO1xuICAgICAgICAgICAgbGV0IGN1ckxWTCA9IHNlbGYuY3VyTFZMO1xuICAgICAgICAgICAgaWYoY3VyTFZMKXtcbiAgICAgICAgICAgICAgY2hhcnQuc2hvd0xvYWRpbmcoJ2ZldGNoaW5nIGRhdGEnKTtcbiAgICAgICAgICAgICAgbGV0IHRhYmxlID0gQXN5bmNIaWVyYXJjaHlUYWJsZS5mZXRjaENoaWxkVGFibGUoY3VyTFZMLmlkLCBjdXJMVkwucGFyZW50P2N1ckxWTC5wYXJlbnQuaWQ6bnVsbCwgc2VsZi50YWJsZUlELCBzZWxmLnBhZ2VTdGF0ZUlkKVxuICAgICAgICAgICAgICAgIC50aGVuKHRhYmxlPT57XG4gICAgICAgICAgICAgICAgICAvLyBwYXJzZSBkYXRhIGxvYWRlZCBmcm9tIHRhYmxlXG4gICAgICAgICAgICAgICAgICBEcmlsbGRvd25NYXAucGFyc2VUYWJsZURhdGEoe1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6dGFibGUsXG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVSb3dzOjAsXG4gICAgICAgICAgICAgICAgICAgIHJvd2hlYWRlcnM6Y3VyTFZMLnN1YmNlbGxzLm1hcChsdmw9Pmx2bC5pZCksXG4gICAgICAgICAgICAgICAgICAgIGZsYXRIaWVyYXJjaHk6c2VsZi5mbGF0SGllcmFyY2h5XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlTWFwKGN1ckxWTCwgY2hhcnQsIGUpO1xuICAgICAgICAgICAgICAgICAgY2hhcnQuc3VidGl0bGUudXBkYXRlKHt0ZXh0OiBzZWxmLnN1YnRpdGxlfSk7XG4gICAgICAgICAgICAgICAgICBjaGFydC5oaWRlTG9hZGluZygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHJpbGx1cGFsbDogZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICBzZWxmLmN1ckxWTCA9IHNlbGYuY3VyTFZMLnBhcmVudDtcbiAgICAgICAgICAgIGlmIChzZWxmLmN1ckxWTCl7XG4gICAgICAgICAgICAgIGUudGFyZ2V0LnN1YnRpdGxlLnVwZGF0ZSh7dGV4dDogc2VsZi5zdWJ0aXRsZX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNlcmllczogc2VsZi5pbml0TWFwKHNlbGYuY3VyTFZMLFt7XG4gICAgICAgIHNob3dJbkxlZ2VuZDpmYWxzZSxcbiAgICAgICAgbWFwRGF0YTogSGlnaGNoYXJ0cy5tYXBzW2luaXRNYXBdXG4gICAgICB9XSlcbiAgICB9O1xuXG4gICAgSGlnaGNoYXJ0cy5tYXBDaGFydCggY29udGFpbmVySUQsIFJlcG9ydGFsQmFzZS5taXhpbihjb25maWcsb3B0aW9ucykpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERyaWxsZG93bk1hcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9EcmlsbGRvd25NYXAuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 14 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Created by IvanP on 26.12.2016.\n */\nvar MapHierarchy = function () {\n  function MapHierarchy(hierarchy, normals, normalsSeparator) {\n    _classCallCheck(this, MapHierarchy);\n\n    this.flatHierarchy = hierarchy;\n    this.hierarchy = this.constructor.processHierarchy(this.flatHierarchy, normals, normalsSeparator);\n    this.constructor.addMapIDsToHierarchyLevel(this.hierarchy);\n  }\n\n  /**\n   * Processes hierarchy array by assigning parent-child relations and returning those that don't have a parent\n   * @param {Object} flatHierarchy - a flat hierarchy object with ids as keys\n   * @param {Object} [normals={}] - an object where keys myst coincide with column ids (thus be identical to keys in `item`). `normals` doesn't require for all keys from `item` to be present, only those that need to be normalised to a different type\n   * @param {String} [separator=','] - a separator array items are serialized with, by default it's a comma (`,`)\n   * */\n\n\n  _createClass(MapHierarchy, null, [{\n    key: 'processHierarchy',\n    value: function processHierarchy(flatHierarchy) {\n      var normals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var separator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ',';\n\n      var orphans = [],\n          toNormalize = Object.keys(normals).length > 0;\n      for (var key in flatHierarchy) {\n        var item = flatHierarchy[key];\n        if (toNormalize) MapHierarchy.normalize(item, normals);\n\n        // map item to parent\n        if (item.parent && item.parent != null && item.parent.length > 0) {\n          item.parent = flatHierarchy[item.parent];\n          item.parent.subcells = item.parent.subcells || [];\n          item.parent.subcells.push(item);\n        } else {\n          orphans.push(item);\n        }\n      }\n      return orphans;\n    }\n  }, {\n    key: 'composeFlatHierarchy',\n    value: function composeFlatHierarchy(hierarchy, normals) {\n      var o = {};\n      var toNormalize = normals.keys().length > 0;\n      hierarchy.forEach(function (item) {\n        if (toNormalize) MapHierarchy.normalize(item, normals);\n        o[item.id] = item;\n      });\n      return o;\n    }\n\n    /**\n     * normalizes a string value to a certain format.\n     * - `arrayString` - normalizes comma-separated items to an Array of Strings, i.e \"haha\", \"lala\" would be [\"haha\", \"lala\"]\n     * - `arrayNumber` - normalizes comma-separated items to an Array of Floats, i.e \"-13.41\", \"48.66\" would be [-13.41, 48.66]\n     * - `string` - returns the string as is\n     * - `number` - parses the string as a Float\n     * - `boolean` - parses the string as a Boolean, case insensitive\n     *\n     * @param {Object} item - item to match contents against `normals`\n     * @param {Object} [normals={}] - an object where keys myst coincide with column ids (thus be identical to keys in `item`). `normals` doesn't require for all keys from `item` to be present, only those that need to be normalised to a different type\n     * @param {String} [separator=','] - a separator array items are serialized with, by default it's a comma (`,`)\n     * */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(item) {\n      var normals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var separator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ',';\n\n      var parser = {\n        stringArray: function stringArray(val) {\n          return val.split(separator);\n        },\n        numberArray: function numberArray(val) {\n          return val.split(separator).map(function (i) {\n            return parseFloat(i);\n          });\n        },\n        string: function string(val) {\n          return val.trim();\n        },\n        number: function number(val) {\n          return val != null && !isNaN(parseFloat(val)) ? parseFloat(val) : null;\n        },\n        boolean: function boolean(val) {\n          return val.toLowerCase() == \"true\" || val == \"1\";\n        }\n      };\n      for (var normal in normals) {\n        if (item[normal]) {\n          // property exists in object\n          if (item[normal].length > 0) {\n            item[normal] = parser[normals[normal]](item[normal]);\n          } else {\n            delete item[normal];\n          }\n        }\n      }\n    }\n\n    /**\n     * Updates initial hierarchy\n     * @param hierarchy\n     * @param parent - hierarchy level parent\n     */\n\n  }, {\n    key: 'addMapIDsToHierarchyLevel',\n    value: function addMapIDsToHierarchyLevel(hierarchy) {\n      var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      hierarchy.forEach(function (subcell) {\n        if (subcell.parent && subcell.parent != null && subcell.parent.mapName) {\n          subcell.mapName = subcell.parent.mapName;\n        }\n        if (subcell.subcells) {\n          MapHierarchy.addMapIDsToHierarchyLevel(subcell.subcells, subcell);\n        }\n        if (subcell.parent && subcell.mapID && !subcell.parent.mapName) {\n          if (!subcell.parent.mapID) subcell.parent.mapID = [];\n          subcell.parent.mapID = subcell.parent.mapID.concat(subcell.mapID);\n        }\n      });\n    }\n  }]);\n\n  return MapHierarchy;\n}();\n\nexports.default = MapHierarchy;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFwLWhpZXJhcmNoeS5qcz80NWFhIl0sIm5hbWVzIjpbIk1hcEhpZXJhcmNoeSIsImhpZXJhcmNoeSIsIm5vcm1hbHMiLCJub3JtYWxzU2VwYXJhdG9yIiwiZmxhdEhpZXJhcmNoeSIsImNvbnN0cnVjdG9yIiwicHJvY2Vzc0hpZXJhcmNoeSIsImFkZE1hcElEc1RvSGllcmFyY2h5TGV2ZWwiLCJzZXBhcmF0b3IiLCJvcnBoYW5zIiwidG9Ob3JtYWxpemUiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwia2V5IiwiaXRlbSIsIm5vcm1hbGl6ZSIsInBhcmVudCIsInN1YmNlbGxzIiwicHVzaCIsIm8iLCJmb3JFYWNoIiwiaWQiLCJwYXJzZXIiLCJzdHJpbmdBcnJheSIsInZhbCIsInNwbGl0IiwibnVtYmVyQXJyYXkiLCJtYXAiLCJwYXJzZUZsb2F0IiwiaSIsInN0cmluZyIsInRyaW0iLCJudW1iZXIiLCJpc05hTiIsImJvb2xlYW4iLCJ0b0xvd2VyQ2FzZSIsIm5vcm1hbCIsInN1YmNlbGwiLCJtYXBOYW1lIiwibWFwSUQiLCJjb25jYXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7O0lBR01BLFk7QUFDSix3QkFBWUMsU0FBWixFQUFzQkMsT0FBdEIsRUFBOEJDLGdCQUE5QixFQUErQztBQUFBOztBQUM3QyxTQUFLQyxhQUFMLEdBQXFCSCxTQUFyQjtBQUNBLFNBQUtBLFNBQUwsR0FBaUIsS0FBS0ksV0FBTCxDQUFpQkMsZ0JBQWpCLENBQWtDLEtBQUtGLGFBQXZDLEVBQXFERixPQUFyRCxFQUE2REMsZ0JBQTdELENBQWpCO0FBQ0EsU0FBS0UsV0FBTCxDQUFpQkUseUJBQWpCLENBQTJDLEtBQUtOLFNBQWhEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7cUNBTXdCRyxhLEVBQXVDO0FBQUEsVUFBekJGLE9BQXlCLHVFQUFqQixFQUFpQjtBQUFBLFVBQWRNLFNBQWMsdUVBQUosR0FBSTs7QUFDN0QsVUFBSUMsVUFBVSxF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ZXNCLE9BQTVELEVBQW9FO0FBQ2xFRCxrQkFBUUMsT0FBUixHQUFrQkQsUUFBUXJCLE1BQVIsQ0FBZXNCLE9BQWpDO0FBQ0Q7QUFDRCxZQUFJRCxRQUFRcEIsUUFBWixFQUFzQjtBQUNwQmxCLHVCQUFhTyx5QkFBYixDQUF1QytCLFFBQVFwQixRQUEvQyxFQUF5RG9CLE9BQXpEO0FBQ0Q7QUFDRCxZQUFHQSxRQUFRckIsTUFBUixJQUFrQnFCLFFBQVFFLEtBQTFCLElBQW1DLENBQUNGLFFBQVFyQixNQUFSLENBQWVzQixPQUF0RCxFQUE4RDtBQUM1RCxjQUFHLENBQUNELFFBQVFyQixNQUFSLENBQWV1QixLQUFuQixFQUNFRixRQUFRckIsTUFBUixDQUFldUIsS0FBZixHQUF1QixFQUF2QjtBQUNGRixrQkFBUXJCLE1BQVIsQ0FBZXVCLEtBQWYsR0FBdUJGLFFBQVFyQixNQUFSLENBQWV1QixLQUFmLENBQXFCQyxNQUFyQixDQUE0QkgsUUFBUUUsS0FBcEMsQ0FBdkI7QUFDRDtBQUNGLE9BWkQ7QUFhRDs7Ozs7O2tCQUdZeEMsWSIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3JlYXRlZCBieSBJdmFuUCBvbiAyNi4xMi4yMDE2LlxuICovXG5jbGFzcyBNYXBIaWVyYXJjaHkge1xuICBjb25zdHJ1Y3RvcihoaWVyYXJjaHksbm9ybWFscyxub3JtYWxzU2VwYXJhdG9yKXtcbiAgICB0aGlzLmZsYXRIaWVyYXJjaHkgPSBoaWVyYXJjaHk7XG4gICAgdGhpcy5oaWVyYXJjaHkgPSB0aGlzLmNvbnN0cnVjdG9yLnByb2Nlc3NIaWVyYXJjaHkodGhpcy5mbGF0SGllcmFyY2h5LG5vcm1hbHMsbm9ybWFsc1NlcGFyYXRvcik7XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5hZGRNYXBJRHNUb0hpZXJhcmNoeUxldmVsKHRoaXMuaGllcmFyY2h5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgaGllcmFyY2h5IGFycmF5IGJ5IGFzc2lnbmluZyBwYXJlbnQtY2hpbGQgcmVsYXRpb25zIGFuZCByZXR1cm5pbmcgdGhvc2UgdGhhdCBkb24ndCBoYXZlIGEgcGFyZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmbGF0SGllcmFyY2h5IC0gYSBmbGF0IGhpZXJhcmNoeSBvYmplY3Qgd2l0aCBpZHMgYXMga2V5c1xuICAgKiBAcGFyYW0ge09iamVjdH0gW25vcm1hbHM9e31dIC0gYW4gb2JqZWN0IHdoZXJlIGtleXMgbXlzdCBjb2luY2lkZSB3aXRoIGNvbHVtbiBpZHMgKHRodXMgYmUgaWRlbnRpY2FsIHRvIGtleXMgaW4gYGl0ZW1gKS4gYG5vcm1hbHNgIGRvZXNuJ3QgcmVxdWlyZSBmb3IgYWxsIGtleXMgZnJvbSBgaXRlbWAgdG8gYmUgcHJlc2VudCwgb25seSB0aG9zZSB0aGF0IG5lZWQgdG8gYmUgbm9ybWFsaXNlZCB0byBhIGRpZmZlcmVudCB0eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VwYXJhdG9yPScsJ10gLSBhIHNlcGFyYXRvciBhcnJheSBpdGVtcyBhcmUgc2VyaWFsaXplZCB3aXRoLCBieSBkZWZhdWx0IGl0J3MgYSBjb21tYSAoYCxgKVxuICAgKiAqL1xuICBzdGF0aWMgcHJvY2Vzc0hpZXJhcmNoeShmbGF0SGllcmFyY2h5LG5vcm1hbHM9e30sc2VwYXJhdG9yPScsJyl7XG4gICAgbGV0IG9ycGhhbnMgPSBbXSxcbiAgICAgICAgdG9Ob3JtYWxpemUgPSBPYmplY3Qua2V5cyhub3JtYWxzKS5sZW5ndGg+MDtcbiAgICBmb3IobGV0IGtleSBpbiBmbGF0SGllcmFyY2h5KXtcbiAgICAgIGxldCBpdGVtID0gZmxhdEhpZXJhcmNoeVtrZXldO1xuICAgICAgaWYodG9Ob3JtYWxpemUpTWFwSGllcmFyY2h5Lm5vcm1hbGl6ZShpdGVtLG5vcm1hbHMpO1xuXG4gICAgICAvLyBtYXAgaXRlbSB0byBwYXJlbnRcbiAgICAgIGlmKGl0ZW0ucGFyZW50ICYmIGl0ZW0ucGFyZW50IT1udWxsICYmIGl0ZW0ucGFyZW50Lmxlbmd0aD4wKXtcbiAgICAgICAgaXRlbS5wYXJlbnQgPSBmbGF0SGllcmFyY2h5W2l0ZW0ucGFyZW50XTtcbiAgICAgICAgaXRlbS5wYXJlbnQuc3ViY2VsbHMgPSBpdGVtLnBhcmVudC5zdWJjZWxscyB8fCBbXTtcbiAgICAgICAgaXRlbS5wYXJlbnQuc3ViY2VsbHMucHVzaChpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ycGhhbnMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9ycGhhbnNcbiAgfVxuXG4gIHN0YXRpYyBjb21wb3NlRmxhdEhpZXJhcmNoeShoaWVyYXJjaHksbm9ybWFscyl7XG4gICAgbGV0IG89e307XG4gICAgbGV0IHRvTm9ybWFsaXplID0gbm9ybWFscy5rZXlzKCkubGVuZ3RoPjA7XG4gICAgaGllcmFyY2h5LmZvckVhY2goXG4gICAgICBpdGVtPT57XG4gICAgICAgIGlmKHRvTm9ybWFsaXplKU1hcEhpZXJhcmNoeS5ub3JtYWxpemUoaXRlbSxub3JtYWxzKTtcbiAgICAgICAgb1tpdGVtLmlkXT1pdGVtO1xuICAgICAgfSk7XG4gICAgcmV0dXJuIG87XG4gIH1cblxuICAvKipcbiAgICogbm9ybWFsaXplcyBhIHN0cmluZyB2YWx1ZSB0byBhIGNlcnRhaW4gZm9ybWF0LlxuICAgKiAtIGBhcnJheVN0cmluZ2AgLSBub3JtYWxpemVzIGNvbW1hLXNlcGFyYXRlZCBpdGVtcyB0byBhbiBBcnJheSBvZiBTdHJpbmdzLCBpLmUgXCJoYWhhXCIsIFwibGFsYVwiIHdvdWxkIGJlIFtcImhhaGFcIiwgXCJsYWxhXCJdXG4gICAqIC0gYGFycmF5TnVtYmVyYCAtIG5vcm1hbGl6ZXMgY29tbWEtc2VwYXJhdGVkIGl0ZW1zIHRvIGFuIEFycmF5IG9mIEZsb2F0cywgaS5lIFwiLTEzLjQxXCIsIFwiNDguNjZcIiB3b3VsZCBiZSBbLTEzLjQxLCA0OC42Nl1cbiAgICogLSBgc3RyaW5nYCAtIHJldHVybnMgdGhlIHN0cmluZyBhcyBpc1xuICAgKiAtIGBudW1iZXJgIC0gcGFyc2VzIHRoZSBzdHJpbmcgYXMgYSBGbG9hdFxuICAgKiAtIGBib29sZWFuYCAtIHBhcnNlcyB0aGUgc3RyaW5nIGFzIGEgQm9vbGVhbiwgY2FzZSBpbnNlbnNpdGl2ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSAtIGl0ZW0gdG8gbWF0Y2ggY29udGVudHMgYWdhaW5zdCBgbm9ybWFsc2BcbiAgICogQHBhcmFtIHtPYmplY3R9IFtub3JtYWxzPXt9XSAtIGFuIG9iamVjdCB3aGVyZSBrZXlzIG15c3QgY29pbmNpZGUgd2l0aCBjb2x1bW4gaWRzICh0aHVzIGJlIGlkZW50aWNhbCB0byBrZXlzIGluIGBpdGVtYCkuIGBub3JtYWxzYCBkb2Vzbid0IHJlcXVpcmUgZm9yIGFsbCBrZXlzIGZyb20gYGl0ZW1gIHRvIGJlIHByZXNlbnQsIG9ubHkgdGhvc2UgdGhhdCBuZWVkIHRvIGJlIG5vcm1hbGlzZWQgdG8gYSBkaWZmZXJlbnQgdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlcGFyYXRvcj0nLCddIC0gYSBzZXBhcmF0b3IgYXJyYXkgaXRlbXMgYXJlIHNlcmlhbGl6ZWQgd2l0aCwgYnkgZGVmYXVsdCBpdCdzIGEgY29tbWEgKGAsYClcbiAgICogKi9cbiAgc3RhdGljIG5vcm1hbGl6ZShpdGVtLG5vcm1hbHM9e30sc2VwYXJhdG9yPScsJyl7XG4gICAgbGV0IHBhcnNlciA9IHtcbiAgICAgIHN0cmluZ0FycmF5OiB2YWwgPT4gdmFsLnNwbGl0KHNlcGFyYXRvciksXG4gICAgICBudW1iZXJBcnJheTogdmFsID0+IHZhbC5zcGxpdChzZXBhcmF0b3IpLm1hcChpPT5wYXJzZUZsb2F0KGkpKSxcbiAgICAgIHN0cmluZzogdmFsID0+IHZhbC50cmltKCksXG4gICAgICBudW1iZXI6IHZhbCA9PiB2YWwhPW51bGwgJiYgIWlzTmFOKHBhcnNlRmxvYXQodmFsKSk/IHBhcnNlRmxvYXQodmFsKTogbnVsbCxcbiAgICAgIGJvb2xlYW46IHZhbCA9PiB2YWwudG9Mb3dlckNhc2UoKT09XCJ0cnVlXCIgfHwgdmFsPT1cIjFcIlxuICAgIH07XG4gICAgZm9yKGxldCBub3JtYWwgaW4gbm9ybWFscyl7XG4gICAgICBpZihpdGVtW25vcm1hbF0pey8vIHByb3BlcnR5IGV4aXN0cyBpbiBvYmplY3RcbiAgICAgICAgaWYoaXRlbVtub3JtYWxdLmxlbmd0aD4wKXtcbiAgICAgICAgICBpdGVtW25vcm1hbF0gPSBwYXJzZXJbbm9ybWFsc1tub3JtYWxdXShpdGVtW25vcm1hbF0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGl0ZW1bbm9ybWFsXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogVXBkYXRlcyBpbml0aWFsIGhpZXJhcmNoeVxuICAgKiBAcGFyYW0gaGllcmFyY2h5XG4gICAqIEBwYXJhbSBwYXJlbnQgLSBoaWVyYXJjaHkgbGV2ZWwgcGFyZW50XG4gICAqL1xuICBzdGF0aWMgYWRkTWFwSURzVG9IaWVyYXJjaHlMZXZlbChoaWVyYXJjaHksIHBhcmVudCA9IG51bGwpIHtcbiAgICBoaWVyYXJjaHkuZm9yRWFjaChzdWJjZWxsID0+IHtcbiAgICAgIGlmKHN1YmNlbGwucGFyZW50ICYmIHN1YmNlbGwucGFyZW50IT1udWxsICYmIHN1YmNlbGwucGFyZW50Lm1hcE5hbWUpe1xuICAgICAgICBzdWJjZWxsLm1hcE5hbWUgPSBzdWJjZWxsLnBhcmVudC5tYXBOYW1lO1xuICAgICAgfVxuICAgICAgaWYgKHN1YmNlbGwuc3ViY2VsbHMpIHtcbiAgICAgICAgTWFwSGllcmFyY2h5LmFkZE1hcElEc1RvSGllcmFyY2h5TGV2ZWwoc3ViY2VsbC5zdWJjZWxscywgc3ViY2VsbCk7XG4gICAgICB9XG4gICAgICBpZihzdWJjZWxsLnBhcmVudCAmJiBzdWJjZWxsLm1hcElEICYmICFzdWJjZWxsLnBhcmVudC5tYXBOYW1lKXtcbiAgICAgICAgaWYoIXN1YmNlbGwucGFyZW50Lm1hcElEKVxuICAgICAgICAgIHN1YmNlbGwucGFyZW50Lm1hcElEID0gW107XG4gICAgICAgIHN1YmNlbGwucGFyZW50Lm1hcElEID0gc3ViY2VsbC5wYXJlbnQubWFwSUQuY29uY2F0KHN1YmNlbGwubWFwSUQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn1cbmV4cG9ydCBkZWZhdWx0IE1hcEhpZXJhcmNoeVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21hcC1oaWVyYXJjaHkuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 15 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItYWdncmVnYXRlZC10YWJsZS9zcmMvYWdncmVnYXRlZC10YWJsZS5jc3M/Y2QxNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ItYWdncmVnYXRlZC10YWJsZS9zcmMvYWdncmVnYXRlZC10YWJsZS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 16 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Itc29ydC10YWJsZS9zcmMvc29ydC10YWJsZS1zdHlsZXMuY3NzP2JmYzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yLXNvcnQtdGFibGUvc3JjL3NvcnQtdGFibGUtc3R5bGVzLmNzc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 17 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItdGFibGUtZmxvYXRpbmctaGVhZGVyL3NyYy90YWJsZS1mbG9hdGluZy1oZWFkZXItc3R5bGVzLmNzcz8zNWE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vci10YWJsZS1mbG9hdGluZy1oZWFkZXIvc3JjL3RhYmxlLWZsb2F0aW5nLWhlYWRlci1zdHlsZXMuY3NzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 18 */,
/* 19 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZHJpbGxkb3duLW1hcC5jc3M/ZjM4YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZHJpbGxkb3duLW1hcC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }
/******/ ]);