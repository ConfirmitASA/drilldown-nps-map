/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _DrilldownMap = __webpack_require__(13);\n\nvar _DrilldownMap2 = _interopRequireDefault(_DrilldownMap);\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nwindow.Reportal = window.Reportal || {};\n_rReportalBase2.default.mixin(window.Reportal, {\n  DrilldownMap: _DrilldownMap2.default,\n  ReportalBase: _rReportalBase2.default\n});\n\nexports.default = _DrilldownMap2.default;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz8zNDc5Il0sIm5hbWVzIjpbIndpbmRvdyIsIlJlcG9ydGFsIiwibWl4aW4iLCJEcmlsbGRvd25NYXAiLCJSZXBvcnRhbEJhc2UiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBQSxPQUFPQyxRQUFQLEdBQWtCRCxPQUFPQyxRQUFQLElBQW1CLEVBQXJDO0FBQ0Esd0JBQWFDLEtBQWIsQ0FBbUJGLE9BQU9DLFFBQTFCLEVBQW1DO0FBQ2pDRSxzQ0FEaUM7QUFFakNDO0FBRmlDLENBQW5DIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBEcmlsbGRvd25NYXAgZnJvbSBcIi4vRHJpbGxkb3duTWFwXCI7XG5pbXBvcnQgUmVwb3J0YWxCYXNlIGZyb20gXCJyLXJlcG9ydGFsLWJhc2VcIjtcblxud2luZG93LlJlcG9ydGFsID0gd2luZG93LlJlcG9ydGFsIHx8IHt9O1xuUmVwb3J0YWxCYXNlLm1peGluKHdpbmRvdy5SZXBvcnRhbCx7XG4gIERyaWxsZG93bk1hcCxcbiAgUmVwb3J0YWxCYXNlXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgRHJpbGxkb3duTWFwXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWFpbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ReportalBase = function () {\n  function ReportalBase() {\n    _classCallCheck(this, ReportalBase);\n  }\n\n  _createClass(ReportalBase, null, [{\n    key: 'mixin',\n\n\n    /**\r\n     * Copies props from a source object to a target object.\r\n     *\r\n     * Note, this method uses a simple `for...in` strategy for enumerating\r\n     * properties.  To ensure only `ownProperties` are copied from source\r\n     * to target and that accessor implementations are copied, use `extend`.\r\n     *\r\n     * @method mixin\r\n     * @param {Object} target Target object to copy properties to.\r\n     * @param {Object} source Source object to copy properties from.\r\n     * @return {Object} Target object that was passed as first argument.\r\n     */\n    value: function mixin(target, source) {\n      for (var i in source) {\n        target[i] = source[i];\n      }\n      return target;\n    }\n  }, {\n    key: '_logger',\n    value: function _logger(level, args) {\n      // accept ['foo', 'bar'] and [['foo', 'bar']]\n      if (args.length === 1 && Array.isArray(args[0])) {\n        args = args[0];\n      }\n      // only accept logging functions\n      switch (level) {\n        case 'log':\n        case 'warn':\n        case 'error':\n          console[level].apply(console, args);\n          break;\n      }\n    }\n  }, {\n    key: '_log',\n    value: function _log() {\n      var args = Array.prototype.slice.call(arguments, 0);\n      this._logger('log', args);\n    }\n  }, {\n    key: '_warn',\n    value: function _warn() {\n      var args = Array.prototype.slice.call(arguments, 0);\n      this._logger('warn', args);\n    }\n  }, {\n    key: '_error',\n    value: function _error() {\n      var args = Array.prototype.slice.call(arguments, 0);\n      this._logger('error', args);\n    }\n\n    /**\r\n     * Creates a named event with `name`\r\n     * @param {String} name - name of the event\r\n     * @return {Event} Returns a created event\r\n     * */\n\n  }, {\n    key: 'newEvent',\n    value: function newEvent(name) {\n      var event = document.createEvent('Event');\n      event.initEvent(name, true, true);\n      return event;\n    }\n\n    /**\r\n     * Inspects if the current string might be converted to number and renders it as number. If string length is 0, returns `null`. If none applies returns the string as is.\r\n     * @param {String} str - value of the cell if not HTML contents\r\n     * @return {Number|null|String}\r\n     * */\n\n  }, {\n    key: 'isNumber',\n    value: function isNumber(str) {\n      if (!isNaN(parseFloat(str))) {\n        str = str.replace(/,/i, ''); // remove unnecessary comma as a delimiter for thousands from data.\n        return parseFloat(str);\n      } else if (str.length == 0) {\n        return null;\n      } else {\n        return str;\n      }\n    }\n\n    /**\r\n     * Creates an XHR wrapped in a Promise\r\n     * @param {!String} URL - url to send a `GET` request to\r\n     * @return {Promise} Returns a then-able promise with `XMLHttpRequest.responseText`\r\n     * */\n\n  }, {\n    key: 'promiseRequest',\n    value: function promiseRequest(URL) {\n      return new Promise(function (resolve, reject) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', URL, true);\n        xhr.onload = function () {\n          xhr.status == 200 ? resolve(xhr.responseText) : reject(Error(xhr.status + ': ' + xhr.statusText));\n        };\n        xhr.onerror = function () {\n          reject(Error(\"Network Error\"));\n        };\n        xhr.send();\n      });\n    }\n\n    /**\r\n     * Gets a variable listed in query string\r\n     * @param {!String} variable - variable name to get value for\r\n     * @param {String=} [query=window.location.search.substring(1)] - the query string to search variable for in\r\n     * @return {String} Returns value for the variable\r\n     * */\n\n  }, {\n    key: 'getQueryVariable',\n    value: function getQueryVariable(variable) {\n      var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.location.search.substring(1);\n\n      var vars = query.split(\"&\");\n      for (var i = 0; i < vars.length; i++) {\n        var pair = vars[i].split(\"=\");\n        if (pair[0].toLowerCase() == variable.toLowerCase()) {\n          return pair[1];\n        }\n      }\n      return null;\n    }\n  }]);\n\n  return ReportalBase;\n}();\n\nexports.default = ReportalBase;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItcmVwb3J0YWwtYmFzZS9zcmMvcmVwb3J0YWwtYmFzZS5qcz9kYTM1Il0sIm5hbWVzIjpbIlJlcG9ydGFsQmFzZSIsInRhcmdldCIsInNvdXJjZSIsImkiLCJsZXZlbCIsImFyZ3MiLCJsZW5ndGgiLCJBcnJheSIsImlzQXJyYXkiLCJjb25zb2xlIiwiYXBwbHkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJhcmd1bWVudHMiLCJfbG9nZ2VyIiwibmFtZSIsImV2ZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsInN0ciIsImlzTmFOIiwicGFyc2VGbG9hdCIsInJlcGxhY2UiLCJVUkwiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsIm9ubG9hZCIsInN0YXR1cyIsInJlc3BvbnNlVGV4dCIsIkVycm9yIiwic3RhdHVzVGV4dCIsIm9uZXJyb3IiLCJzZW5kIiwidmFyaWFibGUiLCJxdWVyeSIsIndpbmRvdyIsImxvY2F0aW9uIiwic2VhcmNoIiwic3Vic3RyaW5nIiwidmFycyIsInNwbGl0IiwicGFpciIsInRvTG93ZXJDYXNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0lBQU1BLFk7Ozs7Ozs7OztBQUVKOzs7Ozs7Ozs7Ozs7MEJBWWFDLE0sRUFBUUMsTSxFQUFRO0FBQzNCLFdBQUssSUFBSUMsQ0FBVCxJQUFjRCxNQUFkLEVBQXNCO0FBQ3BCRCxlQUFPRSxDQUFQLElBQVlELE9BQU9DLENBQVAsQ0FBWjtBQUNEO0FBQ0QsYUFBT0YsTUFBUDtBQUNEOzs7NEJBRWNHLEssRUFBT0MsSSxFQUFNO0FBQzFCO0FBQ0EsVUFBSUEsS0FBS0MsTUFBTCxLQUFnQixDQUFoQixJQUFxQkMsTUFBTUMsT0FBTixDQUFjSCxLQUFLLENBQUwsQ0FBZCxDQUF6QixFQUFpRDtBQUMvQ0EsZUFBT0EsS0FBSyxDQUFMLENBQVA7QUFDRDtBQUNEO0FBQ0Es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Ozs7a0JBR1kvQyxZIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBSZXBvcnRhbEJhc2Uge1xyXG5cclxuICAvKipcclxuICAgKiBDb3BpZXMgcHJvcHMgZnJvbSBhIHNvdXJjZSBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogTm90ZSwgdGhpcyBtZXRob2QgdXNlcyBhIHNpbXBsZSBgZm9yLi4uaW5gIHN0cmF0ZWd5IGZvciBlbnVtZXJhdGluZ1xyXG4gICAqIHByb3BlcnRpZXMuICBUbyBlbnN1cmUgb25seSBgb3duUHJvcGVydGllc2AgYXJlIGNvcGllZCBmcm9tIHNvdXJjZVxyXG4gICAqIHRvIHRhcmdldCBhbmQgdGhhdCBhY2Nlc3NvciBpbXBsZW1lbnRhdGlvbnMgYXJlIGNvcGllZCwgdXNlIGBleHRlbmRgLlxyXG4gICAqXHJcbiAgICogQG1ldGhvZCBtaXhpblxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGFyZ2V0IG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBTb3VyY2Ugb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxyXG4gICAqIEByZXR1cm4ge09iamVjdH0gVGFyZ2V0IG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgYXMgZmlyc3QgYXJndW1lbnQuXHJcbiAgICovXHJcbiAgc3RhdGljIG1peGluKHRhcmdldCwgc291cmNlKSB7XHJcbiAgICBmb3IgKHZhciBpIGluIHNvdXJjZSkge1xyXG4gICAgICB0YXJnZXRbaV0gPSBzb3VyY2VbaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIF9sb2dnZXIobGV2ZWwsIGFyZ3MpIHtcclxuICAgIC8vIGFjY2VwdCBbJ2ZvbycsICdiYXInXSBhbmQgW1snZm9vJywgJ2JhciddXVxyXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcclxuICAgICAgYXJncyA9IGFyZ3NbMF07XHJcbiAgICB9XHJcbiAgICAvLyBvbmx5IGFjY2VwdCBsb2dnaW5nIGZ1bmN0aW9uc1xyXG4gICAgc3dpdGNoKGxldmVsKSB7XHJcbiAgICAgIGNhc2UgJ2xvZyc6XHJcbiAgICAgIGNhc2UgJ3dhcm4nOlxyXG4gICAgICBjYXNlICdlcnJvcic6XHJcbiAgICAgICAgY29uc29sZVtsZXZlbF0uYXBwbHkoY29uc29sZSwgYXJncyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgX2xvZygpIHtcclxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcclxuICAgIHRoaXMuX2xvZ2dlcignbG9nJywgYXJncyk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgX3dhcm4oKSB7XHJcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XHJcbiAgICB0aGlzLl9sb2dnZXIoJ3dhcm4nLCBhcmdzKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBfZXJyb3IoKSB7XHJcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XHJcbiAgICB0aGlzLl9sb2dnZXIoJ2Vycm9yJywgYXJncyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmFtZWQgZXZlbnQgd2l0aCBgbmFtZWBcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICogQHJldHVybiB7RXZlbnR9IFJldHVybnMgYSBjcmVhdGVkIGV2ZW50XHJcbiAgICogKi9cclxuICBzdGF0aWMgbmV3RXZlbnQobmFtZSl7XHJcbiAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxuICAgIGV2ZW50LmluaXRFdmVudChuYW1lLCB0cnVlLCB0cnVlKTtcclxuICAgIHJldHVybiBldmVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluc3BlY3RzIGlmIHRoZSBjdXJyZW50IHN0cmluZyBtaWdodCBiZSBjb252ZXJ0ZWQgdG8gbnVtYmVyIGFuZCByZW5kZXJzIGl0IGFzIG51bWJlci4gSWYgc3RyaW5nIGxlbmd0aCBpcyAwLCByZXR1cm5zIGBudWxsYC4gSWYgbm9uZSBhcHBsaWVzIHJldHVybnMgdGhlIHN0cmluZyBhcyBpcy5cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gdmFsdWUgb2YgdGhlIGNlbGwgaWYgbm90IEhUTUwgY29udGVudHNcclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ8bnVsbHxTdHJpbmd9XHJcbiAgICogKi9cclxuICBzdGF0aWMgaXNOdW1iZXIoc3RyKXtcclxuICAgIGlmKCFpc05hTihwYXJzZUZsb2F0KHN0cikpKXtcclxuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLywvaSwnJyk7Ly8gcmVtb3ZlIHVubmVjZXNzYXJ5IGNvbW1hIGFzIGEgZGVsaW1pdGVyIGZvciB0aG91c2FuZHMgZnJvbSBkYXRhLlxyXG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIpO1xyXG4gICAgfSBlbHNlIGlmKHN0ci5sZW5ndGg9PTApe3JldHVybiBudWxsfSBlbHNlIHtyZXR1cm4gc3RyfVxyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gWEhSIHdyYXBwZWQgaW4gYSBQcm9taXNlXHJcbiAgICogQHBhcmFtIHshU3RyaW5nfSBVUkwgLSB1cmwgdG8gc2VuZCBhIGBHRVRgIHJlcXVlc3QgdG9cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXR1cm5zIGEgdGhlbi1hYmxlIHByb21pc2Ugd2l0aCBgWE1MSHR0cFJlcXVlc3QucmVzcG9uc2VUZXh0YFxyXG4gICAqICovXHJcbiAgc3RhdGljIHByb21pc2VSZXF1ZXN0KFVSTCl7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KT0+e1xyXG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgIHhoci5vcGVuKCdHRVQnLCBVUkwsIHRydWUpO1xyXG4gICAgICB4aHIub25sb2FkID0gKCk9Pnt4aHIuc3RhdHVzID09IDIwMD9yZXNvbHZlKHhoci5yZXNwb25zZVRleHQpOnJlamVjdChFcnJvcihgJHt4aHIuc3RhdHVzfTogJHt4aHIuc3RhdHVzVGV4dH1gKSk7fVxyXG4gICAgICB4aHIub25lcnJvciA9ICgpPT57cmVqZWN0KEVycm9yKFwiTmV0d29yayBFcnJvclwiKSk7fVxyXG4gICAgICB4aHIuc2VuZCgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGEgdmFyaWFibGUgbGlzdGVkIGluIHF1ZXJ5IHN0cmluZ1xyXG4gICAqIEBwYXJhbSB7IVN0cmluZ30gdmFyaWFibGUgLSB2YXJpYWJsZSBuYW1lIHRvIGdldCB2YWx1ZSBmb3JcclxuICAgKiBAcGFyYW0ge1N0cmluZz19IFtxdWVyeT13aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKV0gLSB0aGUgcXVlcnkgc3RyaW5nIHRvIHNlYXJjaCB2YXJpYWJsZSBmb3IgaW5cclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFJldHVybnMgdmFsdWUgZm9yIHRoZSB2YXJpYWJsZVxyXG4gICAqICovXHJcbiAgc3RhdGljIGdldFF1ZXJ5VmFyaWFibGUodmFyaWFibGUscXVlcnk9d2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpe1xyXG4gICAgdmFyIHZhcnMgPSBxdWVyeS5zcGxpdChcIiZcIik7XHJcbiAgICBmb3IgKHZhciBpPTA7aTx2YXJzLmxlbmd0aDtpKyspIHtcclxuICAgICAgdmFyIHBhaXIgPSB2YXJzW2ldLnNwbGl0KFwiPVwiKTtcclxuICAgICAgaWYoKHBhaXJbMF0pLnRvTG93ZXJDYXNlKCkgPT0gdmFyaWFibGUudG9Mb3dlckNhc2UoKSl7cmV0dXJuIHBhaXJbMV07fVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxufVxyXG5leHBvcnQgZGVmYXVsdCBSZXBvcnRhbEJhc2VcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yLXJlcG9ydGFsLWJhc2Uvc3JjL3JlcG9ydGFsLWJhc2UuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by IvanP on 21.09.2016.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//import TableDataRowMeta from \"./TableDataRowMeta\";\n\n/**\r\n * A base class for stripping data from HTML tables\r\n * */\nvar TableData = function () {\n  function TableData() {\n    _classCallCheck(this, TableData);\n  }\n\n  _createClass(TableData, null, [{\n    key: 'detectMultidimensional',\n\n    /**\r\n     * Detects if the dataset is multi-dimentional and sets classes on items: a rowspanning cell gets a `.blockCell` and the row containing it a `.firstInBlock`\r\n     * __Doesn't work with `Horizontal Percents` enabled!__\r\n     * @param {HTMLTableElement} source - source table\r\n     * @return {Boolean} Returns if the data in table is multi-dimentional\r\n     * */\n    value: function detectMultidimensional(source) {\n      var multidimensional = false;\n      var blocks = source.parentNode.querySelectorAll('table#' + source.id + '>tbody>tr>td:nth-child(1)[rowspan]');\n      if (blocks.length > 0) {\n        multidimensional = true;\n        [].slice.call(blocks).forEach(function (blockCell) {\n          blockCell.classList.add('blockCell');\n          blockCell.parentNode.classList.add('firstInBlock');\n        });\n      }\n      return multidimensional;\n    }\n\n    /**\r\n     * Extracts data from a given cell. Override in an inherited class if you need to add any metadata to it.\r\n     * @param {HTMLTableCellElement} cell - cell element to have data stripped off it\r\n     * @param {HTMLTableCellElement} rowIndex - index of the row it's in\r\n     * @param {HTMLTableCellElement} columnIndex - index of the column it's in\r\n     * @returns {?String|?Number} Returns a `String`, a `Number` or a `null` (if data is absent in the cell or its text content boils down to an empty string - i.e. there are no characters in the cell, only HTML tags)\r\n     * */\n\n  }, {\n    key: 'prepareDataCell',\n    value: function prepareDataCell(cell, rowIndex, columnIndex) {\n      return _rReportalBase2.default.isNumber(cell.textContent.trim());\n      /*return {\r\n          cell,\r\n          data: ReportalBase.isNumber(cell.textContent.trim()),\r\n          rowIndex,\r\n          columnIndex\r\n        }*/\n    }\n\n    /**\r\n     * A universal data-extraction function. It strips data from a table's body. Data can be stripped by rows (horizontally) or by columns (vertically) which is controlled by `direction`. It accounts for a spanning block cell and may exclude it.\r\n     * @param {Object} options - options to configure the way data is stripped off the table\r\n     * @param {HTMLTableElement} options.source - source table that will be an input for data stripping\r\n     * @param {String=} options.direction='row' - direction in which data stripping will occur: `row` strips across rows and presents an array where each array item is an array of cell values. `column` strips values verticaly in a column, the resulting array will contain arrays (per column) with values resembling normalized data for cells in the column\r\n     * @param {Boolean=} [options.excludeBlock=true] - if table contains block cells that rowspan across several rows, we might need to exclude those from actual data\r\n     * @param {Array|Number} [options.excludeColumns] - if table contains columns that are not to be in data, then pass a single index or an array of cell indices (0-based). You need to count columns not by headers but by the cells in rows.\r\n     * @param {Array|Number} [options.excludeRows] - if table contains rows that are not to be in data, then pass a single index or an array of row indices (0-based). You need to count only rows that contain data, not the table-header rows.\r\n     * @param {Boolean=} options.multidimensional=false - whether the table has aggregating cells that aggregate rowheaders. Result of {@link TableData#detectMultidimensional} may be passed here to automatically calculate if it has aggregating cells.\r\n     * @returns {Array} returns data array.\r\n     * */\n\n  }, {\n    key: 'getData',\n    value: function getData(options) {\n      var _this = this;\n\n      var source = options.source,\n          _options$excludeBlock = options.excludeBlock,\n          excludeBlock = _options$excludeBlock === undefined ? true : _options$excludeBlock,\n          excludeColumns = options.excludeColumns,\n          excludeRows = options.excludeRows,\n          _options$direction = options.direction,\n          direction = _options$direction === undefined ? 'row' : _options$direction,\n          _options$multidimensi = options.multidimensional,\n          multidimensional = _options$multidimensi === undefined ? false : _options$multidimensi;\n\n      var data = [];\n      if (source && source.tagName == 'TABLE') {\n        (function () {\n          var rows = [].slice.call(source.parentNode.querySelectorAll('table#' + source.id + '>tbody>tr'));\n          if (rows.length > 0) {\n            (function () {\n              var tempArray = [];\n              // account for a negative row number (`-1`) meaning last row\n              if ((typeof excludeRows === 'undefined' ? 'undefined' : _typeof(excludeRows)) != undefined) {\n                if (typeof excludeRows == 'number') {\n                  // for non-block rows in multidimensional\n                  if (excludeRows < 0) {\n                    // account for a negative column number (e.g.`-1`) meaning last column\n                    excludeRows = rows.length + excludeRows;\n                  }\n                  rows.splice(excludeRows, 1);\n                }\n                if (Array.isArray(excludeRows)) {\n                  excludeRows.sort(function (a, b) {\n                    return a > b ? 1 : -1;\n                  }).reverse(); //sort to splice from the end of the array\n                  excludeRows.forEach(function (i) {\n                    if (i >= 0) {\n                      rows.splice(i, 1);\n                    } else {\n                      rows.splice(rows.length + i, 1);\n                    }\n                  });\n                }\n              }\n              rows.forEach(function (row, rowIndex) {\n                if (multidimensional) {\n                  // we need to check if the `tempArray` is not empty and push it to the `data` array, because we've encountered a new block, so the old block has to be pushed to data. Then we need to create a new block array and push there\n                  if (row.classList.contains('firstInBlock')) {\n                    if (Array.isArray(tempArray) && tempArray.length > 0) {\n                      data.push(tempArray);\n                    }\n                    tempArray = [];\n                  }\n                }\n\n                if (direction == 'row' && !Array.isArray(tempArray[tempArray.length])) {\n                  // if a row in an array doesn't exist create it\n                  tempArray[tempArray.length] = [];\n                }\n\n                // calculate which cells to exclude\n                var cells = [].slice.call(row.children);\n                var temp_excludeColumns = excludeColumns;\n                if ((typeof temp_excludeColumns === 'undefined' ? 'undefined' : _typeof(temp_excludeColumns)) != undefined) {\n                  if (typeof temp_excludeColumns == 'number') {\n                    // for non-block rows in multidimensional\n                    if (multidimensional && !row.classList.contains('firstInBlock') && !temp_excludeColumns < 0) {\n                      temp_excludeColumns = temp_excludeColumns + 1;\n                    }\n                    if (temp_excludeColumns < 0) {\n                      // account for a negative column number (e.g.`-1`) meaning last column\n                      temp_excludeColumns = cells.length + temp_excludeColumns;\n                    }\n                    cells.splice(temp_excludeColumns, 1);\n                  }\n                  if (Array.isArray(temp_excludeColumns)) {\n                    temp_excludeColumns.sort(function (a, b) {\n                      return a > b ? 1 : -1;\n                    }).reverse();\n                    temp_excludeColumns.forEach(function (i) {\n                      if (i >= 0) {\n                        cells.splice(multidimensional && !row.classList.contains('firstInBlock') ? i + 1 : i, 1);\n                      } else {\n                        cells.splice(cells.length + i, 1);\n                      }\n                    });\n                  }\n                }\n\n                cells.forEach(function (cell, index) {\n\n                  // we want to run this every row because number of cells in each row may differ and we want to exclude the last one\n                  if (typeof direction == 'string' && direction == 'row') {\n                    //if we strip data horizontally by row\n                    if (!(multidimensional && excludeBlock && cell.rowSpan > 1)) {\n                      // if it's a block cell we'd exclude it from data\n                      tempArray[tempArray.length - 1].push(_this.prepareDataCell(cell, rowIndex, index));\n                    }\n                  } else if (typeof direction == 'string' && direction == 'column') {\n                    //if we strip data vertically by column\n                    var realIndex = index;\n                    if (!(multidimensional && excludeBlock && cell.rowSpan > 1)) {\n                      //exclude block cell\n                      realIndex += !row.classList.contains('firstInBlock') ? 0 : -1; // offset cell that follows block cell one position back\n                      if (!Array.isArray(tempArray[realIndex])) {\n                        //create column array for current column if not available\n                        tempArray[realIndex] = [];\n                      }\n                      tempArray[realIndex].push(_this.prepareDataCell(cell, rowIndex, realIndex));\n                    }\n                  } else {\n                    throw new TypeError('direction has tobe a String==`row | column`, not a ${direction}');\n                  }\n                });\n              });\n              //we need to push the last block Array because there'll be no `.firstInBlock` anymore to do that\n              if (multidimensional && Array.isArray(tempArray) && tempArray.length > 0) {\n                data.push(tempArray);\n              } else {\n                data = tempArray;\n              }\n            })();\n          } else {\n            throw new Error('table#' + source.id + '\\'s body must contain rows');\n          }\n        })();\n      } else {\n        throw new TypeError('source must be defined and be a table');\n      }\n      return data;\n    }\n  }]);\n\n  return TableData;\n}();\n\nexports.default = TableData;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItYWdncmVnYXRlZC10YWJsZS9zcmMvdGFibGUtZGF0YS5qcz84ZDlhIl0sIm5hbWVzIjpbIlRhYmxlRGF0YSIsInNvdXJjZSIsIm11bHRpZGltZW5zaW9uYWwiLCJibG9ja3MiLCJwYXJlbnROb2RlIiwicXVlcnlTZWxlY3RvckFsbCIsImlkIiwibGVuZ3RoIiwic2xpY2UiLCJjYWxsIiwiZm9yRWFjaCIsImJsb2NrQ2VsbCIsImNsYXNzTGlzdCIsImFkZCIsImNlbGwiLCJyb3dJbmRleCIsImNvbHVtbkluZGV4IiwiaXNOdW1iZXIiLCJ0ZXh0Q29udGVudCIsInRyaW0iLCJvcHRpb25zIiwiZXhjbHVkZUJsb2NrIiwiZXhjbHVkZUNvbHVtbnMiLCJleGNsdWRlUm93cyIsImRpcmVjdGlvbiIsImRhdGEiLCJ0YWdOYW1lIiwicm93cyIsInRlbXBBcnJheSIsInVuZGVmaW5lZCIsInNwbGljZSIsIkFycmF5IiwiaXNBcnJheSIsInNvcnQiLCJhIiwiYiIsInJldmVyc2UiLCJpIiwicm93IiwiY29udGFpbnMiLCJwdXNoIiwiY2VsbHMiLCJjaGlsZHJlbiIsInRlbXBfZXhjbHVkZUNvbHVtbnMiLCJpbmRleCIsInJvd1NwYW4iLCJwcmVwYXJlRGF0YUNlbGwiLCJyZWFsSW5kZXgiLCJUeXBlRXJyb3IiLCJFcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7cWpCQUFBOzs7OztBQUdBOzs7Ozs7OztBQUNBOztBQUVBOzs7SUFHTUEsUzs7Ozs7Ozs7QUFDSjs7Ozs7OzJDQU04QkMsTSxFQUFPO0FBQ25DLFVBQUlDLG1CQUFtQixLQUF2QjtBQUNBLFVBQUlDLFNBQVNGLE9BQU9HLFVBQVAsQ0FBa0JDLGdCQUFsQixZQUE0Q0osT0FBT0ssRUFBbkQsd0NBQWI7QUFDQSxVQUFHSCxPQUFPSSxNQUFQLEdBQWMsQ0FBakIsRUFBbUI7QUFDakJMLDJCQUFtQixJQUFuQjtBQUNBLFdBQUdNLEtBQUgsQ0FBU0MsSUFBVCxDQUFjTixNQUFkLEVB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LE1BQUtNLGVBQUwsQ0FBcUJoQyxJQUFyQixFQUEwQkMsUUFBMUIsRUFBbUNnQyxTQUFuQyxDQUExQjtBQUNEO0FBQ0YsbUJBVE0sTUFTQTtBQUNMLDBCQUFNLElBQUlDLFNBQUosQ0FBYyxpRUFBZCxDQUFOO0FBQ0Q7QUFDRixpQkFuQkQ7QUFvQkQsZUEzREQ7QUE0REE7QUFDQSxrQkFBRzlDLG9CQUFvQjZCLE1BQU1DLE9BQU4sQ0FBY0osU0FBZCxDQUFwQixJQUFnREEsVUFBVXJCLE1BQVYsR0FBaUIsQ0FBcEUsRUFBc0U7QUFDcEVrQixxQkFBS2UsSUFBTCxDQUFVWixTQUFWO0FBQ0QsZUFGRCxNQUVPO0FBQ0xILHVCQUFPRyxTQUFQO0FBQ0Q7QUF4RmM7QUF5RmhCLFdBekZELE1BeUZPO0FBQ0wsa0JBQU0sSUFBSXFCLEtBQUosWUFBbUJoRCxPQUFPSyxFQUExQixnQ0FBTjtBQUNEO0FBN0ZvQztBQThGdEMsT0E5RkQsTUE4Rk87QUFDTCxjQUFNLElBQUkwQyxTQUFKLENBQWMsdUNBQWQsQ0FBTjtBQUNEO0FBQ0QsYUFBT3ZCLElBQVA7QUFDRDs7Ozs7O2tCQUlZekIsUyIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENyZWF0ZWQgYnkgSXZhblAgb24gMjEuMDkuMjAxNi5cclxuICovXHJcbmltcG9ydCBSZXBvcnRhbEJhc2UgZnJvbSBcInItcmVwb3J0YWwtYmFzZVwiO1xyXG4vL2ltcG9ydCBUYWJsZURhdGFSb3dNZXRhIGZyb20gXCIuL1RhYmxlRGF0YVJvd01ldGFcIjtcclxuXHJcbi8qKlxyXG4gKiBBIGJhc2UgY2xhc3MgZm9yIHN0cmlwcGluZyBkYXRhIGZyb20gSFRNTCB0YWJsZXNcclxuICogKi9cclxuY2xhc3MgVGFibGVEYXRhIHtcclxuICAvKipcclxuICAgKiBEZXRlY3RzIGlmIHRoZSBkYXRhc2V0IGlzIG11bHRpLWRpbWVudGlvbmFsIGFuZCBzZXRzIGNsYXNzZXMgb24gaXRlbXM6IGEgcm93c3Bhbm5pbmcgY2VsbCBnZXRzIGEgYC5ibG9ja0NlbGxgIGFuZCB0aGUgcm93IGNvbnRhaW5pbmcgaXQgYSBgLmZpcnN0SW5CbG9ja2BcclxuICAgKiBfX0RvZXNuJ3Qgd29yayB3aXRoIGBIb3Jpem9udGFsIFBlcmNlbnRzYCBlbmFibGVkIV9fXHJcbiAgICogQHBhcmFtIHtIVE1MVGFibGVFbGVtZW50fSBzb3VyY2UgLSBzb3VyY2UgdGFibGVcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGlmIHRoZSBkYXRhIGluIHRhYmxlIGlzIG11bHRpLWRpbWVudGlvbmFsXHJcbiAgICogKi9cclxuICBzdGF0aWMgZGV0ZWN0TXVsdGlkaW1lbnNpb25hbChzb3VyY2Upe1xyXG4gICAgbGV0IG11bHRpZGltZW5zaW9uYWwgPSBmYWxzZTtcclxuICAgIGxldCBibG9ja3MgPSBzb3VyY2UucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKGB0YWJsZSMke3NvdXJjZS5pZH0+dGJvZHk+dHI+dGQ6bnRoLWNoaWxkKDEpW3Jvd3NwYW5dYCk7XHJcbiAgICBpZihibG9ja3MubGVuZ3RoPjApe1xyXG4gICAgICBtdWx0aWRpbWVuc2lvbmFsID0gdHJ1ZTtcclxuICAgICAgW10uc2xpY2UuY2FsbChibG9ja3MpLmZvckVhY2goYmxvY2tDZWxsPT57XHJcbiAgICAgICAgYmxvY2tDZWxsLmNsYXNzTGlzdC5hZGQoJ2Jsb2NrQ2VsbCcpO1xyXG4gICAgICAgIGJsb2NrQ2VsbC5wYXJlbnROb2RlLmNsYXNzTGlzdC5hZGQoJ2ZpcnN0SW5CbG9jaycpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBtdWx0aWRpbWVuc2lvbmFsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeHRyYWN0cyBkYXRhIGZyb20gYSBnaXZlbiBjZWxsLiBPdmVycmlkZSBpbiBhbiBpbmhlcml0ZWQgY2xhc3MgaWYgeW91IG5lZWQgdG8gYWRkIGFueSBtZXRhZGF0YSB0byBpdC5cclxuICAgKiBAcGFyYW0ge0hUTUxUYWJsZUNlbGxFbGVtZW50fSBjZWxsIC0gY2VsbCBlbGVtZW50IHRvIGhhdmUgZGF0YSBzdHJpcHBlZCBvZmYgaXRcclxuICAgKiBAcGFyYW0ge0hUTUxUYWJsZUNlbGxFbGVtZW50fSByb3dJbmRleCAtIGluZGV4IG9mIHRoZSByb3cgaXQncyBpblxyXG4gICAqIEBwYXJhbSB7SFRNTFRhYmxlQ2VsbEVsZW1lbnR9IGNvbHVtbkluZGV4IC0gaW5kZXggb2YgdGhlIGNvbHVtbiBpdCdzIGluXHJcbiAgICogQHJldHVybnMgez9TdHJpbmd8P051bWJlcn0gUmV0dXJucyBhIGBTdHJpbmdgLCBhIGBOdW1iZXJgIG9yIGEgYG51bGxgIChpZiBkYXRhIGlzIGFic2VudCBpbiB0aGUgY2VsbCBvciBpdHMgdGV4dCBjb250ZW50IGJvaWxzIGRvd24gdG8gYW4gZW1wdHkgc3RyaW5nIC0gaS5lLiB0aGVyZSBhcmUgbm8gY2hhcmFjdGVycyBpbiB0aGUgY2VsbCwgb25seSBIVE1MIHRhZ3MpXHJcbiAgICogKi9cclxuICBzdGF0aWMgcHJlcGFyZURhdGFDZWxsKGNlbGwsIHJvd0luZGV4LCBjb2x1bW5JbmRleCl7XHJcbiAgIHJldHVybiBSZXBvcnRhbEJhc2UuaXNOdW1iZXIoY2VsbC50ZXh0Q29udGVudC50cmltKCkpO1xyXG4gICAgLypyZXR1cm4ge1xyXG4gICAgICAgIGNlbGwsXHJcbiAgICAgICAgZGF0YTogUmVwb3J0YWxCYXNlLmlzTnVtYmVyKGNlbGwudGV4dENvbnRlbnQudHJpbSgpKSxcclxuICAgICAgICByb3dJbmRleCxcclxuICAgICAgICBjb2x1bW5JbmRleFxyXG4gICAgICB9Ki9cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgdW5pdmVyc2FsIGRhdGEtZXh0cmFjdGlvbiBmdW5jdGlvbi4gSXQgc3RyaXBzIGRhdGEgZnJvbSBhIHRhYmxlJ3MgYm9keS4gRGF0YSBjYW4gYmUgc3RyaXBwZWQgYnkgcm93cyAoaG9yaXpvbnRhbGx5KSBvciBieSBjb2x1bW5zICh2ZXJ0aWNhbGx5KSB3aGljaCBpcyBjb250cm9sbGVkIGJ5IGBkaXJlY3Rpb25gLiBJdCBhY2NvdW50cyBmb3IgYSBzcGFubmluZyBibG9jayBjZWxsIGFuZCBtYXkgZXhjbHVkZSBpdC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSB3YXkgZGF0YSBpcyBzdHJpcHBlZCBvZmYgdGhlIHRhYmxlXHJcbiAgICogQHBhcmFtIHtIVE1MVGFibGVFbGVtZW50fSBvcHRpb25zLnNvdXJjZSAtIHNvdXJjZSB0YWJsZSB0aGF0IHdpbGwgYmUgYW4gaW5wdXQgZm9yIGRhdGEgc3RyaXBwaW5nXHJcbiAgICogQHBhcmFtIHtTdHJpbmc9fSBvcHRpb25zLmRpcmVjdGlvbj0ncm93JyAtIGRpcmVjdGlvbiBpbiB3aGljaCBkYXRhIHN0cmlwcGluZyB3aWxsIG9jY3VyOiBgcm93YCBzdHJpcHMgYWNyb3NzIHJvd3MgYW5kIHByZXNlbnRzIGFuIGFycmF5IHdoZXJlIGVhY2ggYXJyYXkgaXRlbSBpcyBhbiBhcnJheSBvZiBjZWxsIHZhbHVlcy4gYGNvbHVtbmAgc3RyaXBzIHZhbHVlcyB2ZXJ0aWNhbHkgaW4gYSBjb2x1bW4sIHRoZSByZXN1bHRpbmcgYXJyYXkgd2lsbCBjb250YWluIGFycmF5cyAocGVyIGNvbHVtbikgd2l0aCB2YWx1ZXMgcmVzZW1ibGluZyBub3JtYWxpemVkIGRhdGEgZm9yIGNlbGxzIGluIHRoZSBjb2x1bW5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBbb3B0aW9ucy5leGNsdWRlQmxvY2s9dHJ1ZV0gLSBpZiB0YWJsZSBjb250YWlucyBibG9jayBjZWxscyB0aGF0IHJvd3NwYW4gYWNyb3NzIHNldmVyYWwgcm93cywgd2UgbWlnaHQgbmVlZCB0byBleGNsdWRlIHRob3NlIGZyb20gYWN0dWFsIGRhdGFcclxuICAgKiBAcGFyYW0ge0FycmF5fE51bWJlcn0gW29wdGlvbnMuZXhjbHVkZUNvbHVtbnNdIC0gaWYgdGFibGUgY29udGFpbnMgY29sdW1ucyB0aGF0IGFyZSBub3QgdG8gYmUgaW4gZGF0YSwgdGhlbiBwYXNzIGEgc2luZ2xlIGluZGV4IG9yIGFuIGFycmF5IG9mIGNlbGwgaW5kaWNlcyAoMC1iYXNlZCkuIFlvdSBuZWVkIHRvIGNvdW50IGNvbHVtbnMgbm90IGJ5IGhlYWRlcnMgYnV0IGJ5IHRoZSBjZWxscyBpbiByb3dzLlxyXG4gICAqIEBwYXJhbSB7QXJyYXl8TnVtYmVyfSBbb3B0aW9ucy5leGNsdWRlUm93c10gLSBpZiB0YWJsZSBjb250YWlucyByb3dzIHRoYXQgYXJlIG5vdCB0byBiZSBpbiBkYXRhLCB0aGVuIHBhc3MgYSBzaW5nbGUgaW5kZXggb3IgYW4gYXJyYXkgb2Ygcm93IGluZGljZXMgKDAtYmFzZWQpLiBZb3UgbmVlZCB0byBjb3VudCBvbmx5IHJvd3MgdGhhdCBjb250YWluIGRhdGEsIG5vdCB0aGUgdGFibGUtaGVhZGVyIHJvd3MuXHJcbiAgICogQHBhcmFtIHtCb29sZWFuPX0gb3B0aW9ucy5tdWx0aWRpbWVuc2lvbmFsPWZhbHNlIC0gd2hldGhlciB0aGUgdGFibGUgaGFzIGFnZ3JlZ2F0aW5nIGNlbGxzIHRoYXQgYWdncmVnYXRlIHJvd2hlYWRlcnMuIFJlc3VsdCBvZiB7QGxpbmsgVGFibGVEYXRhI2RldGVjdE11bHRpZGltZW5zaW9uYWx9IG1heSBiZSBwYXNzZWQgaGVyZSB0byBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZSBpZiBpdCBoYXMgYWdncmVnYXRpbmcgY2VsbHMuXHJcbiAgICogQHJldHVybnMge0FycmF5fSByZXR1cm5zIGRhdGEgYXJyYXkuXHJcbiAgICogKi9cclxuICBzdGF0aWMgZ2V0RGF0YShvcHRpb25zKXtcclxuICAgIGxldCB7c291cmNlLGV4Y2x1ZGVCbG9jaz10cnVlLGV4Y2x1ZGVDb2x1bW5zLGV4Y2x1ZGVSb3dzLGRpcmVjdGlvbj0ncm93JyxtdWx0aWRpbWVuc2lvbmFsPWZhbHNlfT1vcHRpb25zO1xyXG4gICAgbGV0IGRhdGEgPSBbXTtcclxuICAgIGlmKHNvdXJjZSAmJiBzb3VyY2UudGFnTmFtZSA9PSAnVEFCTEUnKXtcclxuICAgICAgbGV0IHJvd3MgPSBbXS5zbGljZS5jYWxsKHNvdXJjZS5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoYHRhYmxlIyR7c291cmNlLmlkfT50Ym9keT50cmApKTtcclxuICAgICAgaWYocm93cy5sZW5ndGg+MCl7XHJcbiAgICAgICAgbGV0IHRlbXBBcnJheT1bXTtcclxuICAgICAgICAvLyBhY2NvdW50IGZvciBhIG5lZ2F0aXZlIHJvdyBudW1iZXIgKGAtMWApIG1lYW5pbmcgbGFzdCByb3dcclxuICAgICAgICBpZih0eXBlb2YgZXhjbHVkZVJvd3MgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgIGlmKHR5cGVvZiBleGNsdWRlUm93cyA9PSAnbnVtYmVyJyl7XHJcbiAgICAgICAgICAgIC8vIGZvciBub24tYmxvY2sgcm93cyBpbiBtdWx0aWRpbWVuc2lvbmFsXHJcbiAgICAgICAgICAgIGlmKGV4Y2x1ZGVSb3dzPDApeyAvLyBhY2NvdW50IGZvciBhIG5lZ2F0aXZlIGNvbHVtbiBudW1iZXIgKGUuZy5gLTFgKSBtZWFuaW5nIGxhc3QgY29sdW1uXHJcbiAgICAgICAgICAgICAgZXhjbHVkZVJvd3M9IHJvd3MubGVuZ3RoK2V4Y2x1ZGVSb3dzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvd3Muc3BsaWNlKGV4Y2x1ZGVSb3dzLDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShleGNsdWRlUm93cykpe1xyXG4gICAgICAgICAgICBleGNsdWRlUm93cy5zb3J0KChhLGIpPT57cmV0dXJuIGE+Yj8xOi0xfSkucmV2ZXJzZSgpOyAvL3NvcnQgdG8gc3BsaWNlIGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXlcclxuICAgICAgICAgICAgZXhjbHVkZVJvd3MuZm9yRWFjaChpPT57XHJcbiAgICAgICAgICAgICAgaWYoaT49MCl7XHJcbiAgICAgICAgICAgICAgICByb3dzLnNwbGljZShpLDEpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByb3dzLnNwbGljZShyb3dzLmxlbmd0aCtpLDEpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByb3dzLmZvckVhY2goKHJvdyxyb3dJbmRleCk9PntcclxuICAgICAgICAgIGlmKG11bHRpZGltZW5zaW9uYWwpe1xyXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBgdGVtcEFycmF5YCBpcyBub3QgZW1wdHkgYW5kIHB1c2ggaXQgdG8gdGhlIGBkYXRhYCBhcnJheSwgYmVjYXVzZSB3ZSd2ZSBlbmNvdW50ZXJlZCBhIG5ldyBibG9jaywgc28gdGhlIG9sZCBibG9jayBoYXMgdG8gYmUgcHVzaGVkIHRvIGRhdGEuIFRoZW4gd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgYmxvY2sgYXJyYXkgYW5kIHB1c2ggdGhlcmVcclxuICAgICAgICAgICAgaWYocm93LmNsYXNzTGlzdC5jb250YWlucygnZmlyc3RJbkJsb2NrJykpe1xyXG4gICAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkodGVtcEFycmF5KSAmJiB0ZW1wQXJyYXkubGVuZ3RoPjApe2RhdGEucHVzaCh0ZW1wQXJyYXkpO31cclxuICAgICAgICAgICAgICB0ZW1wQXJyYXkgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChkaXJlY3Rpb249PSdyb3cnICYmICFBcnJheS5pc0FycmF5KHRlbXBBcnJheVt0ZW1wQXJyYXkubGVuZ3RoXSkpIHsgLy8gaWYgYSByb3cgaW4gYW4gYXJyYXkgZG9lc24ndCBleGlzdCBjcmVhdGUgaXRcclxuICAgICAgICAgICAgdGVtcEFycmF5W3RlbXBBcnJheS5sZW5ndGhdID0gW107XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHdoaWNoIGNlbGxzIHRvIGV4Y2x1ZGVcclxuICAgICAgICAgIGxldCBjZWxscyA9IFtdLnNsaWNlLmNhbGwocm93LmNoaWxkcmVuKTtcclxuICAgICAgICAgIGxldCB0ZW1wX2V4Y2x1ZGVDb2x1bW5zID0gZXhjbHVkZUNvbHVtbnM7XHJcbiAgICAgICAgICBpZih0eXBlb2YgdGVtcF9leGNsdWRlQ29sdW1ucyAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBpZih0eXBlb2YgdGVtcF9leGNsdWRlQ29sdW1ucyA9PSAnbnVtYmVyJyl7XHJcbiAgICAgICAgICAgICAgLy8gZm9yIG5vbi1ibG9jayByb3dzIGluIG11bHRpZGltZW5zaW9uYWxcclxuICAgICAgICAgICAgICBpZihtdWx0aWRpbWVuc2lvbmFsICYmICFyb3cuY2xhc3NMaXN0LmNvbnRhaW5zKCdmaXJzdEluQmxvY2snKSAmJiAhdGVtcF9leGNsdWRlQ29sdW1uczwwKXtcclxuICAgICAgICAgICAgICAgIHRlbXBfZXhjbHVkZUNvbHVtbnM9dGVtcF9leGNsdWRlQ29sdW1ucysxO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZih0ZW1wX2V4Y2x1ZGVDb2x1bW5zPDApeyAvLyBhY2NvdW50IGZvciBhIG5lZ2F0aXZlIGNvbHVtbiBudW1iZXIgKGUuZy5gLTFgKSBtZWFuaW5nIGxhc3QgY29sdW1uXHJcbiAgICAgICAgICAgICAgICB0ZW1wX2V4Y2x1ZGVDb2x1bW5zPSBjZWxscy5sZW5ndGgrdGVtcF9leGNsdWRlQ29sdW1ucztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgY2VsbHMuc3BsaWNlKHRlbXBfZXhjbHVkZUNvbHVtbnMsMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheSh0ZW1wX2V4Y2x1ZGVDb2x1bW5zKSl7XHJcbiAgICAgICAgICAgICAgdGVtcF9leGNsdWRlQ29sdW1ucy5zb3J0KChhLGIpPT57cmV0dXJuIGE+Yj8xOi0xfSkucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICAgIHRlbXBfZXhjbHVkZUNvbHVtbnMuZm9yRWFjaChpPT57XHJcbiAgICAgICAgICAgICAgICBpZihpPj0wKXtcclxuICAgICAgICAgICAgICAgICAgY2VsbHMuc3BsaWNlKG11bHRpZGltZW5zaW9uYWwgJiYgIXJvdy5jbGFzc0xpc3QuY29udGFpbnMoJ2ZpcnN0SW5CbG9jaycpP2krMTppLDEpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgY2VsbHMuc3BsaWNlKGNlbGxzLmxlbmd0aCtpLDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY2VsbHMuZm9yRWFjaCgoY2VsbCwgaW5kZXgpID0+IHtcclxuXHJcbiAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gcnVuIHRoaXMgZXZlcnkgcm93IGJlY2F1c2UgbnVtYmVyIG9mIGNlbGxzIGluIGVhY2ggcm93IG1heSBkaWZmZXIgYW5kIHdlIHdhbnQgdG8gZXhjbHVkZSB0aGUgbGFzdCBvbmVcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkaXJlY3Rpb24gPT0gJ3N0cmluZycgJiYgZGlyZWN0aW9uID09ICdyb3cnKSB7IC8vaWYgd2Ugc3RyaXAgZGF0YSBob3Jpem9udGFsbHkgYnkgcm93XHJcbiAgICAgICAgICAgICAgaWYoIShtdWx0aWRpbWVuc2lvbmFsICYmIGV4Y2x1ZGVCbG9jayAmJiBjZWxsLnJvd1NwYW4+MSkpeyAvLyBpZiBpdCdzIGEgYmxvY2sgY2VsbCB3ZSdkIGV4Y2x1ZGUgaXQgZnJvbSBkYXRhXHJcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXlbdGVtcEFycmF5Lmxlbmd0aC0xXS5wdXNoKHRoaXMucHJlcGFyZURhdGFDZWxsKGNlbGwscm93SW5kZXgsaW5kZXgpKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRpcmVjdGlvbiA9PSAnc3RyaW5nJyAmJiBkaXJlY3Rpb24gPT0gJ2NvbHVtbicpIHsgLy9pZiB3ZSBzdHJpcCBkYXRhIHZlcnRpY2FsbHkgYnkgY29sdW1uXHJcbiAgICAgICAgICAgICAgbGV0IHJlYWxJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgIGlmKCEobXVsdGlkaW1lbnNpb25hbCAmJiBleGNsdWRlQmxvY2sgJiYgY2VsbC5yb3dTcGFuPjEpKXsgLy9leGNsdWRlIGJsb2NrIGNlbGxcclxuICAgICAgICAgICAgICAgIHJlYWxJbmRleCArPSAhcm93LmNsYXNzTGlzdC5jb250YWlucygnZmlyc3RJbkJsb2NrJyk/IDAgOiAtMTsgLy8gb2Zmc2V0IGNlbGwgdGhhdCBmb2xsb3dzIGJsb2NrIGNlbGwgb25lIHBvc2l0aW9uIGJhY2tcclxuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0ZW1wQXJyYXlbcmVhbEluZGV4XSkpIHsgLy9jcmVhdGUgY29sdW1uIGFycmF5IGZvciBjdXJyZW50IGNvbHVtbiBpZiBub3QgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgICAgICAgIHRlbXBBcnJheVtyZWFsSW5kZXhdID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXlbcmVhbEluZGV4XS5wdXNoKHRoaXMucHJlcGFyZURhdGFDZWxsKGNlbGwscm93SW5kZXgscmVhbEluZGV4KSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RpcmVjdGlvbiBoYXMgdG9iZSBhIFN0cmluZz09YHJvdyB8IGNvbHVtbmAsIG5vdCBhICR7ZGlyZWN0aW9ufScpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vd2UgbmVlZCB0byBwdXNoIHRoZSBsYXN0IGJsb2NrIEFycmF5IGJlY2F1c2UgdGhlcmUnbGwgYmUgbm8gYC5maXJzdEluQmxvY2tgIGFueW1vcmUgdG8gZG8gdGhhdFxyXG4gICAgICAgIGlmKG11bHRpZGltZW5zaW9uYWwgJiYgQXJyYXkuaXNBcnJheSh0ZW1wQXJyYXkpICYmIHRlbXBBcnJheS5sZW5ndGg+MCl7XHJcbiAgICAgICAgICBkYXRhLnB1c2godGVtcEFycmF5KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBkYXRhID0gdGVtcEFycmF5O1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRhYmxlIyR7c291cmNlLmlkfSdzIGJvZHkgbXVzdCBjb250YWluIHJvd3NgKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc291cmNlIG11c3QgYmUgZGVmaW5lZCBhbmQgYmUgYSB0YWJsZScpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGFibGVEYXRhXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vci1hZ2dyZWdhdGVkLXRhYmxlL3NyYy90YWJsZS1kYXRhLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 3 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Created by IvanP on 17.08.2016.\r\n */\n/**\r\n * @property {HTMLTableRowElement} row - reference to the `<tr>` element\r\n * @property {?String} id - internal Reportal id for the rowheader in the row\r\n * @property {!HTMLTableCellElement} nameCell - reference to the `<td>` element that contains the rowheader label/name\r\n * @property {String} [name=nameCell.textContent] - label of the rowheader.\r\n * @property {?Object} [block=null] - the block the row belongs to\r\n * @property {Boolean} firstInBlock - this `row` is first in the `block`, which means it contains the first cell as a block cell\r\n * */\nvar AggregatedTableRowMeta =\n/**\r\n * Builds a prototype for each row of an Aggregated Table\r\n * @param {HTMLTableRowElement} row - reference to the `<tr>` element\r\n * @param {?String} id - internal Reportal id for the rowheader in the row\r\n * @param {!HTMLTableCellElement} nameCell - reference to the `<td>` element that contains the rowheader label/name\r\n * @param {String=} [name=nameCell.textContent] - label of the rowheader.\r\n * @param {?Object} [block=null] - the block the row belongs to\r\n * */\nfunction AggregatedTableRowMeta() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      row = _ref.row,\n      _ref$id = _ref.id,\n      id = _ref$id === undefined ? null : _ref$id,\n      nameCell = _ref.nameCell,\n      name = _ref.name,\n      _ref$block = _ref.block,\n      block = _ref$block === undefined ? null : _ref$block;\n\n  _classCallCheck(this, AggregatedTableRowMeta);\n\n  /*** @property {HTMLTableRowElement} row - reference to the `<tr>` element*/\n  this.row = row;\n  this.id = id;\n  this.nameCell = nameCell;\n  this.name = name || nameCell.textContent.trim();\n  this.block = block;\n  this.firstInBlock = block != null && this.row.rowIndex === this.block.cell.parentNode.rowIndex;\n}\n/*get firstInBlock(){\r\n  return this._firstInBlock;\r\n}\r\nset firstInBlock(val){\r\n  this._firstInBlock = val;\r\n  val?this.row.classList.add('firstInBlock'):this.row.classList.remove('firstInBlock');\r\n}*/\n;\n\nexports.default = AggregatedTableRowMeta;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItYWdncmVnYXRlZC10YWJsZS9zcmMvYWdncmVnYXRlZC10YWJsZS1yb3ctbWV0YS5qcz80NmViIl0sIm5hbWVzIjpbIkFnZ3JlZ2F0ZWRUYWJsZVJvd01ldGEiLCJyb3ciLCJpZCIsIm5hbWVDZWxsIiwibmFtZSIsImJsb2NrIiwidGV4dENvbnRlbnQiLCJ0cmltIiwiZmlyc3RJbkJsb2NrIiwicm93SW5kZXgiLCJjZWxsIiwicGFyZW50Tm9kZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7O0FBR0E7Ozs7Ozs7O0lBUU1BLHNCO0FBQ0o7Ozs7Ozs7O0FBUUEsa0NBQTBEO0FBQUEsaUZBQUgsRUFBRztBQUFBLE1BQTdDQyxHQUE2QyxRQUE3Q0EsR0FBNkM7QUFBQSxxQkFBeENDLEVBQXdDO0FBQUEsTUFBeENBLEVBQXdDLDJCQUFyQyxJQUFxQztBQUFBLE1BQS9CQyxRQUErQixRQUEvQkEsUUFBK0I7QUFBQSxNQUFyQkMsSUFBcUIsUUFBckJBLElBQXFCO0FBQUEsd0JBQWZDLEtBQWU7QUFBQSxNQUFmQSxLQUFlLDhCQUFULElBQVM7O0FBQUE7O0FBQ3hEO0FBQ0EsT0FBS0osR0FBTCxHQUFXQSxHQUFYO0FBQ0EsT0FBS0MsRUFBTCxHQUFVQSxFQUFWO0FBQ0EsT0FBS0MsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxPQUFLQyxJQUFMLEdBQVlBLFFBQVFELFNBQVNHLFdBQVQsQ0FBcUJDLElBQXJCLEVBQXBCO0FBQ0EsT0FBS0YsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsT0FBS0csWUFBTCxHQUFvQkgsU0FBTyxJQUFQLElBQWUsS0FBS0osR0FBTCxDQUFTUSxRQUFULEtBQXNCLEtBQUtKLEtBQUwsQ0FBV0ssSUFBWCxDQUFnQkMsVUFBaEIsQ0FBMkJGLFFBQXBGO0FBQ0Q7QUFDRDs7Ozs7Ozs7O2tCQVFhVCxzQiIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENyZWF0ZWQgYnkgSXZhblAgb24gMTcuMDguMjAxNi5cclxuICovXHJcbi8qKlxyXG4gKiBAcHJvcGVydHkge0hUTUxUYWJsZVJvd0VsZW1lbnR9IHJvdyAtIHJlZmVyZW5jZSB0byB0aGUgYDx0cj5gIGVsZW1lbnRcclxuICogQHByb3BlcnR5IHs/U3RyaW5nfSBpZCAtIGludGVybmFsIFJlcG9ydGFsIGlkIGZvciB0aGUgcm93aGVhZGVyIGluIHRoZSByb3dcclxuICogQHByb3BlcnR5IHshSFRNTFRhYmxlQ2VsbEVsZW1lbnR9IG5hbWVDZWxsIC0gcmVmZXJlbmNlIHRvIHRoZSBgPHRkPmAgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSByb3doZWFkZXIgbGFiZWwvbmFtZVxyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW25hbWU9bmFtZUNlbGwudGV4dENvbnRlbnRdIC0gbGFiZWwgb2YgdGhlIHJvd2hlYWRlci5cclxuICogQHByb3BlcnR5IHs/T2JqZWN0fSBbYmxvY2s9bnVsbF0gLSB0aGUgYmxvY2sgdGhlIHJvdyBiZWxvbmdzIHRvXHJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZmlyc3RJbkJsb2NrIC0gdGhpcyBgcm93YCBpcyBmaXJzdCBpbiB0aGUgYGJsb2NrYCwgd2hpY2ggbWVhbnMgaXQgY29udGFpbnMgdGhlIGZpcnN0IGNlbGwgYXMgYSBibG9jayBjZWxsXHJcbiAqICovXHJcbmNsYXNzIEFnZ3JlZ2F0ZWRUYWJsZVJvd01ldGEge1xyXG4gIC8qKlxyXG4gICAqIEJ1aWxkcyBhIHByb3RvdHlwZSBmb3IgZWFjaCByb3cgb2YgYW4gQWdncmVnYXRlZCBUYWJsZVxyXG4gICAqIEBwYXJhbSB7SFRNTFRhYmxlUm93RWxlbWVudH0gcm93IC0gcmVmZXJlbmNlIHRvIHRoZSBgPHRyPmAgZWxlbWVudFxyXG4gICAqIEBwYXJhbSB7P1N0cmluZ30gaWQgLSBpbnRlcm5hbCBSZXBvcnRhbCBpZCBmb3IgdGhlIHJvd2hlYWRlciBpbiB0aGUgcm93XHJcbiAgICogQHBhcmFtIHshSFRNTFRhYmxlQ2VsbEVsZW1lbnR9IG5hbWVDZWxsIC0gcmVmZXJlbmNlIHRvIHRoZSBgPHRkPmAgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSByb3doZWFkZXIgbGFiZWwvbmFtZVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nPX0gW25hbWU9bmFtZUNlbGwudGV4dENvbnRlbnRdIC0gbGFiZWwgb2YgdGhlIHJvd2hlYWRlci5cclxuICAgKiBAcGFyYW0gez9PYmplY3R9IFtibG9jaz1udWxsXSAtIHRoZSBibG9jayB0aGUgcm93IGJlbG9uZ3MgdG9cclxuICAgKiAqL1xyXG4gIGNvbnN0cnVjdG9yKHtyb3csIGlkPW51bGwsIG5hbWVDZWxsLCBuYW1lLCBibG9jaz1udWxsfT17fSl7XHJcbiAgICAvKioqIEBwcm9wZXJ0eSB7SFRNTFRhYmxlUm93RWxlbWVudH0gcm93IC0gcmVmZXJlbmNlIHRvIHRoZSBgPHRyPmAgZWxlbWVudCovXHJcbiAgICB0aGlzLnJvdyA9IHJvdztcclxuICAgIHRoaXMuaWQgPSBpZDtcclxuICAgIHRoaXMubmFtZUNlbGwgPSBuYW1lQ2VsbDtcclxuICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgbmFtZUNlbGwudGV4dENvbnRlbnQudHJpbSgpO1xyXG4gICAgdGhpcy5ibG9jayA9IGJsb2NrO1xyXG4gICAgdGhpcy5maXJzdEluQmxvY2sgPSBibG9jayE9bnVsbCAmJiB0aGlzLnJvdy5yb3dJbmRleCA9PT0gdGhpcy5ibG9jay5jZWxsLnBhcmVudE5vZGUucm93SW5kZXg7XHJcbiAgfVxyXG4gIC8qZ2V0IGZpcnN0SW5CbG9jaygpe1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZpcnN0SW5CbG9jaztcclxuICB9XHJcbiAgc2V0IGZpcnN0SW5CbG9jayh2YWwpe1xyXG4gICAgdGhpcy5fZmlyc3RJbkJsb2NrID0gdmFsO1xyXG4gICAgdmFsP3RoaXMucm93LmNsYXNzTGlzdC5hZGQoJ2ZpcnN0SW5CbG9jaycpOnRoaXMucm93LmNsYXNzTGlzdC5yZW1vdmUoJ2ZpcnN0SW5CbG9jaycpO1xyXG4gIH0qL1xyXG59XHJcbmV4cG9ydCBkZWZhdWx0IEFnZ3JlZ2F0ZWRUYWJsZVJvd01ldGFcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yLWFnZ3JlZ2F0ZWQtdGFibGUvc3JjL2FnZ3JlZ2F0ZWQtdGFibGUtcm93LW1ldGEuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _tableData = __webpack_require__(2);\n\nvar _tableData2 = _interopRequireDefault(_tableData);\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nvar _rTableColumns = __webpack_require__(10);\n\nvar _rTableColumns2 = _interopRequireDefault(_rTableColumns);\n\nvar _sortTable = __webpack_require__(8);\n\nvar _sortTable2 = _interopRequireDefault(_sortTable);\n\nvar _tableFloatingHeader = __webpack_require__(12);\n\nvar _tableFloatingHeader2 = _interopRequireDefault(_tableFloatingHeader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by IvanP on 27.09.2016.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\nvar styles = __webpack_require__(16);\nvar aggregatedTableCSS = __webpack_require__(15);\n\n/**\r\n * A base class for aggregated tables. Multidimensional property of data is automatically calculated, thus removed from params.\r\n * @extends TableData\r\n * */\n\nvar AggregatedTable = function (_TableData) {\n  _inherits(AggregatedTable, _TableData);\n\n  /*\r\n   * @param {Object} options - options to configure the way data is stripped off the table\r\n   * @param {HTMLTableElement} options.source - source table that will be an input for data stripping\r\n   * @param {HTMLTableElement} [options.refSource] - a reference to a floating header, if any\r\n   * @param {Number} [options.rowheaderColumnIndex=0] - 0-based index of the column that we need to check against to see if it's a multidimentional table\r\n   * @param {Number|Object=} [options.defaultHeaderRow=-1] - index of the row in `thead` (incremented from 0) that will have sorting enabled for columns. If `-1` then last row.\r\n   * @param {String=} options.dataStripDirection='row' - direction in which data stripping will occur: `row` strips across rows and presents an array where each array item is an array of cell values. `column` strips values verticaly in a column, the resulting array will contain arrays (per column) with values resembling normalized data for cells in the column\r\n   * @param {Boolean=} [options.excludeBlock=true] - if table contains block cells that rowspan across several rows, we might need to exclude those from actual data\r\n   * @param {Array|Number} [options.excludeColumns] - if table contains columns that are not to be in data, then pass a single index or an array of cell indices (0-based). You need to count columns not by headers but by the cells in rows.\r\n   * @param {Array|Number} [options.excludeRows] - if table contains rows that are not to be in data, then pass a single index or an array of row indices (0-based). You need to count only rows that contain data, not the table-header rows.\r\n   * @param {SortTable} options.sorting - sorting options, see {@link SortTable}. If you want to leave all options default but enable sorting, pass an empty object(`.., sorting:{}`), or sorting won't be applied.\r\n   * @param {SortTable} options.floatingHeader - floating header, see {@link SortTable}. If you want to leave all options default but enable sorting, pass an empty object(`.., sorting:{}`), or sorting won't be applied.\r\n   * */\n  function AggregatedTable(options) {\n    _classCallCheck(this, AggregatedTable);\n\n    var source = options.source,\n        rowheaderColumnIndex = options.rowheaderColumnIndex,\n        defaultHeaderRow = options.defaultHeaderRow,\n        dataStripDirection = options.dataStripDirection,\n        excludeBlock = options.excludeBlock,\n        excludeColumns = options.excludeColumns,\n        excludeRows = options.excludeRows,\n        sorting = options.sorting,\n        floatingHeader = options.floatingHeader;\n\n    /**\r\n     *  The source table\r\n     *  @type {HTMLTableElement}\r\n     *  @memberOf AggregatedTable\r\n     *  */\n    var _this = _possibleConstructorReturn(this, (AggregatedTable.__proto__ || Object.getPrototypeOf(AggregatedTable)).call(this));\n\n    _this.source = source;\n    var refSource = void 0;\n    if (floatingHeader && (typeof floatingHeader === \"undefined\" ? \"undefined\" : _typeof(floatingHeader)) == 'object') {\n      _this.floatingHeader = new _tableFloatingHeader2.default(source);\n      /**\r\n       *  The floating header\r\n       *  @type {HTMLTableElement}\r\n       *  @memberOf AggregatedTable\r\n       *  */\n      _this.refSource = refSource = _this.floatingHeader.header;\n    }\n\n    /**\r\n     *  Whether data is monodimensional or multidimensional\r\n     *  @type {Boolean}\r\n     *  @memberOf AggregatedTable\r\n     *  */\n\n    _this.multidimensional = _this.constructor.detectMultidimensional(source);\n\n    /**\r\n     *  data Array\r\n     *  @type {Array.<{cell:HTMLTableCellElement, data:?String|?Number, columnIndex:Number}>}\r\n     *  @memberOf AggregatedTable\r\n     *  */\n    _this.data = _this.constructor.getData({ source: source, refSource: refSource, defaultHeaderRow: defaultHeaderRow, excludeBlock: excludeBlock, excludeColumns: excludeColumns, excludeRows: excludeRows, direction: dataStripDirection, multidimensional: _this.multidimensional });\n\n    if (sorting && (typeof sorting === \"undefined\" ? \"undefined\" : _typeof(sorting)) == 'object') {\n      (function () {\n        var reorderFunction = function reorderFunction(e) {\n          return _this.constructor.reorderRows(_this.data, _this.source, _this.multidimensional);\n        };\n        [source, refSource].forEach(function (target) {\n          if (target) {\n            target.addEventListener('reportal-table-sort', reorderFunction);\n          }\n        });\n\n        sorting.source = source;\n        sorting.refSource = refSource;\n        sorting.defaultHeaderRow = defaultHeaderRow;\n        sorting.data = _this.data;\n        sorting.multidimensional = _this.multidimensional;\n\n        /**\r\n         *  sorting object. See {@link SortTable}\r\n         *  @type {SortTable}\r\n         *  @memberOf AggregatedTable\r\n         *  */\n        _this.sorting = new _sortTable2.default(sorting);\n\n        // add listener to do reordering on sorting\n      })();\n    }\n\n    /**\r\n     * table columns array\r\n     * @type {Array.<{index:Number, title:String, colSpan:Number, cell: HTMLTableCellElement, ?refCell:HTMLTableCellElement}>}\r\n     * @memberOf AggregatedTable\r\n     * */\n    _this.columns = _this.sorting && _this.sorting.columns ? _this.sorting.columns : new _rTableColumns2.default({ source: source, refSource: refSource, defaultHeaderRow: defaultHeaderRow });\n    return _this;\n  }\n\n  /**\r\n   * Extracts data from a given cell. Override in an inherited class if you need to add any metadata to it.\r\n   * @param {HTMLTableCellElement} cell - cell element to have data stripped off it\r\n   * @param {HTMLTableCellElement} rowIndex - index of the row it's in\r\n   * @param {HTMLTableCellElement} columnIndex - index of the column it's in\r\n   * @returns {{cell:HTMLTableCellElement, ?data:String|Number, columnIndex:Number}} Returns an object `{cell:HTMLTableCellElement, data:?String|?Number, columnIndex:Number}` (if data is absent in the cell or its text content boils down to an empty string - i.e. there are no characters in the cell, only HTML tags) it returns null in `data`\r\n   * @override\r\n   * */\n\n\n  _createClass(AggregatedTable, null, [{\n    key: \"prepareDataCell\",\n    value: function prepareDataCell(cell, rowIndex, columnIndex) {\n      return {\n        cell: cell,\n        data: _rReportalBase2.default.isNumber(cell.textContent.trim()),\n        columnIndex: columnIndex,\n        rowIndex: rowIndex\n      };\n    }\n\n    /**\r\n     * This function takes care of repositioning rows in the table to match the `data` array in the way it was sorted and if the data is separated into blocks, then move the block piece to the first row in each data block.\r\n     * @param {Array} data - full sorted dataset. Instance of {@link TableData#getData}\r\n     * @param {HTMLTableElement} source - source table\r\n     * @param {Boolean} multidimensional\r\n     * */\n\n  }, {\n    key: \"reorderRows\",\n    value: function reorderRows(data, source, multidimensional) {\n      var fragment = document.createDocumentFragment();\n      AggregatedTable.dimensionalDataIterator(data, multidimensional, function (dataDimension) {\n        if (multidimensional) {\n          AggregatedTable.repositionBlockCell(dataDimension);\n        } // if multidimensional reposition aggregating block cell to the topmost row in sorted array\n        dataDimension.forEach(function (item) {\n          fragment.appendChild(item[0].cell.parentNode);\n        }); // add row to fragment in the array order, this doesn't account for column stripped data yet\n      });\n      source.querySelector('tbody').appendChild(fragment);\n    }\n\n    /*\r\n     * Repositions the rowspanning block cell from the initial row to the new sorted row\r\n     * @param {Array} items - dimension of data\r\n     * */\n\n  }, {\n    key: \"repositionBlockCell\",\n    value: function repositionBlockCell(items) {\n      var blockRowItem = items.filter(function (item) {\n        return item[0].cell.parentNode.classList.contains('firstInBlock');\n      })[0];\n      var blockRow = blockRowItem[0].cell.parentNode;\n      if (items.indexOf(blockRowItem) != 0) {\n        // if block row isn't first in dimension\n        var newFirstRow = items[0][0].cell.parentNode;\n        newFirstRow.insertBefore(blockRow.querySelector('.blockCell'), newFirstRow.firstElementChild); // move block cell\n        newFirstRow.classList.add('firstInBlock');\n        blockRow.classList.remove('firstInBlock');\n      }\n    }\n\n    /**\r\n     * allows to perform action on data based on its multidimensionality\r\n     * @param {Array} data - full dataset. Instance of {@link TableData#getData}\r\n     * @param {Boolean} multidimensional\r\n     * @param {!Function} callback - a function to be executed on a dimension of data. Callback is called with two attributes: `dimension` - the current iteration of data and `index` (optional) if it's multidimensional\r\n     * */\n\n  }, {\n    key: \"dimensionalDataIterator\",\n    value: function dimensionalDataIterator(data, multidimensional, callback) {\n      if (!callback || typeof callback != 'function') {\n        throw new TypeError('`callback` must be passed and be a function');\n      }\n      if (!multidimensional) {\n        return callback(data);\n      } else {\n        // if array has nested array blocks\n        data.forEach(function (dimension, index) {\n          callback(dimension, index);\n        });\n      }\n    }\n  }]);\n\n  return AggregatedTable;\n}(_tableData2.default);\n\nexports.default = AggregatedTable;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItYWdncmVnYXRlZC10YWJsZS9zcmMvYWdncmVnYXRlZC10YWJsZS5qcz8zMDBiIl0sIm5hbWVzIjpbInN0eWxlcyIsInJlcXVpcmUiLCJhZ2dyZWdhdGVkVGFibGVDU1MiLCJBZ2dyZWdhdGVkVGFibGUiLCJvcHRpb25zIiwic291cmNlIiwicm93aGVhZGVyQ29sdW1uSW5kZXgiLCJkZWZhdWx0SGVhZGVyUm93IiwiZGF0YVN0cmlwRGlyZWN0aW9uIiwiZXhjbHVkZUJsb2NrIiwiZXhjbHVkZUNvbHVtbnMiLCJleGNsdWRlUm93cyIsInNvcnRpbmciLCJmbG9hdGluZ0hlYWRlciIsInJlZlNvdXJjZSIsImhlYWRlciIsIm11bHRpZGltZW5zaW9uYWwiLCJjb25zdHJ1Y3RvciIsImRldGVjdE11bHRpZGltZW5zaW9uYWwiLCJkYXRhIiwiZ2V0RGF0YSIsImRpcmVjdGlvbiIsInJlb3JkZXJGdW5jdGlvbiIsInJlb3JkZXJSb3dzIiwiZm9yRWFjaCIsInRhcmdldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJjb2x1bW5zIiwiY2VsbCIsInJvd0luZGV4IiwiY29sdW1uSW5kZXgiLCJpc051bWJlciIsInRleHRDb250ZW50IiwidHJpbSIsImZyYWdtZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiZGltZW5zaW9uYWxEYXRhSXRlcmF0b3IiLCJkYXRhRGltZW5zaW9uIiwicmVwb3NpdGlvbkJsb2NrQ2VsbCIsImFwcGVuZENoaWxkIiwiaXRlbSIsInBhcmVudE5vZGUiLCJxdWVyeVNlbGVjdG9yIiwiaXRlbXMiLCJibG9ja1Jvd0l0ZW0iLCJmaWx0ZXIiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImJsb2NrUm93IiwiaW5kZXhPZiIsIm5ld0ZpcnN0Um93IiwiaW5zZXJ0QmVmb3JlIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJhZGQiLCJyZW1vdmUiLCJjYWxsYmFjayIsIlR5cGVFcnJvciIsImRpbWVuc2lvbiIs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LE1BQU1NLE9BQU4sQ0FBY0wsWUFBZCxLQUE2QixDQUFoQyxFQUFrQztBQUFDO0FBQ2pDLFlBQUlNLGNBQWNQLE1BQU0sQ0FBTixFQUFTLENBQVQsRUFBWWhCLElBQVosQ0FBaUJjLFVBQW5DO0FBQ0FTLG9CQUFZQyxZQUFaLENBQXlCSCxTQUFTTixhQUFULENBQXVCLFlBQXZCLENBQXpCLEVBQThEUSxZQUFZRSxpQkFBMUUsRUFGZ0MsQ0FFNkQ7QUFDN0ZGLG9CQUFZSixTQUFaLENBQXNCTyxHQUF0QixDQUEwQixjQUExQjtBQUNBTCxpQkFBU0YsU0FBVCxDQUFtQlEsTUFBbkIsQ0FBMEIsY0FBMUI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7NENBTStCcEMsSSxFQUFLSCxnQixFQUFpQndDLFEsRUFBUztBQUM1RCxVQUFHLENBQUNBLFFBQUQsSUFBYSxPQUFPQSxRQUFQLElBQW1CLFVBQW5DLEVBQThDO0FBQUMsY0FBTSxJQUFJQyxTQUFKLENBQWMsNkNBQWQsQ0FBTjtBQUFtRTtBQUNsSCxVQUFHLENBQUN6QyxnQkFBSixFQUFxQjtBQUNuQixlQUFPd0MsU0FBU3JDLElBQVQsQ0FBUDtBQUNELE9BRkQsTUFFTztBQUFFO0FBQ1BBLGFBQUtLLE9BQUwsQ0FBYSxVQUFDa0MsU0FBRCxFQUFXQyxLQUFYLEVBQW1CO0FBQzlCSCxtQkFBU0UsU0FBVCxFQUFtQkMsS0FBbkI7QUFDRCxTQUZEO0FBR0Q7QUFDRjs7Ozs7O2tCQUtZeEQsZSIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENyZWF0ZWQgYnkgSXZhblAgb24gMjcuMDkuMjAxNi5cclxuICovXHJcblxyXG5pbXBvcnQgVGFibGVEYXRhIGZyb20gJy4vdGFibGUtZGF0YSc7XHJcbmltcG9ydCBSZXBvcnRhbEJhc2UgZnJvbSBcInItcmVwb3J0YWwtYmFzZVwiO1xyXG5pbXBvcnQgVGFibGVDb2x1bW5zIGZyb20gXCJyLXRhYmxlLWNvbHVtbnNcIjtcclxuaW1wb3J0IFNvcnRUYWJsZSBmcm9tIFwici1zb3J0LXRhYmxlL3NyYy9zb3J0LXRhYmxlXCI7XHJcbmltcG9ydCBUYWJsZUZsb2F0aW5nSGVhZGVyIGZyb20gXCJyLXRhYmxlLWZsb2F0aW5nLWhlYWRlci9zcmMvdGFibGUtZmxvYXRpbmctaGVhZGVyXCI7XHJcblxyXG5sZXQgc3R5bGVzID0gcmVxdWlyZSgnci1zb3J0LXRhYmxlL3NyYy9zb3J0LXRhYmxlLXN0eWxlcy5jc3MnKTtcclxubGV0IGFnZ3JlZ2F0ZWRUYWJsZUNTUyA9IHJlcXVpcmUoJy4vYWdncmVnYXRlZC10YWJsZS5jc3MnKTtcclxuXHJcbi8qKlxyXG4gKiBBIGJhc2UgY2xhc3MgZm9yIGFnZ3JlZ2F0ZWQgdGFibGVzLiBNdWx0aWRpbWVuc2lvbmFsIHByb3BlcnR5IG9mIGRhdGEgaXMgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkLCB0aHVzIHJlbW92ZWQgZnJvbSBwYXJhbXMuXHJcbiAqIEBleHRlbmRzIFRhYmxlRGF0YVxyXG4gKiAqL1xyXG5jbGFzcyBBZ2dyZWdhdGVkVGFibGUgZXh0ZW5kcyBUYWJsZURhdGEge1xyXG4gIC8qXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgd2F5IGRhdGEgaXMgc3RyaXBwZWQgb2ZmIHRoZSB0YWJsZVxyXG4gICAqIEBwYXJhbSB7SFRNTFRhYmxlRWxlbWVudH0gb3B0aW9ucy5zb3VyY2UgLSBzb3VyY2UgdGFibGUgdGhhdCB3aWxsIGJlIGFuIGlucHV0IGZvciBkYXRhIHN0cmlwcGluZ1xyXG4gICAqIEBwYXJhbSB7SFRNTFRhYmxlRWxlbWVudH0gW29wdGlvbnMucmVmU291cmNlXSAtIGEgcmVmZXJlbmNlIHRvIGEgZmxvYXRpbmcgaGVhZGVyLCBpZiBhbnlcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucm93aGVhZGVyQ29sdW1uSW5kZXg9MF0gLSAwLWJhc2VkIGluZGV4IG9mIHRoZSBjb2x1bW4gdGhhdCB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QgdG8gc2VlIGlmIGl0J3MgYSBtdWx0aWRpbWVudGlvbmFsIHRhYmxlXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0PX0gW29wdGlvbnMuZGVmYXVsdEhlYWRlclJvdz0tMV0gLSBpbmRleCBvZiB0aGUgcm93IGluIGB0aGVhZGAgKGluY3JlbWVudGVkIGZyb20gMCkgdGhhdCB3aWxsIGhhdmUgc29ydGluZyBlbmFibGVkIGZvciBjb2x1bW5zLiBJZiBgLTFgIHRoZW4gbGFzdCByb3cuXHJcbiAgICogQHBhcmFtIHtTdHJpbmc9fSBvcHRpb25zLmRhdGFTdHJpcERpcmVjdGlvbj0ncm93JyAtIGRpcmVjdGlvbiBpbiB3aGljaCBkYXRhIHN0cmlwcGluZyB3aWxsIG9jY3VyOiBgcm93YCBzdHJpcHMgYWNyb3NzIHJvd3MgYW5kIHByZXNlbnRzIGFuIGFycmF5IHdoZXJlIGVhY2ggYXJyYXkgaXRlbSBpcyBhbiBhcnJheSBvZiBjZWxsIHZhbHVlcy4gYGNvbHVtbmAgc3RyaXBzIHZhbHVlcyB2ZXJ0aWNhbHkgaW4gYSBjb2x1bW4sIHRoZSByZXN1bHRpbmcgYXJyYXkgd2lsbCBjb250YWluIGFycmF5cyAocGVyIGNvbHVtbikgd2l0aCB2YWx1ZXMgcmVzZW1ibGluZyBub3JtYWxpemVkIGRhdGEgZm9yIGNlbGxzIGluIHRoZSBjb2x1bW5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBbb3B0aW9ucy5leGNsdWRlQmxvY2s9dHJ1ZV0gLSBpZiB0YWJsZSBjb250YWlucyBibG9jayBjZWxscyB0aGF0IHJvd3NwYW4gYWNyb3NzIHNldmVyYWwgcm93cywgd2UgbWlnaHQgbmVlZCB0byBleGNsdWRlIHRob3NlIGZyb20gYWN0dWFsIGRhdGFcclxuICAgKiBAcGFyYW0ge0FycmF5fE51bWJlcn0gW29wdGlvbnMuZXhjbHVkZUNvbHVtbnNdIC0gaWYgdGFibGUgY29udGFpbnMgY29sdW1ucyB0aGF0IGFyZSBub3QgdG8gYmUgaW4gZGF0YSwgdGhlbiBwYXNzIGEgc2luZ2xlIGluZGV4IG9yIGFuIGFycmF5IG9mIGNlbGwgaW5kaWNlcyAoMC1iYXNlZCkuIFlvdSBuZWVkIHRvIGNvdW50IGNvbHVtbnMgbm90IGJ5IGhlYWRlcnMgYnV0IGJ5IHRoZSBjZWxscyBpbiByb3dzLlxyXG4gICAqIEBwYXJhbSB7QXJyYXl8TnVtYmVyfSBbb3B0aW9ucy5leGNsdWRlUm93c10gLSBpZiB0YWJsZSBjb250YWlucyByb3dzIHRoYXQgYXJlIG5vdCB0byBiZSBpbiBkYXRhLCB0aGVuIHBhc3MgYSBzaW5nbGUgaW5kZXggb3IgYW4gYXJyYXkgb2Ygcm93IGluZGljZXMgKDAtYmFzZWQpLiBZb3UgbmVlZCB0byBjb3VudCBvbmx5IHJvd3MgdGhhdCBjb250YWluIGRhdGEsIG5vdCB0aGUgdGFibGUtaGVhZGVyIHJvd3MuXHJcbiAgICogQHBhcmFtIHtTb3J0VGFibGV9IG9wdGlvbnMuc29ydGluZyAtIHNvcnRpbmcgb3B0aW9ucywgc2VlIHtAbGluayBTb3J0VGFibGV9LiBJZiB5b3Ugd2FudCB0byBsZWF2ZSBhbGwgb3B0aW9ucyBkZWZhdWx0IGJ1dCBlbmFibGUgc29ydGluZywgcGFzcyBhbiBlbXB0eSBvYmplY3QoYC4uLCBzb3J0aW5nOnt9YCksIG9yIHNvcnRpbmcgd29uJ3QgYmUgYXBwbGllZC5cclxuICAgKiBAcGFyYW0ge1NvcnRUYWJsZX0gb3B0aW9ucy5mbG9hdGluZ0hlYWRlciAtIGZsb2F0aW5nIGhlYWRlciwgc2VlIHtAbGluayBTb3J0VGFibGV9LiBJZiB5b3Ugd2FudCB0byBsZWF2ZSBhbGwgb3B0aW9ucyBkZWZhdWx0IGJ1dCBlbmFibGUgc29ydGluZywgcGFzcyBhbiBlbXB0eSBvYmplY3QoYC4uLCBzb3J0aW5nOnt9YCksIG9yIHNvcnRpbmcgd29uJ3QgYmUgYXBwbGllZC5cclxuICAgKiAqL1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpe1xyXG4gICAgbGV0IHtcclxuICAgICAgc291cmNlLFxyXG4gICAgICByb3doZWFkZXJDb2x1bW5JbmRleCxkZWZhdWx0SGVhZGVyUm93LGRhdGFTdHJpcERpcmVjdGlvbixleGNsdWRlQmxvY2ssZXhjbHVkZUNvbHVtbnMsZXhjbHVkZVJvd3MsXHJcbiAgICAgIHNvcnRpbmcsXHJcbiAgICAgIGZsb2F0aW5nSGVhZGVyXHJcbiAgICB9ID0gb3B0aW9ucztcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHNvdXJjZSB0YWJsZVxyXG4gICAgICogIEB0eXBlIHtIVE1MVGFibGVFbGVtZW50fVxyXG4gICAgICogIEBtZW1iZXJPZiBBZ2dyZWdhdGVkVGFibGVcclxuICAgICAqICAqL1xyXG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICBsZXQgcmVmU291cmNlO1xyXG4gICAgaWYoZmxvYXRpbmdIZWFkZXIgJiYgdHlwZW9mIGZsb2F0aW5nSGVhZGVyPT0nb2JqZWN0Jyl7XHJcbiAgICAgIHRoaXMuZmxvYXRpbmdIZWFkZXIgPSBuZXcgVGFibGVGbG9hdGluZ0hlYWRlcihzb3VyY2UpO1xyXG4gICAgICAvKipcclxuICAgICAgICogIFRoZSBmbG9hdGluZyBoZWFkZXJcclxuICAgICAgICogIEB0eXBlIHtIVE1MVGFibGVFbGVtZW50fVxyXG4gICAgICAgKiAgQG1lbWJlck9mIEFnZ3JlZ2F0ZWRUYWJsZVxyXG4gICAgICAgKiAgKi9cclxuICAgICAgdGhpcy5yZWZTb3VyY2UgPSByZWZTb3VyY2UgPSB0aGlzLmZsb2F0aW5nSGVhZGVyLmhlYWRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqICBXaGV0aGVyIGRhdGEgaXMgbW9ub2RpbWVuc2lvbmFsIG9yIG11bHRpZGltZW5zaW9uYWxcclxuICAgICAqICBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqICBAbWVtYmVyT2YgQWdncmVnYXRlZFRhYmxlXHJcbiAgICAgKiAgKi9cclxuXHJcbiAgICB0aGlzLm11bHRpZGltZW5zaW9uYWwgPSB0aGlzLmNvbnN0cnVjdG9yLmRldGVjdE11bHRpZGltZW5zaW9uYWwoc291cmNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqICBkYXRhIEFycmF5XHJcbiAgICAgKiAgQHR5cGUge0FycmF5Ljx7Y2VsbDpIVE1MVGFibGVDZWxsRWxlbWVudCwgZGF0YTo/U3RyaW5nfD9OdW1iZXIsIGNvbHVtbkluZGV4Ok51bWJlcn0+fVxyXG4gICAgICogIEBtZW1iZXJPZiBBZ2dyZWdhdGVkVGFibGVcclxuICAgICAqICAqL1xyXG4gICAgdGhpcy5kYXRhID0gdGhpcy5jb25zdHJ1Y3Rvci5nZXREYXRhKHtzb3VyY2UscmVmU291cmNlLGRlZmF1bHRIZWFkZXJSb3csZXhjbHVkZUJsb2NrLGV4Y2x1ZGVDb2x1bW5zLGV4Y2x1ZGVSb3dzLGRpcmVjdGlvbjpkYXRhU3RyaXBEaXJlY3Rpb24sbXVsdGlkaW1lbnNpb25hbDogdGhpcy5tdWx0aWRpbWVuc2lvbmFsfSk7XHJcblxyXG5cclxuICAgIGlmKHNvcnRpbmcgJiYgdHlwZW9mIHNvcnRpbmcgPT0gJ29iamVjdCcpe1xyXG4gICAgICBsZXQgcmVvcmRlckZ1bmN0aW9uID0gZT0+e1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnJlb3JkZXJSb3dzKHRoaXMuZGF0YSx0aGlzLnNvdXJjZSx0aGlzLm11bHRpZGltZW5zaW9uYWwpXHJcbiAgICAgIH07XHJcbiAgICAgIFtzb3VyY2UscmVmU291cmNlXS5mb3JFYWNoKHRhcmdldD0+e1xyXG4gICAgICAgIGlmKHRhcmdldCl7XHJcbiAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigncmVwb3J0YWwtdGFibGUtc29ydCcsIHJlb3JkZXJGdW5jdGlvbilcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgc29ydGluZy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgIHNvcnRpbmcucmVmU291cmNlID0gcmVmU291cmNlO1xyXG4gICAgICBzb3J0aW5nLmRlZmF1bHRIZWFkZXJSb3cgPSBkZWZhdWx0SGVhZGVyUm93O1xyXG4gICAgICBzb3J0aW5nLmRhdGE9dGhpcy5kYXRhO1xyXG4gICAgICBzb3J0aW5nLm11bHRpZGltZW5zaW9uYWwgPSB0aGlzLm11bHRpZGltZW5zaW9uYWw7XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogIHNvcnRpbmcgb2JqZWN0LiBTZWUge0BsaW5rIFNvcnRUYWJsZX1cclxuICAgICAgICogIEB0eXBlIHtTb3J0VGFibGV9XHJcbiAgICAgICAqICBAbWVtYmVyT2YgQWdncmVnYXRlZFRhYmxlXHJcbiAgICAgICAqICAqL1xyXG4gICAgICB0aGlzLnNvcnRpbmcgPSBuZXcgU29ydFRhYmxlKHNvcnRpbmcpO1xyXG5cclxuICAgICAgLy8gYWRkIGxpc3RlbmVyIHRvIGRvIHJlb3JkZXJpbmcgb24gc29ydGluZ1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGFibGUgY29sdW1ucyBhcnJheVxyXG4gICAgICogQHR5cGUge0FycmF5Ljx7aW5kZXg6TnVtYmVyLCB0aXRsZTpTdHJpbmcsIGNvbFNwYW46TnVtYmVyLCBjZWxsOiBIVE1MVGFibGVDZWxsRWxlbWVudCwgP3JlZkNlbGw6SFRNTFRhYmxlQ2VsbEVsZW1lbnR9Pn1cclxuICAgICAqIEBtZW1iZXJPZiBBZ2dyZWdhdGVkVGFibGVcclxuICAgICAqICovXHJcbiAgICB0aGlzLmNvbHVtbnMgPSB0aGlzLnNvcnRpbmcgJiYgdGhpcy5zb3J0aW5nLmNvbHVtbnM/IHRoaXMuc29ydGluZy5jb2x1bW5zIDogbmV3IFRhYmxlQ29sdW1ucyh7c291cmNlLHJlZlNvdXJjZSxkZWZhdWx0SGVhZGVyUm93fSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogRXh0cmFjdHMgZGF0YSBmcm9tIGEgZ2l2ZW4gY2VsbC4gT3ZlcnJpZGUgaW4gYW4gaW5oZXJpdGVkIGNsYXNzIGlmIHlvdSBuZWVkIHRvIGFkZCBhbnkgbWV0YWRhdGEgdG8gaXQuXHJcbiAgICogQHBhcmFtIHtIVE1MVGFibGVDZWxsRWxlbWVudH0gY2VsbCAtIGNlbGwgZWxlbWVudCB0byBoYXZlIGRhdGEgc3RyaXBwZWQgb2ZmIGl0XHJcbiAgICogQHBhcmFtIHtIVE1MVGFibGVDZWxsRWxlbWVudH0gcm93SW5kZXggLSBpbmRleCBvZiB0aGUgcm93IGl0J3MgaW5cclxuICAgKiBAcGFyYW0ge0hUTUxUYWJsZUNlbGxFbGVtZW50fSBjb2x1bW5JbmRleCAtIGluZGV4IG9mIHRoZSBjb2x1bW4gaXQncyBpblxyXG4gICAqIEByZXR1cm5zIHt7Y2VsbDpIVE1MVGFibGVDZWxsRWxlbWVudCwgP2RhdGE6U3RyaW5nfE51bWJlciwgY29sdW1uSW5kZXg6TnVtYmVyfX0gUmV0dXJucyBhbiBvYmplY3QgYHtjZWxsOkhUTUxUYWJsZUNlbGxFbGVtZW50LCBkYXRhOj9TdHJpbmd8P051bWJlciwgY29sdW1uSW5kZXg6TnVtYmVyfWAgKGlmIGRhdGEgaXMgYWJzZW50IGluIHRoZSBjZWxsIG9yIGl0cyB0ZXh0IGNvbnRlbnQgYm9pbHMgZG93biB0byBhbiBlbXB0eSBzdHJpbmcgLSBpLmUuIHRoZXJlIGFyZSBubyBjaGFyYWN0ZXJzIGluIHRoZSBjZWxsLCBvbmx5IEhUTUwgdGFncykgaXQgcmV0dXJucyBudWxsIGluIGBkYXRhYFxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqICovXHJcbiAgc3RhdGljIHByZXBhcmVEYXRhQ2VsbChjZWxsLCByb3dJbmRleCwgY29sdW1uSW5kZXgpe1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2VsbCxcclxuICAgICAgZGF0YTogUmVwb3J0YWxCYXNlLmlzTnVtYmVyKGNlbGwudGV4dENvbnRlbnQudHJpbSgpKSxcclxuICAgICAgY29sdW1uSW5kZXgsXHJcbiAgICAgIHJvd0luZGV4XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGNhcmUgb2YgcmVwb3NpdGlvbmluZyByb3dzIGluIHRoZSB0YWJsZSB0byBtYXRjaCB0aGUgYGRhdGFgIGFycmF5IGluIHRoZSB3YXkgaXQgd2FzIHNvcnRlZCBhbmQgaWYgdGhlIGRhdGEgaXMgc2VwYXJhdGVkIGludG8gYmxvY2tzLCB0aGVuIG1vdmUgdGhlIGJsb2NrIHBpZWNlIHRvIHRoZSBmaXJzdCByb3cgaW4gZWFjaCBkYXRhIGJsb2NrLlxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgLSBmdWxsIHNvcnRlZCBkYXRhc2V0LiBJbnN0YW5jZSBvZiB7QGxpbmsgVGFibGVEYXRhI2dldERhdGF9XHJcbiAgICogQHBhcmFtIHtIVE1MVGFibGVFbGVtZW50fSBzb3VyY2UgLSBzb3VyY2UgdGFibGVcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG11bHRpZGltZW5zaW9uYWxcclxuICAgKiAqL1xyXG4gIHN0YXRpYyByZW9yZGVyUm93cyhkYXRhLHNvdXJjZSxtdWx0aWRpbWVuc2lvbmFsKXtcclxuICAgIGxldCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgIEFnZ3JlZ2F0ZWRUYWJsZS5kaW1lbnNpb25hbERhdGFJdGVyYXRvcihkYXRhLG11bHRpZGltZW5zaW9uYWwsKGRhdGFEaW1lbnNpb24pPT57XHJcbiAgICAgIGlmKG11bHRpZGltZW5zaW9uYWwpe0FnZ3JlZ2F0ZWRUYWJsZS5yZXBvc2l0aW9uQmxvY2tDZWxsKGRhdGFEaW1lbnNpb24pfSAvLyBpZiBtdWx0aWRpbWVuc2lvbmFsIHJlcG9zaXRpb24gYWdncmVnYXRpbmcgYmxvY2sgY2VsbCB0byB0aGUgdG9wbW9zdCByb3cgaW4gc29ydGVkIGFycmF5XHJcbiAgICAgIGRhdGFEaW1lbnNpb24uZm9yRWFjaChpdGVtPT57ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoaXRlbVswXS5jZWxsLnBhcmVudE5vZGUpfSk7IC8vIGFkZCByb3cgdG8gZnJhZ21lbnQgaW4gdGhlIGFycmF5IG9yZGVyLCB0aGlzIGRvZXNuJ3QgYWNjb3VudCBmb3IgY29sdW1uIHN0cmlwcGVkIGRhdGEgeWV0XHJcbiAgICB9KTtcclxuICAgIHNvdXJjZS5xdWVyeVNlbGVjdG9yKCd0Ym9keScpLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcclxuICB9XHJcblxyXG4gIC8qXHJcbiAgICogUmVwb3NpdGlvbnMgdGhlIHJvd3NwYW5uaW5nIGJsb2NrIGNlbGwgZnJvbSB0aGUgaW5pdGlhbCByb3cgdG8gdGhlIG5ldyBzb3J0ZWQgcm93XHJcbiAgICogQHBhcmFtIHtBcnJheX0gaXRlbXMgLSBkaW1lbnNpb24gb2YgZGF0YVxyXG4gICAqICovXHJcbiAgc3RhdGljIHJlcG9zaXRpb25CbG9ja0NlbGwoaXRlbXMpe1xyXG4gICAgbGV0IGJsb2NrUm93SXRlbSA9IGl0ZW1zLmZpbHRlcihpdGVtPT5pdGVtWzBdLmNlbGwucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2ZpcnN0SW5CbG9jaycpKVswXTtcclxuICAgIGxldCBibG9ja1JvdyA9IGJsb2NrUm93SXRlbVswXS5jZWxsLnBhcmVudE5vZGU7XHJcbiAgICBpZihpdGVtcy5pbmRleE9mKGJsb2NrUm93SXRlbSkhPTApey8vIGlmIGJsb2NrIHJvdyBpc24ndCBmaXJzdCBpbiBkaW1lbnNpb25cclxuICAgICAgbGV0IG5ld0ZpcnN0Um93ID0gaXRlbXNbMF1bMF0uY2VsbC5wYXJlbnROb2RlO1xyXG4gICAgICBuZXdGaXJzdFJvdy5pbnNlcnRCZWZvcmUoYmxvY2tSb3cucXVlcnlTZWxlY3RvcignLmJsb2NrQ2VsbCcpLG5ld0ZpcnN0Um93LmZpcnN0RWxlbWVudENoaWxkKTsvLyBtb3ZlIGJsb2NrIGNlbGxcclxuICAgICAgbmV3Rmlyc3RSb3cuY2xhc3NMaXN0LmFkZCgnZmlyc3RJbkJsb2NrJyk7XHJcbiAgICAgIGJsb2NrUm93LmNsYXNzTGlzdC5yZW1vdmUoJ2ZpcnN0SW5CbG9jaycpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogYWxsb3dzIHRvIHBlcmZvcm0gYWN0aW9uIG9uIGRhdGEgYmFzZWQgb24gaXRzIG11bHRpZGltZW5zaW9uYWxpdHlcclxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIC0gZnVsbCBkYXRhc2V0LiBJbnN0YW5jZSBvZiB7QGxpbmsgVGFibGVEYXRhI2dldERhdGF9XHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBtdWx0aWRpbWVuc2lvbmFsXHJcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGNhbGxiYWNrIC0gYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbiBhIGRpbWVuc2lvbiBvZiBkYXRhLiBDYWxsYmFjayBpcyBjYWxsZWQgd2l0aCB0d28gYXR0cmlidXRlczogYGRpbWVuc2lvbmAgLSB0aGUgY3VycmVudCBpdGVyYXRpb24gb2YgZGF0YSBhbmQgYGluZGV4YCAob3B0aW9uYWwpIGlmIGl0J3MgbXVsdGlkaW1lbnNpb25hbFxyXG4gICAqICovXHJcbiAgc3RhdGljIGRpbWVuc2lvbmFsRGF0YUl0ZXJhdG9yKGRhdGEsbXVsdGlkaW1lbnNpb25hbCxjYWxsYmFjayl7XHJcbiAgICBpZighY2FsbGJhY2sgfHwgdHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ2BjYWxsYmFja2AgbXVzdCBiZSBwYXNzZWQgYW5kIGJlIGEgZnVuY3Rpb24nKX1cclxuICAgIGlmKCFtdWx0aWRpbWVuc2lvbmFsKXtcclxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGRhdGEpXHJcbiAgICB9IGVsc2UgeyAvLyBpZiBhcnJheSBoYXMgbmVzdGVkIGFycmF5IGJsb2Nrc1xyXG4gICAgICBkYXRhLmZvckVhY2goKGRpbWVuc2lvbixpbmRleCk9PntcclxuICAgICAgICBjYWxsYmFjayhkaW1lbnNpb24saW5kZXgpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQWdncmVnYXRlZFRhYmxlXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vci1hZ2dyZWdhdGVkLXRhYmxlL3NyYy9hZ2dyZWdhdGVkLXRhYmxlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _tableData = __webpack_require__(2);\n\nvar _tableData2 = _interopRequireDefault(_tableData);\n\nvar _aggregatedTable = __webpack_require__(4);\n\nvar _aggregatedTable2 = _interopRequireDefault(_aggregatedTable);\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nvar _aggregatedTableRowMeta = __webpack_require__(3);\n\nvar _aggregatedTableRowMeta2 = _interopRequireDefault(_aggregatedTableRowMeta);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\r\n * Created by IvanP on 07.09.2016.\r\n */\n\nwindow.Reportal = window.Reportal || {};\n_rReportalBase2.default.mixin(window.Reportal, {\n  TableData: _tableData2.default,\n  AggregatedTable: _aggregatedTable2.default,\n  AggregatedTableRowMeta: _aggregatedTableRowMeta2.default\n});\n\nexports.default = _aggregatedTable2.default;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItYWdncmVnYXRlZC10YWJsZS9zcmMvbWFpbi5qcz85Nzg2Il0sIm5hbWVzIjpbIndpbmRvdyIsIlJlcG9ydGFsIiwibWl4aW4iLCJUYWJsZURhdGEiLCJBZ2dyZWdhdGVkVGFibGUiLCJBZ2dyZWdhdGVkVGFibGVSb3dNZXRhIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFJQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBUEE7Ozs7QUFVQUEsT0FBT0MsUUFBUCxHQUFrQkQsT0FBT0MsUUFBUCxJQUFtQixFQUFyQztBQUNBLHdCQUFhQyxLQUFiLENBQW1CRixPQUFPQyxRQUExQixFQUFtQztBQUNqQ0UsZ0NBRGlDO0FBRWpDQyw0Q0FGaUM7QUFHakNDO0FBSGlDLENBQW5DIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ3JlYXRlZCBieSBJdmFuUCBvbiAwNy4wOS4yMDE2LlxyXG4gKi9cclxuXHJcbmltcG9ydCBUYWJsZURhdGEgZnJvbSBcIi4vdGFibGUtZGF0YVwiO1xyXG5pbXBvcnQgQWdncmVnYXRlZFRhYmxlIGZyb20gXCIuL2FnZ3JlZ2F0ZWQtdGFibGVcIjtcclxuaW1wb3J0IFJlcG9ydGFsQmFzZSBmcm9tIFwici1yZXBvcnRhbC1iYXNlXCI7XHJcbmltcG9ydCBBZ2dyZWdhdGVkVGFibGVSb3dNZXRhIGZyb20gXCIuL2FnZ3JlZ2F0ZWQtdGFibGUtcm93LW1ldGFcIjtcclxuXHJcblxyXG53aW5kb3cuUmVwb3J0YWwgPSB3aW5kb3cuUmVwb3J0YWwgfHwge307XHJcblJlcG9ydGFsQmFzZS5taXhpbih3aW5kb3cuUmVwb3J0YWwse1xyXG4gIFRhYmxlRGF0YSxcclxuICBBZ2dyZWdhdGVkVGFibGUsXHJcbiAgQWdncmVnYXRlZFRhYmxlUm93TWV0YVxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFnZ3JlZ2F0ZWRUYWJsZVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3ItYWdncmVnYXRlZC10YWJsZS9zcmMvbWFpbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by IvanP on 15.12.2016.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * A class that provides utility static methods to load children of a level of hiererachy and a table per a given id\r\n * */\nvar AsyncHierarchyTable = function () {\n  function AsyncHierarchyTable() {\n    _classCallCheck(this, AsyncHierarchyTable);\n  }\n\n  _createClass(AsyncHierarchyTable, null, [{\n    key: 'fetchChildHierarchy',\n\n    /**\r\n     * Queries if each row might contain child rows by quering hierarchy for next level\r\n     * @param {!String} id - rowheader id for current row\r\n     * @param {!Number} hierarchyID - id of Hierarchy in Table Designer\r\n     * @param {!String} hierarchyControlID - id of the Reportal Hierarchy Component instance on the page\r\n     * @param {!String} pageStateID - Reportal state id\r\n     * @param {Number=} languageCode=9 - Language code (according to Confirmit table of language codes) of the language the hierarchy is going to be streamed in at the page load\r\n     * @returns {Array} array of child nodes of the `id` in hierarchy\r\n     * */\n    value: function fetchChildHierarchy(id, hierarchyID, hierarchyControlID, pageStateID) {\n      var languageCode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 9;\n\n      var path = [location.origin, 'reportal', 'Hierarchy', _rReportalBase2.default.getQueryVariable('ReportId'), hierarchyID, languageCode, 'GetChildNodes'];\n\n      var query = ['nodeId=' + id, 'info=' + AsyncHierarchyTable.encode({\n        IsPreview: _rReportalBase2.default.getQueryVariable('Preview') === 'true',\n        HierarchyControlId: hierarchyControlID\n      }), 'isRepBase=false', 'parameter=', 'PageStateId=' + pageStateID];\n\n      var hierarchyItemChildren = _rReportalBase2.default.promiseRequest([path.join('/'), '?', query.join('&')].join(''));\n      return hierarchyItemChildren.then(function (response) {\n        return Promise.resolve(JSON.parse(response));\n      });\n    }\n\n    /**\r\n     * Gets row nodes that are child to the parent row#`id`\r\n     * @param {!String} id - rowheader id for current row\r\n     * @param {?String} parentID - rowheader id for parent row\r\n     * @param {!String} tableID - Reportal Aggregated Table Component id\r\n     * @param {!String} pageStateID - Reportal state id\r\n     * @return {Promise} Returns a thenable promise which result is an `HTMLTableElement` with rows that are children to the row#`id`\r\n     * */\n\n  }, {\n    key: 'fetchChildTable',\n    value: function fetchChildTable(id, parentID, tableID, pageStateID) {\n      parentID = parentID != null ? parentID : id;\n      var path = [location.origin, 'reportal', 'Report', _rReportalBase2.default.getQueryVariable('ReportId'), 'Component', tableID];\n      var query = ['PageId=' + _rReportalBase2.default.getQueryVariable('PageId'), 'Preview=' + _rReportalBase2.default.getQueryVariable('Preview'), 'PageStateId=' + pageStateID, 'pageFilters=' + AsyncHierarchyTable.encode({}), 'customFilters=' + AsyncHierarchyTable.encode({}), 'persNodes=' + AsyncHierarchyTable.encode([{ NodeId: id, Text: null }]), // child node id\n      'origNodes=' + AsyncHierarchyTable.encode([{ NodeId: parentID, Text: null }]) // parent node id\n      ];\n      var tableResult = _rReportalBase2.default.promiseRequest([path.join('/'), '?', query.join('&')].join(''));\n      return tableResult.then(function (response) {\n        var host = document.createElement('span');\n        host.innerHTML = response;\n        return Promise.resolve(host.querySelector('table'));\n      });\n    }\n\n    /**\r\n     * Strips rows from the table received\r\n     * @param {HTMLTableElement} table - Aggregated table element\r\n     * @param {Array} excludedRows - rows excluded from insertion\r\n     * @return {Array} Returns an array of rows {HTMLTableRowElement}\r\n     * */\n\n  }, {\n    key: 'stripRowsFromResponseTable',\n    value: function stripRowsFromResponseTable(table, excludedRows) {\n      var rows = [].slice.call(table.querySelectorAll('tbody>tr'));\n      if (excludedRows && excludedRows.length > 0) {\n        excludedRows.reverse().forEach(function (index) {\n          rows.splice(index, 1);\n        });\n      }\n      return rows;\n    }\n\n    /**\r\n     * Does `JSON.stringify` and `encodeURIComponent` of anything passed to be added to the query string\r\n     * @param {String|Object|Array} toEncode - piece to be URLencoded\r\n     * @returns {String} Returns an encoded string\r\n     * */\n\n  }, {\n    key: 'encode',\n    value: function encode(toEncode) {\n      return encodeURIComponent(JSON.stringify(toEncode));\n    }\n  }]);\n\n  return AsyncHierarchyTable;\n}();\n\nexports.default = AsyncHierarchyTable;\n\n\nwindow.Reportal = window.Reportal || {};\n_rReportalBase2.default.mixin(window.Reportal, {\n  AsyncHierarchyTable: AsyncHierarchyTable\n});\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItYXN5bmMtaGllcmFyY2h5LXRhYmxlL3NyYy9tYWluLmpzPzNiNzUiXSwibmFtZXMiOlsiQXN5bmNIaWVyYXJjaHlUYWJsZSIsImlkIiwiaGllcmFyY2h5SUQiLCJoaWVyYXJjaHlDb250cm9sSUQiLCJwYWdlU3RhdGVJRCIsImxhbmd1YWdlQ29kZSIsInBhdGgiLCJsb2NhdGlvbiIsIm9yaWdpbiIsImdldFF1ZXJ5VmFyaWFibGUiLCJxdWVyeSIsImVuY29kZSIsIklzUHJldmlldyIsIkhpZXJhcmNoeUNvbnRyb2xJZCIsImhpZXJhcmNoeUl0ZW1DaGlsZHJlbiIsInByb21pc2VSZXF1ZXN0Iiwiam9pbiIsInRoZW4iLCJQcm9taXNlIiwicmVzb2x2ZSIsIkpTT04iLCJwYXJzZSIsInJlc3BvbnNlIiwicGFyZW50SUQiLCJ0YWJsZUlEIiwiTm9kZUlkIiwiVGV4dCIsInRhYmxlUmVzdWx0IiwiaG9zdCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsInF1ZXJ5U2VsZWN0b3IiLCJ0YWJsZSIsImV4Y2x1ZGVkUm93cyIsInJvd3MiLCJzbGljZSIsImNhbGwiLCJxdWVyeVNlbGVjdG9yQWxsIiwibGVuZ3RoIiwicmV2ZXJzZSIsImZvckVhY2giLCJzcGxpY2UiLCJpbmRleCIsInRvRW5jb2RlIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic3RyaW5naWZ5Iiwid2luZG93IiwiUmVwb3J0YWwiLCJtaXhpbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O3FqQkFBQTs7Ozs7QUFHQTs7Ozs7Ozs7QUFFQTs7O0lBR01BLG1COzs7Ozs7OztBQUNKOzs7Ozs7Ozs7d0NBUzJCQyxFLEVBQUdDLFcsRUFBWUMsa0IsRUFBbUJDLFcsRUFBMkI7QUFBQSxVQUFmQyxZQUFlLHVFQUFGLENBQUU7O0FBQ3RGLFVBQUlDLE9BQU8sQ0FDVEMsU0FBU0MsTUFEQSxFQUVULFVBRlMsRUFHVCxXQUhTLEVBSVQsd0JBQWFDLGdCQUFiLENBQThC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RDs7Ozs7O2tCQUlZNUMsbUI7OztBQUdmK0MsT0FBT0MsUUFBUCxHQUFrQkQsT0FBT0MsUUFBUCxJQUFtQixFQUFyQztBQUNBLHdCQUFhQyxLQUFiLENBQW1CRixPQUFPQyxRQUExQixFQUFtQztBQUNqQ2hEO0FBRGlDLENBQW5DIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ3JlYXRlZCBieSBJdmFuUCBvbiAxNS4xMi4yMDE2LlxyXG4gKi9cclxuaW1wb3J0IFJlcG9ydGFsQmFzZSBmcm9tIFwici1yZXBvcnRhbC1iYXNlXCI7XHJcblxyXG4vKipcclxuICogQSBjbGFzcyB0aGF0IHByb3ZpZGVzIHV0aWxpdHkgc3RhdGljIG1ldGhvZHMgdG8gbG9hZCBjaGlsZHJlbiBvZiBhIGxldmVsIG9mIGhpZXJlcmFjaHkgYW5kIGEgdGFibGUgcGVyIGEgZ2l2ZW4gaWRcclxuICogKi9cclxuY2xhc3MgQXN5bmNIaWVyYXJjaHlUYWJsZXtcclxuICAvKipcclxuICAgKiBRdWVyaWVzIGlmIGVhY2ggcm93IG1pZ2h0IGNvbnRhaW4gY2hpbGQgcm93cyBieSBxdWVyaW5nIGhpZXJhcmNoeSBmb3IgbmV4dCBsZXZlbFxyXG4gICAqIEBwYXJhbSB7IVN0cmluZ30gaWQgLSByb3doZWFkZXIgaWQgZm9yIGN1cnJlbnQgcm93XHJcbiAgICogQHBhcmFtIHshTnVtYmVyfSBoaWVyYXJjaHlJRCAtIGlkIG9mIEhpZXJhcmNoeSBpbiBUYWJsZSBEZXNpZ25lclxyXG4gICAqIEBwYXJhbSB7IVN0cmluZ30gaGllcmFyY2h5Q29udHJvbElEIC0gaWQgb2YgdGhlIFJlcG9ydGFsIEhpZXJhcmNoeSBDb21wb25lbnQgaW5zdGFuY2Ugb24gdGhlIHBhZ2VcclxuICAgKiBAcGFyYW0geyFTdHJpbmd9IHBhZ2VTdGF0ZUlEIC0gUmVwb3J0YWwgc3RhdGUgaWRcclxuICAgKiBAcGFyYW0ge051bWJlcj19IGxhbmd1YWdlQ29kZT05IC0gTGFuZ3VhZ2UgY29kZSAoYWNjb3JkaW5nIHRvIENvbmZpcm1pdCB0YWJsZSBvZiBsYW5ndWFnZSBjb2Rlcykgb2YgdGhlIGxhbmd1YWdlIHRoZSBoaWVyYXJjaHkgaXMgZ29pbmcgdG8gYmUgc3RyZWFtZWQgaW4gYXQgdGhlIHBhZ2UgbG9hZFxyXG4gICAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXkgb2YgY2hpbGQgbm9kZXMgb2YgdGhlIGBpZGAgaW4gaGllcmFyY2h5XHJcbiAgICogKi9cclxuICBzdGF0aWMgZmV0Y2hDaGlsZEhpZXJhcmNoeShpZCxoaWVyYXJjaHlJRCxoaWVyYXJjaHlDb250cm9sSUQscGFnZVN0YXRlSUQsbGFuZ3VhZ2VDb2RlPTkpe1xyXG4gICAgbGV0IHBhdGggPSBbXHJcbiAgICAgIGxvY2F0aW9uLm9yaWdpbixcclxuICAgICAgJ3JlcG9ydGFsJyxcclxuICAgICAgJ0hpZXJhcmNoeScsXHJcbiAgICAgIFJlcG9ydGFsQmFzZS5nZXRRdWVyeVZhcmlhYmxlKCdSZXBvcnRJZCcpLFxyXG4gICAgICBoaWVyYXJjaHlJRCxcclxuICAgICAgbGFuZ3VhZ2VDb2RlLFxyXG4gICAgICAnR2V0Q2hpbGROb2RlcydcclxuICAgIF07XHJcblxyXG4gICAgbGV0IHF1ZXJ5PVtcclxuICAgICAgYG5vZGVJZD0ke2lkfWAsXHJcbiAgICAgIGBpbmZvPSR7QXN5bmNIaWVyYXJjaHlUYWJsZS5lbmNvZGUoe1xyXG4gICAgICAgIElzUHJldmlldzpSZXBvcnRhbEJhc2UuZ2V0UXVlcnlWYXJpYWJsZSgnUHJldmlldycpPT09J3RydWUnLFxyXG4gICAgICAgIEhpZXJhcmNoeUNvbnRyb2xJZDpoaWVyYXJjaHlDb250cm9sSURcclxuICAgICAgfSl9YCxcclxuICAgICAgJ2lzUmVwQmFzZT1mYWxzZScsXHJcbiAgICAgICdwYXJhbWV0ZXI9JyxcclxuICAgICAgYFBhZ2VTdGF0ZUlkPSR7cGFnZVN0YXRlSUR9YFxyXG4gICAgXTtcclxuXHJcbiAgICBsZXQgaGllcmFyY2h5SXRlbUNoaWxkcmVuID0gUmVwb3J0YWxCYXNlLnByb21pc2VSZXF1ZXN0KFtwYXRoLmpvaW4oJy8nKSwnPycscXVlcnkuam9pbignJicpXS5qb2luKCcnKSk7XHJcbiAgICByZXR1cm4gaGllcmFyY2h5SXRlbUNoaWxkcmVuLnRoZW4ocmVzcG9uc2U9PntyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEpTT04ucGFyc2UocmVzcG9uc2UpKX0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyByb3cgbm9kZXMgdGhhdCBhcmUgY2hpbGQgdG8gdGhlIHBhcmVudCByb3cjYGlkYFxyXG4gICAqIEBwYXJhbSB7IVN0cmluZ30gaWQgLSByb3doZWFkZXIgaWQgZm9yIGN1cnJlbnQgcm93XHJcbiAgICogQHBhcmFtIHs/U3RyaW5nfSBwYXJlbnRJRCAtIHJvd2hlYWRlciBpZCBmb3IgcGFyZW50IHJvd1xyXG4gICAqIEBwYXJhbSB7IVN0cmluZ30gdGFibGVJRCAtIFJlcG9ydGFsIEFnZ3JlZ2F0ZWQgVGFibGUgQ29tcG9uZW50IGlkXHJcbiAgICogQHBhcmFtIHshU3RyaW5nfSBwYWdlU3RhdGVJRCAtIFJlcG9ydGFsIHN0YXRlIGlkXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmV0dXJucyBhIHRoZW5hYmxlIHByb21pc2Ugd2hpY2ggcmVzdWx0IGlzIGFuIGBIVE1MVGFibGVFbGVtZW50YCB3aXRoIHJvd3MgdGhhdCBhcmUgY2hpbGRyZW4gdG8gdGhlIHJvdyNgaWRgXHJcbiAgICogKi9cclxuICBzdGF0aWMgZmV0Y2hDaGlsZFRhYmxlKGlkLCBwYXJlbnRJRCwgdGFibGVJRCxwYWdlU3RhdGVJRCl7XHJcbiAgICBwYXJlbnRJRCA9IHBhcmVudElEIT1udWxsP3BhcmVudElEOmlkO1xyXG4gICAgbGV0IHBhdGggPSBbXHJcbiAgICAgIGxvY2F0aW9uLm9yaWdpbixcclxuICAgICAgJ3JlcG9ydGFsJyxcclxuICAgICAgJ1JlcG9ydCcsXHJcbiAgICAgIFJlcG9ydGFsQmFzZS5nZXRRdWVyeVZhcmlhYmxlKCdSZXBvcnRJZCcpLFxyXG4gICAgICAnQ29tcG9uZW50JyxcclxuICAgICAgdGFibGVJRFxyXG4gICAgXTtcclxuICAgIGxldCBxdWVyeT1bXHJcbiAgICAgIGBQYWdlSWQ9JHtSZXBvcnRhbEJhc2UuZ2V0UXVlcnlWYXJpYWJsZSgnUGFnZUlkJyl9YCxcclxuICAgICAgYFByZXZpZXc9JHtSZXBvcnRhbEJhc2UuZ2V0UXVlcnlWYXJpYWJsZSgnUHJldmlldycpfWAsXHJcbiAgICAgIGBQYWdlU3RhdGVJZD0ke3BhZ2VTdGF0ZUlEfWAsXHJcbiAgICAgIGBwYWdlRmlsdGVycz0ke0FzeW5jSGllcmFyY2h5VGFibGUuZW5jb2RlKHt9KX1gLFxyXG4gICAgICBgY3VzdG9tRmlsdGVycz0ke0FzeW5jSGllcmFyY2h5VGFibGUuZW5jb2RlKHt9KX1gLFxyXG4gICAgICBgcGVyc05vZGVzPSR7QXN5bmNIaWVyYXJjaHlUYWJsZS5lbmNvZGUoW3tOb2RlSWQ6aWQsVGV4dDpudWxsfV0pfWAsIC8vIGNoaWxkIG5vZGUgaWRcclxuICAgICAgYG9yaWdOb2Rlcz0ke0FzeW5jSGllcmFyY2h5VGFibGUuZW5jb2RlKFt7Tm9kZUlkOnBhcmVudElELFRleHQ6bnVsbH1dKX1gIC8vIHBhcmVudCBub2RlIGlkXHJcbiAgICBdO1xyXG4gICAgbGV0IHRhYmxlUmVzdWx0ID0gUmVwb3J0YWxCYXNlLnByb21pc2VSZXF1ZXN0KFtwYXRoLmpvaW4oJy8nKSwnPycscXVlcnkuam9pbignJicpXS5qb2luKCcnKSk7XHJcbiAgICByZXR1cm4gdGFibGVSZXN1bHQudGhlbihyZXNwb25zZT0+e1xyXG4gICAgICBsZXQgaG9zdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICAgICAgaG9zdC5pbm5lckhUTUwgPSByZXNwb25zZTtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShob3N0LnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJykpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdHJpcHMgcm93cyBmcm9tIHRoZSB0YWJsZSByZWNlaXZlZFxyXG4gICAqIEBwYXJhbSB7SFRNTFRhYmxlRWxlbWVudH0gdGFibGUgLSBBZ2dyZWdhdGVkIHRhYmxlIGVsZW1lbnRcclxuICAgKiBAcGFyYW0ge0FycmF5fSBleGNsdWRlZFJvd3MgLSByb3dzIGV4Y2x1ZGVkIGZyb20gaW5zZXJ0aW9uXHJcbiAgICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2Ygcm93cyB7SFRNTFRhYmxlUm93RWxlbWVudH1cclxuICAgKiAqL1xyXG4gIHN0YXRpYyBzdHJpcFJvd3NGcm9tUmVzcG9uc2VUYWJsZSh0YWJsZSxleGNsdWRlZFJvd3Mpe1xyXG4gICAgbGV0IHJvd3MgPSBbXS5zbGljZS5jYWxsKHRhYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3Rib2R5PnRyJykpO1xyXG4gICAgaWYoZXhjbHVkZWRSb3dzICYmIGV4Y2x1ZGVkUm93cy5sZW5ndGg+MCl7XHJcbiAgICAgIGV4Y2x1ZGVkUm93cy5yZXZlcnNlKCkuZm9yRWFjaChpbmRleD0+e1xyXG4gICAgICAgIHJvd3Muc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcm93cztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERvZXMgYEpTT04uc3RyaW5naWZ5YCBhbmQgYGVuY29kZVVSSUNvbXBvbmVudGAgb2YgYW55dGhpbmcgcGFzc2VkIHRvIGJlIGFkZGVkIHRvIHRoZSBxdWVyeSBzdHJpbmdcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8QXJyYXl9IHRvRW5jb2RlIC0gcGllY2UgdG8gYmUgVVJMZW5jb2RlZFxyXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFJldHVybnMgYW4gZW5jb2RlZCBzdHJpbmdcclxuICAgKiAqL1xyXG4gIHN0YXRpYyBlbmNvZGUodG9FbmNvZGUpe1xyXG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh0b0VuY29kZSkpO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFzeW5jSGllcmFyY2h5VGFibGU7XHJcblxyXG5cclxud2luZG93LlJlcG9ydGFsID0gd2luZG93LlJlcG9ydGFsIHx8IHt9O1xyXG5SZXBvcnRhbEJhc2UubWl4aW4od2luZG93LlJlcG9ydGFsLHtcclxuICBBc3luY0hpZXJhcmNoeVRhYmxlXHJcbn0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3ItYXN5bmMtaGllcmFyY2h5LXRhYmxlL3NyYy9tYWluLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 7 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SortOrder = function () {\n  /**\r\n   * Creates a `sortOrder` array\r\n   * @param {Object} options - configuration options\r\n   * @param {Object} options.columns - an array of columns from {@link TableColumns}\r\n   * @param {Function} options.sortCallback - function that performs sorting based on the `sortOrder`\r\n   * @param {Object} options.sortCallbackScope - scope in which sort callback needs to be executed\r\n   * @param {Object} [options.defaultSorting] - an array of objects that specify default sorting\r\n   * @param {Number} options.defaultSorting.column - column index\r\n   * @param {String} options.defaultSorting.direction - sort direction (`asc`|`desc`)\r\n   * @return {Array}\r\n   * */\n  function SortOrder(options) {\n    var _this = this;\n\n    _classCallCheck(this, SortOrder);\n\n    var columns = options.columns,\n        sortCallback = options.sortCallback,\n        _options$defaultSorti = options.defaultSorting,\n        defaultSorting = _options$defaultSorti === undefined ? [] : _options$defaultSorti,\n        _options$sortCallback = options.sortCallbackScope,\n        sortCallbackScope = _options$sortCallback === undefined ? this : _options$sortCallback;\n\n\n    this.sortOrder = [];\n    if ((typeof columns === 'undefined' ? 'undefined' : _typeof(columns)) != undefined && columns != null) {\n      this.columns = columns;\n    } else {\n      throw new TypeError('SortOrder: columns must be specified');\n    }\n    this.sort = function () {\n      if (sortCallback && typeof sortCallback === 'function') {\n        sortCallback.call(sortCallbackScope, _this);\n      }\n    };\n    if (defaultSorting.length > 0) {\n      defaultSorting.forEach(function (item) {\n        return _this.add(item);\n      });\n      this.sort();\n    }\n  }\n\n  /**\r\n   * Returns an array containing a `cell` from the table and a reference cell (`refCell`) from the floating header if any\r\n   * @param {!Number} columnIndex - index of the column from the array of columns from {@link TableColumns}\r\n   * @return {{cell:HTMLTableCellElement, refCell:HTMLTableCellElement}}\r\n   * */\n\n\n  _createClass(SortOrder, [{\n    key: 'getCell',\n    value: function getCell(columnIndex) {\n      if (typeof columnIndex != 'undefined' && columnIndex != null) {\n        var cells = [];\n        if (this.columns[columnIndex].cell) {\n          cells.push(this.columns[columnIndex].cell);\n        }\n        if (this.columns[columnIndex].refCell) {\n          cells.push(this.columns[columnIndex].refCell);\n        }\n        return cells;\n      } else {\n        throw new TypeError('columnIndex parameter should not be null');\n      }\n    }\n\n    /**\r\n     * Adds another column to be sorted\r\n     * @param {!Object} obj - object describing sorting\r\n     * @param {Number} obj.column - column index\r\n     * @param {String} obj.direction - sort direction (`asc`|`desc`)\r\n     * */\n\n  }, {\n    key: 'add',\n    value: function add(obj) {\n      this.getCell(obj.column).forEach(function (cell) {\n        //if(!cell.classList.contains('sorted')){ // this column is not sorted, there might be others that are.\n        ['sorted', obj.direction].forEach(function (className) {\n          return cell.classList.add(className);\n        });\n        //} else { //swaps sorting from asc to desc\n        //  ['asc','desc'].forEach(className=>cell.classList.toggle(className));\n        //}\n      });\n      this.sortOrder.push(obj);\n    }\n\n    /**\r\n     * Removes a column from `sortOrder`\r\n     * @param {Number} column - column index as reference to the item to be removed.\r\n     * @param {Number} index - index of item in `sortOrder` array to be removed\r\n     * */\n\n  }, {\n    key: 'remove',\n    value: function remove(column, index) {\n      var _this2 = this;\n\n      ['sorted', 'asc', 'desc'].forEach(function (className) {\n        _this2.getCell(column).forEach(function (cell) {\n          return cell.classList.remove(className);\n        });\n      });\n      this.sortOrder.splice(index, 1);\n    }\n  }, {\n    key: 'replace',\n\n\n    /**\r\n     * Replaces all items in `sortOrder`\r\n     * @param {!Object} obj - object describing sorting\r\n     * @param {Number} obj.column - column index\r\n     * @param {String} obj.direction - sort direction (`asc`|`desc`)\r\n     * */\n    value: function replace(obj) {\n      var _this3 = this;\n\n      if (this.sortOrder.length > 0) {\n        this.sortOrder.forEach(function (item, index) {\n          _this3.remove(item.column, index);\n        });\n      }\n      this.add(obj);\n      this.sort();\n    }\n  }]);\n\n  return SortOrder;\n}();\n\nexports.default = SortOrder;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Itc29ydC10YWJsZS9zcmMvc29ydC1vcmRlci5qcz8xMGIzIl0sIm5hbWVzIjpbIlNvcnRPcmRlciIsIm9wdGlvbnMiLCJjb2x1bW5zIiwic29ydENhbGxiYWNrIiwiZGVmYXVsdFNvcnRpbmciLCJzb3J0Q2FsbGJhY2tTY29wZSIsInNvcnRPcmRlciIsInVuZGVmaW5lZCIsIlR5cGVFcnJvciIsInNvcnQiLCJjYWxsIiwibGVuZ3RoIiwiZm9yRWFjaCIsImFkZCIsIml0ZW0iLCJjb2x1bW5JbmRleCIsImNlbGxzIiwiY2VsbCIsInB1c2giLCJyZWZDZWxsIiwib2JqIiwiZ2V0Q2VsbCIsImNvbHVtbiIsImRpcmVjdGlvbiIsImNsYXNzTGlzdCIsImNsYXNzTmFtZSIsImluZGV4IiwicmVtb3ZlIiwic3BsaWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFBTUEsUztBQUNKOzs7Ozs7Ozs7OztBQVdBLHFCQUFZQyxPQUFaLEVBQW9CO0FBQUE7O0FBQUE7O0FBQUEsUUFDYkMsT0FEYSxHQUN1REQsT0FEdkQsQ0FDYkMsT0FEYTtBQUFBLFFBQ0pDLFlBREksR0FDdURGLE9BRHZELENBQ0pFLFlBREk7QUFBQSxnQ0FDdURGLE9BRHZELENBQ1VHLGNBRFY7QUFBQSxRQUNVQSxjQURWLHlDQUN5QixFQUR6QjtBQUFBLGdDQUN1REgsT0FEdkQsQ0FDNkJJLGlCQUQ3QjtBQUFBLFFBQzZCQSxpQkFEN0IseUNBQytDLElBRC9DOzs7QUFHbEIsU0FBS0MsU0FBTCxHQUFpQixFQUFqQjtBQUNBLFFBQUcsUUFBT0osT0FBUCx5Q0FBT0EsT0FBUCxNQUFrQkssU0FBbEIsSUFBK0JMLFdBQVcsSUFBN0MsRUFBa0Q7QUFDaEQsV0FBS0EsT0FBTCxHQUFlQSxPQUFmO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsWUFBTSxJQUFJTSxTQUFKLENBQWMsc0NBQWQsQ0FBTjtBQUNEO0FBQ0QsU0FBS0MsSUFBTCxHQUFZLFlBQUk7QUFDZCxVQUFHTixnQkFBZ0IsT0FBT0EsWUFBUCxLQUF3QixVQUEzQyxFQUFzRDtBQUNwREEscUJBQWFPLElBQWIsQ0FBa0JMLGlCQUFsQjtBQUNEO0FBQ0YsS0FKRDtBQUtBLFFBQUdELGVBQWVPLE1BQWYsR0FBc0IsQ0FBekIsRUFBMkI7QUFDekJQLHFCQUFlUSxPQUFmLENBQXVCO0FBQUEsZUFBTSxNQUFLQyxHQUFMLENBQVNDLElBQVQsQ0FBTjtBQUFBLE9BQXZCO0FBQ0EsV0FBS0wsSUFBTDtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs0QkFLUU0sVyxFQUFZO0FBQ2xCLFVBQUcsT0FBT0EsV0FBUCxJQUFzQixXQUF0QixJQUFxQ0EsZUFBYSxJQUFyRCxFQUEwRDtBQUN4RCxZQUFJQyxRQUFRLEVBQVo7QUFDQSxZQUFHLEtBQUtkLE9BQUwsQ0FBYWEsV0FBYixFQUEwQkUsSUFBN0IsRUFBa0M7QUFBQ0QsZ0JBQU1FLElBQU4sQ0FBVyxLQUFLaEIsT0FBTCxDQUFhYSxXQUFiLEVBQTBCRSxJQUFyQztBQUEyQztBQUM5RSxZQUFHLEtBQUtmLE9BQUwsQ0FBYWEsV0FBYixFQUEwQkksT0FBN0IsRUFBcUM7QUFBQ0gsZ0JBQU1FLElBQU4sQ0FBVyxLQUFLaEIsT0FBTCxDQUFhYSxXQUFiLEVBQTBCSSxPQUFyQztBQUE4QztBQUNwRixlQUFPSCxLQUFQO0FBQ0QsT0FMRCxNQUtPO0FBQ0wsY0FBTSxJQUFJUixTQUFKLENBQWMsMENBQWQsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozt3QkFPS1ksRyxFQUFJO0FBQ1AsV0FBS0MsT0FBTCxDQUFhRCxJQUFJRSxNQUFqQixFQUF5QlYsT0FBekIsQ0FBaUMsZ0JBQU07QUFDckM7QUFDRSxTQUFDLFFBQUQsRUFBVVEsSUFBSUcsU0FBZCxFQUF5QlgsT0FBekIsQ0FBaUM7QUFBQSxpQkFBV0ssS0FBS08sU0FBTCxDQUFlWCxHQUFmLENBQW1CWSxTQUFuQixDQUFYO0FBQUEsU0FBakM7QUFDRjtBQUNBO0FBQ0E7QUFDRCxPQU5EO0FBT0EsV0FBS25CLFNBQUwsQ0FBZVksSUFBZixDQUFvQkUsR0FBcEI7QUFDRDs7QUFFRDs7Ozs7Ozs7MkJBS1FFLE0sRUFBT0ksSyxFQUFNO0FBQUE7O0FBQ25CLE9BQUMsUUFBRCxFQUFVLEtBQVYsRUFBZ0IsTUFBaEIsRUFBd0JkLE9BQXhCLENBQWdDLHFCQUFXO0FBQ3pDLGVBQUtTLE9BQUwsQ0FBYUMsTUFBYixFQUFxQlYsT0FBckIsQ0FBNkI7QUFBQSxpQkFBTUssS0FBS08sU0FBTCxDQUFlRyxNQUFmLENBQXNCRixTQUF0QixDQUFOO0FBQUEsU0FBN0I7QUFDRCxPQUZEO0FBR0EsV0FBS25CLFNBQUwsQ0FBZXNCLE1BQWYsQ0FBc0JGLEtBQXRCLEVBQTRCLENBQTVCO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs0QkFNU04sRyxFQUFJO0FBQUE7O0FBQ1gsVUFBRyxLQUFLZCxTQUFMLENBQWVLLE1BQWYsR0FBc0IsQ0FBekIsRUFBMkI7QUFDekIsYUFBS0wsU0FBTCxDQUFlTSxPQUFmLENBQXVCLFVBQUNFLElBQUQsRUFBTVksS0FBTixFQUFjO0FBQ25DLGlCQUFLQyxNQUFMLENBQVliLEtBQUtRLE1BQWpCLEVBQXdCSSxLQUF4QjtBQUNELFNBRkQ7QUFHRDtBQUNELFdBQUtiLEdBQUwsQ0FBU08sR0FBVDtBQUNBLFdBQUtYLElBQUw7QUFDRDs7Ozs7O2tCQUVZVCxTIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBTb3J0T3JkZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBgc29ydE9yZGVyYCBhcnJheVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuY29sdW1ucyAtIGFuIGFycmF5IG9mIGNvbHVtbnMgZnJvbSB7QGxpbmsgVGFibGVDb2x1bW5zfVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuc29ydENhbGxiYWNrIC0gZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBzb3J0aW5nIGJhc2VkIG9uIHRoZSBgc29ydE9yZGVyYFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnNvcnRDYWxsYmFja1Njb3BlIC0gc2NvcGUgaW4gd2hpY2ggc29ydCBjYWxsYmFjayBuZWVkcyB0byBiZSBleGVjdXRlZFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5kZWZhdWx0U29ydGluZ10gLSBhbiBhcnJheSBvZiBvYmplY3RzIHRoYXQgc3BlY2lmeSBkZWZhdWx0IHNvcnRpbmdcclxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kZWZhdWx0U29ydGluZy5jb2x1bW4gLSBjb2x1bW4gaW5kZXhcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5kZWZhdWx0U29ydGluZy5kaXJlY3Rpb24gLSBzb3J0IGRpcmVjdGlvbiAoYGFzY2B8YGRlc2NgKVxyXG4gICAqIEByZXR1cm4ge0FycmF5fVxyXG4gICAqICovXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucyl7XHJcbiAgICBsZXQge2NvbHVtbnMsIHNvcnRDYWxsYmFjaywgZGVmYXVsdFNvcnRpbmc9W10sIHNvcnRDYWxsYmFja1Njb3BlPXRoaXN9ID0gb3B0aW9ucztcclxuXHJcbiAgICB0aGlzLnNvcnRPcmRlciA9IFtdO1xyXG4gICAgaWYodHlwZW9mIGNvbHVtbnMgIT0gdW5kZWZpbmVkICYmIGNvbHVtbnMgIT0gbnVsbCl7XHJcbiAgICAgIHRoaXMuY29sdW1ucyA9IGNvbHVtbnM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTb3J0T3JkZXI6IGNvbHVtbnMgbXVzdCBiZSBzcGVjaWZpZWQnKTtcclxuICAgIH1cclxuICAgIHRoaXMuc29ydCA9ICgpPT57XHJcbiAgICAgIGlmKHNvcnRDYWxsYmFjayAmJiB0eXBlb2Ygc29ydENhbGxiYWNrID09PSAnZnVuY3Rpb24nKXtcclxuICAgICAgICBzb3J0Q2FsbGJhY2suY2FsbChzb3J0Q2FsbGJhY2tTY29wZSx0aGlzKVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYoZGVmYXVsdFNvcnRpbmcubGVuZ3RoPjApe1xyXG4gICAgICBkZWZhdWx0U29ydGluZy5mb3JFYWNoKGl0ZW09PnRoaXMuYWRkKGl0ZW0pKTtcclxuICAgICAgdGhpcy5zb3J0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgYSBgY2VsbGAgZnJvbSB0aGUgdGFibGUgYW5kIGEgcmVmZXJlbmNlIGNlbGwgKGByZWZDZWxsYCkgZnJvbSB0aGUgZmxvYXRpbmcgaGVhZGVyIGlmIGFueVxyXG4gICAqIEBwYXJhbSB7IU51bWJlcn0gY29sdW1uSW5kZXggLSBpbmRleCBvZiB0aGUgY29sdW1uIGZyb20gdGhlIGFycmF5IG9mIGNvbHVtbnMgZnJvbSB7QGxpbmsgVGFibGVDb2x1bW5zfVxyXG4gICAqIEByZXR1cm4ge3tjZWxsOkhUTUxUYWJsZUNlbGxFbGVtZW50LCByZWZDZWxsOkhUTUxUYWJsZUNlbGxFbGVtZW50fX1cclxuICAgKiAqL1xyXG4gIGdldENlbGwoY29sdW1uSW5kZXgpe1xyXG4gICAgaWYodHlwZW9mIGNvbHVtbkluZGV4ICE9ICd1bmRlZmluZWQnICYmIGNvbHVtbkluZGV4IT1udWxsKXtcclxuICAgICAgbGV0IGNlbGxzID0gW107XHJcbiAgICAgIGlmKHRoaXMuY29sdW1uc1tjb2x1bW5JbmRleF0uY2VsbCl7Y2VsbHMucHVzaCh0aGlzLmNvbHVtbnNbY29sdW1uSW5kZXhdLmNlbGwpfVxyXG4gICAgICBpZih0aGlzLmNvbHVtbnNbY29sdW1uSW5kZXhdLnJlZkNlbGwpe2NlbGxzLnB1c2godGhpcy5jb2x1bW5zW2NvbHVtbkluZGV4XS5yZWZDZWxsKX1cclxuICAgICAgcmV0dXJuIGNlbGxzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29sdW1uSW5kZXggcGFyYW1ldGVyIHNob3VsZCBub3QgYmUgbnVsbCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhbm90aGVyIGNvbHVtbiB0byBiZSBzb3J0ZWRcclxuICAgKiBAcGFyYW0geyFPYmplY3R9IG9iaiAtIG9iamVjdCBkZXNjcmliaW5nIHNvcnRpbmdcclxuICAgKiBAcGFyYW0ge051bWJlcn0gb2JqLmNvbHVtbiAtIGNvbHVtbiBpbmRleFxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvYmouZGlyZWN0aW9uIC0gc29ydCBkaXJlY3Rpb24gKGBhc2NgfGBkZXNjYClcclxuICAgKiAqL1xyXG5cclxuICBhZGQgKG9iail7XHJcbiAgICB0aGlzLmdldENlbGwob2JqLmNvbHVtbikuZm9yRWFjaChjZWxsPT57XHJcbiAgICAgIC8vaWYoIWNlbGwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzb3J0ZWQnKSl7IC8vIHRoaXMgY29sdW1uIGlzIG5vdCBzb3J0ZWQsIHRoZXJlIG1pZ2h0IGJlIG90aGVycyB0aGF0IGFyZS5cclxuICAgICAgICBbJ3NvcnRlZCcsb2JqLmRpcmVjdGlvbl0uZm9yRWFjaChjbGFzc05hbWU9PmNlbGwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpKTtcclxuICAgICAgLy99IGVsc2UgeyAvL3N3YXBzIHNvcnRpbmcgZnJvbSBhc2MgdG8gZGVzY1xyXG4gICAgICAvLyAgWydhc2MnLCdkZXNjJ10uZm9yRWFjaChjbGFzc05hbWU9PmNlbGwuY2xhc3NMaXN0LnRvZ2dsZShjbGFzc05hbWUpKTtcclxuICAgICAgLy99XHJcbiAgICB9KTtcclxuICAgIHRoaXMuc29ydE9yZGVyLnB1c2gob2JqKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgYSBjb2x1bW4gZnJvbSBgc29ydE9yZGVyYFxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2x1bW4gLSBjb2x1bW4gaW5kZXggYXMgcmVmZXJlbmNlIHRvIHRoZSBpdGVtIHRvIGJlIHJlbW92ZWQuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gaW5kZXggb2YgaXRlbSBpbiBgc29ydE9yZGVyYCBhcnJheSB0byBiZSByZW1vdmVkXHJcbiAgICogKi9cclxuICByZW1vdmUgKGNvbHVtbixpbmRleCl7XHJcbiAgICBbJ3NvcnRlZCcsJ2FzYycsJ2Rlc2MnXS5mb3JFYWNoKGNsYXNzTmFtZT0+e1xyXG4gICAgICB0aGlzLmdldENlbGwoY29sdW1uKS5mb3JFYWNoKGNlbGw9PmNlbGwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpKVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnNvcnRPcmRlci5zcGxpY2UoaW5kZXgsMSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVwbGFjZXMgYWxsIGl0ZW1zIGluIGBzb3J0T3JkZXJgXHJcbiAgICogQHBhcmFtIHshT2JqZWN0fSBvYmogLSBvYmplY3QgZGVzY3JpYmluZyBzb3J0aW5nXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9iai5jb2x1bW4gLSBjb2x1bW4gaW5kZXhcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqLmRpcmVjdGlvbiAtIHNvcnQgZGlyZWN0aW9uIChgYXNjYHxgZGVzY2ApXHJcbiAgICogKi9cclxuICByZXBsYWNlIChvYmope1xyXG4gICAgaWYodGhpcy5zb3J0T3JkZXIubGVuZ3RoPjApe1xyXG4gICAgICB0aGlzLnNvcnRPcmRlci5mb3JFYWNoKChpdGVtLGluZGV4KT0+e1xyXG4gICAgICAgIHRoaXMucmVtb3ZlKGl0ZW0uY29sdW1uLGluZGV4KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmFkZChvYmopO1xyXG4gICAgdGhpcy5zb3J0KCk7XHJcbiAgfTtcclxufVxyXG5leHBvcnQgZGVmYXVsdCBTb3J0T3JkZXI7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vci1zb3J0LXRhYmxlL3NyYy9zb3J0LW9yZGVyLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nvar _tableColumns = __webpack_require__(9);\n\nvar _tableColumns2 = _interopRequireDefault(_tableColumns);\n\nvar _sortOrder = __webpack_require__(7);\n\nvar _sortOrder2 = _interopRequireDefault(_sortOrder);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Event reporting that a table has been sorted\r\n * @event SortTable~reportal-table-sort\r\n */\n\n/**\r\n * Makes a table sortable, gives API for sorting. It sorts `data` array, but doesn't move rows in the `source` table, because of differences in implementation.\r\n *\r\n * > Note: It's important that every Array item that is going to be sortable was either a `String`, a `Number`, a `null`, or an `Object` that contained `data` property (which was of the previously named types)\r\n *\r\n * @param {Object} options - options passed to configure the Sorting\r\n * @param {HTMLTableElement} options.source - source table sorting will be applied to\r\n * @param {HTMLTableElement} [options.refSource] - the floating header if any, will reflect and trigger sorting on header when scrolled.\r\n * @param {Number} [options.defaultHeaderRow=-1] - index of the row in `thead` (incremented from 0) that will have sorting enabled for columns. If `-1` then last row.\r\n * @param {Array} [options.included] - Array of column indices (incremented from 0) that will have sorting enabled. If not specified, all columns will be sortable. Optionally `excluded` can be specified instead as a shorthand to pass only indices of columns to be excluded from sorting, assumning that others will be made sortable. It's important to count the column index in the defaultHeaderRow\r\n * @param {Array} [options.excluded] - Array of column indices (incremented from 0) that will be excluded from sorting. Can be used as a shorthand instead of `included`.\r\n * @param {Object} [options.defaultSorting] - an array of objects that specify default sorting\r\n * @param {Number} options.defaultSorting.column - column index\r\n * @param {String} options.defaultSorting.direction - sort direction (`asc`|`desc`)\r\n * @param {Array} options.data - data with information for rows to be sorted\r\n * @param {Boolean} [options.multidimensional=false] - if `data` is single-dimensional (contains rows with data to be sorted as immediate array items: `data [rowItem...]`), then it is `false`. If it has blocks of data as items (each block containing an array of rows to be sorted: data [block [rowItem...]...]), then set it to `true`. Currently it supports only a two-level aggregation max (data->block->rowItem).\r\n * @prop {HTMLTableElement} source - source table\r\n * @prop {Array} data - data array to be sorted\r\n * @prop {Boolean} multidimensional - if `data` is mono-dimensional (contains rows with data to be sorted as immediate array items: `data [rowItem...]`), then it is `false`. If it has blocks of data as items (each block containing an array of rows to be sorted: data [block [rowItem...]...]), then set it to `true`. Currently it supports only a two-level aggregation max (data->block->rowItem).\r\n * @prop {SortOrder} sortOrder - instance of {@link SortOrder}\r\n * @prop {TableColumns} columns - instance of {@link TableColumns} with a modified prototype (added `sortable:true` and `.sortable` to sortable columns)\r\n * @class SortTable\r\n * */\nvar SortTable = function () {\n  /**\r\n   *\r\n   *\r\n   *  */\n\n  function SortTable(options) {\n    var _ref,\n        _ref$sortOrder,\n        _this = this;\n\n    _classCallCheck(this, SortTable);\n\n    var source = options.source,\n        refSource = options.refSource,\n        _options$defaultHeade = options.defaultHeaderRow,\n        defaultHeaderRow = _options$defaultHeade === undefined ? -1 : _options$defaultHeade,\n        included = options.included,\n        excluded = options.excluded,\n        _options$defaultSorti = options.defaultSorting,\n        defaultSorting = _options$defaultSorti === undefined ? [] : _options$defaultSorti,\n        _options$data = options.data,\n        data = _options$data === undefined ? [] : _options$data,\n        _options$multidimensi = options.multidimensional,\n        multidimensional = _options$multidimensi === undefined ? false : _options$multidimensi;\n\n    this._sortEvent = _rReportalBase2.default.newEvent('reportal-table-sort');\n\n    if (source) {\n      this.source = source;\n    } else {\n      throw new Error('`source` table is not specified for SortTable');\n    }\n    this.data = data;\n    this.multidimensional = multidimensional;\n\n    //let tableColumns= new TableColumns({source, refSource, defaultHeaderRow});\n    var sortableColumns = SortTable.defineSortableColumns(new _tableColumns2.default({ source: source, refSource: refSource, defaultHeaderRow: defaultHeaderRow }), included, excluded);\n    this.columns = sortableColumns;\n    // setup sort order and do initial default sorting\n    this.sortOrder = (_ref = new _sortOrder2.default({ columns: sortableColumns, sortCallback: this.sort, sortCallbackScope: this, defaultSorting: defaultSorting }), _ref$sortOrder = _toArray(_ref.sortOrder), _ref);\n    [source, refSource].forEach(function (src) {\n      if (src) {\n        SortTable.listenForSort(_tableColumns2.default.getHeader(src), sortableColumns, _this.sortOrder);\n      }\n    }); // set up listeners for headers\n  }\n\n  /**\r\n   * Checks the table columns array against the `included`/`excluded` columns arrays and adds a `sortable:true` property and a `.sortable` class to the sortable ones\r\n   * @param {TableColumns} columns - an instance of {@link TableColumns}\r\n   * @param {Array} [included] - array of included columns indices\r\n   * @param {Array} [excluded] - array of excluded columns indices\r\n   * */\n\n\n  _createClass(SortTable, [{\n    key: \"sort\",\n\n\n    /**\r\n     * Performs channeling of sorting based on whether `this.data` is `multidimensional`\r\n     * @param {SortOrder} sortOrder - instance of {@link SortOrder} passed by the {@link SortOrder#sort} on initial sort\r\n     * @fires SortTable~reportal-table-sort\r\n     * */\n    value: function sort(sortOrder) {\n      var _this2 = this;\n\n      var so = sortOrder.sortOrder || this.sortOrder.sortOrder,\n          columns = this.columns;\n      if (so && so.length > 0) {\n        if (!this.multidimensional) {\n          SortTable.sortDimension(this.data, columns, so);\n        } else {\n          // if array has nested array blocks\n          this.data.forEach(function (dimension) {\n            SortTable.sortDimension(dimension, _this2.columns, so);\n          });\n        }\n        columns[so[0].column].cell.dispatchEvent(this._sortEvent);\n      }\n    }\n    /**\r\n     * Splits sorting into one-column or two-column. The precedence of columns in `sortOrder` is the factor defining sort priority\r\n     * @param {Array} data - array containing row items to be sorted\r\n     * @param {TableColumns} columns - array of table columns from {@link SortTable#defineSortableColumns}\r\n     * @param {SortOrder} sortOrder - instance of {@link SortOrder}\r\n     * */\n\n  }], [{\n    key: \"defineSortableColumns\",\n    value: function defineSortableColumns(columns, included, excluded) {\n      var sortableColumns = [].slice.call(columns);\n      sortableColumns.forEach(function (column, index) {\n        var sortable = !included && !excluded || included && included.indexOf(index) != -1 || excluded && excluded.indexOf(index) == -1;\n        if (sortable) {\n          column.cell.classList.add('sortable');\n          if (column.refCell) {\n            column.refCell.classList.add('sortable');\n          }\n          column.sortable = true;\n        }\n      });\n      return sortableColumns;\n    }\n\n    /**\r\n     * sets up listeners for column headers available for click\r\n     * @param {HTMLElement} delegatedTarget - element that will receive clicks and see if they are valid, `thead` is recommended to boil down to header clicks only\r\n     * @param {TableColumns} columns - array of table columns from {@link SortTable#defineSortableColumns}\r\n     * @param {SortOrder} sortOrder - instance of {@link SortOrder}\r\n     * @listens click\r\n     * */\n\n  }, {\n    key: \"listenForSort\",\n    value: function listenForSort(delegatedTarget, columns, sortOrder) {\n      delegatedTarget.addEventListener('click', function (e) {\n        // if it's a table cell, is in columns array and is sortable\n        var clickedColumn = void 0;\n        for (var i = 0; i < columns.length; i++) {\n          if (e.target == columns[i].cell || e.target == columns[i].refCell) {\n            clickedColumn = columns[i];break;\n          }\n        }\n        if ((e.target.tagName == 'TD' || e.target.tagName == 'TH') && clickedColumn.sortable) {\n          sortOrder.replace({ column: columns.indexOf(clickedColumn), direction: e.target.classList.contains('asc') ? 'desc' : 'asc' });\n        }\n      });\n    }\n  }, {\n    key: \"sortDimension\",\n    value: function sortDimension(data, columns, sortOrder) {\n      var getIndex = function getIndex(i) {\n        return columns[sortOrder[i].column].index;\n      };\n      var getDirection = function getDirection(i) {\n        return sortOrder[i].direction === 'desc' ? -1 : 1;\n      };\n      // TODO: add possibility to sort the data that was stripped by column.\n      data.sort(function (a, b) {\n        // sort rows\n        if (sortOrder.length == 1) {\n          //sort one column only\n          return SortTable.sorter(a[getIndex(0)], b[getIndex(0)], getDirection(0));\n        } else {\n          //sort against two columns\n          return SortTable.sorter(a[getIndex(0)], b[getIndex(0)], getDirection(0)) || SortTable.sorter(a[getIndex(1)], b[getIndex(1)], getDirection(1));\n        }\n      });\n    }\n\n    /**\r\n     * Function that performs case insensitive sorting in the array. It can distinguish between numbers, numbers as strings, HTML and plain strings\r\n     * */\n\n  }, {\n    key: \"sorter\",\n    value: function sorter(a, b, lesser) {\n      var regex = /[<>]/g;\n      if (regex.test(a) || regex.test(b)) {\n        // if we need to sort elements that have HTML like links\n        var tempEl1 = document.createElement('span');tempEl1.innerHTML = a;\n        a = tempEl1.textContent.trim();\n        var tempEl2 = document.createElement('span');tempEl2.innerHTML = b;\n        b = tempEl2.textContent.trim();\n      }\n      if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) == 'object' && _typeof(a.data) != undefined) {\n        a = a.data;\n      }\n      if ((typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) == 'object' && _typeof(b.data) != undefined) {\n        b = b.data;\n      }\n      if (!isNaN(a) && !isNaN(b)) {\n        //they might be numbers or null\n        if (a === null) {\n          return 1;\n        } else if (b === null) {\n          return -1;\n        }\n        return a < b ? lesser : a > b ? -lesser : 0;\n      } else if (!isNaN(parseFloat(a)) && !isNaN(parseFloat(b))) {\n        // they might be number strings\n        return parseFloat(a) < parseFloat(b) ? lesser : parseFloat(a) > parseFloat(b) ? -lesser : 0;\n      } else {\n        //they might be simple strings\n        return a.toLowerCase() < b.toLowerCase() ? lesser : a.toLowerCase() > b.toLowerCase() ? -lesser : 0;\n      }\n    }\n  }]);\n\n  return SortTable;\n}();\n\nexports.default = SortTable;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Itc29ydC10YWJsZS9zcmMvc29ydC10YWJsZS5qcz83MDc4Il0sIm5hbWVzIjpbIlNvcnRUYWJsZSIsIm9wdGlvbnMiLCJzb3VyY2UiLCJyZWZTb3VyY2UiLCJkZWZhdWx0SGVhZGVyUm93IiwiaW5jbHVkZWQiLCJleGNsdWRlZCIsImRlZmF1bHRTb3J0aW5nIiwiZGF0YSIsIm11bHRpZGltZW5zaW9uYWwiLCJfc29ydEV2ZW50IiwibmV3RXZlbnQiLCJFcnJvciIsInNvcnRhYmxlQ29sdW1ucyIsImRlZmluZVNvcnRhYmxlQ29sdW1ucyIsImNvbHVtbnMiLCJzb3J0T3JkZXIiLCJzb3J0Q2FsbGJhY2siLCJzb3J0Iiwic29ydENhbGxiYWNrU2NvcGUiLCJmb3JFYWNoIiwic3JjIiwibGlzdGVuRm9yU29ydCIsImdldEhlYWRlciIsInNvIiwibGVuZ3RoIiwic29ydERpbWVuc2lvbiIsImRpbWVuc2lvbiIsImNvbHVtbiIsImNlbGwiLCJkaXNwYXRjaEV2ZW50Iiwic2xpY2UiLCJjYWxsIiwiaW5kZXgiLCJzb3J0YWJsZSIsImluZGV4T2YiLCJjbGFzc0xpc3QiLCJhZGQiLCJyZWZDZWxsIiwiZGVsZWdhdGVkVGFyZ2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImNsaWNrZWRDb2x1bW4iLCJpIiwiZSIsInRhcmdldCIsInRhZ05hbWUiLCJyZXBsYWNlIiwiZGlyZWN0aW9uIiwiY29udGFpbnMiLCJnZXRJbmRleCIsImdldERpcmVjdGlvbiIsImEiLCJiIiwic29ydGVyIiwibGVzc2VyIiwicmVnZXgiLCJ0ZXN0IiwidGVtcEVsMSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsInRleHRDb250ZW50IiwidHJpbSIsInRlbXBFbDIiLCJ1bmRlZmluZWQiLCJpc05hTiIsInBhcnNlRmxvYXQiLCJ0b0xvd2VyQ2FzZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7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QUFSO0FBQVU7QUFDcEQsZUFBT0QsSUFBS0MsQ0FBTCxHQUFTRSxNQUFULEdBQW1CSCxJQUFLQyxDQUFMLEdBQVMsQ0FBQ0UsTUFBVixHQUFtQixDQUE3QztBQUNELE9BSEQsTUFJSyxJQUFHLENBQUNXLE1BQU1DLFdBQVdmLENBQVgsQ0FBTixDQUFELElBQXlCLENBQUNjLE1BQU1DLFdBQVdkLENBQVgsQ0FBTixDQUE3QixFQUFrRDtBQUFFO0FBQ3ZELGVBQU9jLFdBQVdmLENBQVgsSUFBaUJlLFdBQVdkLENBQVgsQ0FBakIsR0FBaUNFLE1BQWpDLEdBQTJDWSxXQUFXZixDQUFYLElBQWlCZSxXQUFXZCxDQUFYLENBQWpCLEdBQWlDLENBQUNFLE1BQWxDLEdBQTJDLENBQTdGO0FBQ0QsT0FGSSxNQUVFO0FBQUU7QUFDUCxlQUFPSCxFQUFFZ0IsV0FBRixLQUFrQmYsRUFBRWUsV0FBRixFQUFsQixHQUFvQ2IsTUFBcEMsR0FBNkNILEVBQUVnQixXQUFGLEtBQWtCZixFQUFFZSxXQUFGLEVBQWxCLEdBQW9DLENBQUNiLE1BQXJDLEdBQThDLENBQWxHO0FBQ0Q7QUFDRjs7Ozs7O2tCQUlZdEQsUyIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlcG9ydGFsQmFzZSBmcm9tIFwici1yZXBvcnRhbC1iYXNlXCI7XHJcbmltcG9ydCBUYWJsZUNvbHVtbnMgZnJvbSBcIi4vdGFibGUtY29sdW1uc1wiO1xyXG5pbXBvcnQgU29ydE9yZGVyIGZyb20gXCIuL3NvcnQtb3JkZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBFdmVudCByZXBvcnRpbmcgdGhhdCBhIHRhYmxlIGhhcyBiZWVuIHNvcnRlZFxyXG4gKiBAZXZlbnQgU29ydFRhYmxlfnJlcG9ydGFsLXRhYmxlLXNvcnRcclxuICovXHJcblxyXG4vKipcclxuICogTWFrZXMgYSB0YWJsZSBzb3J0YWJsZSwgZ2l2ZXMgQVBJIGZvciBzb3J0aW5nLiBJdCBzb3J0cyBgZGF0YWAgYXJyYXksIGJ1dCBkb2Vzbid0IG1vdmUgcm93cyBpbiB0aGUgYHNvdXJjZWAgdGFibGUsIGJlY2F1c2Ugb2YgZGlmZmVyZW5jZXMgaW4gaW1wbGVtZW50YXRpb24uXHJcbiAqXHJcbiAqID4gTm90ZTogSXQncyBpbXBvcnRhbnQgdGhhdCBldmVyeSBBcnJheSBpdGVtIHRoYXQgaXMgZ29pbmcgdG8gYmUgc29ydGFibGUgd2FzIGVpdGhlciBhIGBTdHJpbmdgLCBhIGBOdW1iZXJgLCBhIGBudWxsYCwgb3IgYW4gYE9iamVjdGAgdGhhdCBjb250YWluZWQgYGRhdGFgIHByb3BlcnR5ICh3aGljaCB3YXMgb2YgdGhlIHByZXZpb3VzbHkgbmFtZWQgdHlwZXMpXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBwYXNzZWQgdG8gY29uZmlndXJlIHRoZSBTb3J0aW5nXHJcbiAqIEBwYXJhbSB7SFRNTFRhYmxlRWxlbWVudH0gb3B0aW9ucy5zb3VyY2UgLSBzb3VyY2UgdGFibGUgc29ydGluZyB3aWxsIGJlIGFwcGxpZWQgdG9cclxuICogQHBhcmFtIHtIVE1MVGFibGVFbGVtZW50fSBbb3B0aW9ucy5yZWZTb3VyY2VdIC0gdGhlIGZsb2F0aW5nIGhlYWRlciBpZiBhbnksIHdpbGwgcmVmbGVjdCBhbmQgdHJpZ2dlciBzb3J0aW5nIG9uIGhlYWRlciB3aGVuIHNjcm9sbGVkLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGVmYXVsdEhlYWRlclJvdz0tMV0gLSBpbmRleCBvZiB0aGUgcm93IGluIGB0aGVhZGAgKGluY3JlbWVudGVkIGZyb20gMCkgdGhhdCB3aWxsIGhhdmUgc29ydGluZyBlbmFibGVkIGZvciBjb2x1bW5zLiBJZiBgLTFgIHRoZW4gbGFzdCByb3cuXHJcbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmluY2x1ZGVkXSAtIEFycmF5IG9mIGNvbHVtbiBpbmRpY2VzIChpbmNyZW1lbnRlZCBmcm9tIDApIHRoYXQgd2lsbCBoYXZlIHNvcnRpbmcgZW5hYmxlZC4gSWYgbm90IHNwZWNpZmllZCwgYWxsIGNvbHVtbnMgd2lsbCBiZSBzb3J0YWJsZS4gT3B0aW9uYWxseSBgZXhjbHVkZWRgIGNhbiBiZSBzcGVjaWZpZWQgaW5zdGVhZCBhcyBhIHNob3J0aGFuZCB0byBwYXNzIG9ubHkgaW5kaWNlcyBvZiBjb2x1bW5zIHRvIGJlIGV4Y2x1ZGVkIGZyb20gc29ydGluZywgYXNzdW1uaW5nIHRoYXQgb3RoZXJzIHdpbGwgYmUgbWFkZSBzb3J0YWJsZS4gSXQncyBpbXBvcnRhbnQgdG8gY291bnQgdGhlIGNvbHVtbiBpbmRleCBpbiB0aGUgZGVmYXVsdEhlYWRlclJvd1xyXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5leGNsdWRlZF0gLSBBcnJheSBvZiBjb2x1bW4gaW5kaWNlcyAoaW5jcmVtZW50ZWQgZnJvbSAwKSB0aGF0IHdpbGwgYmUgZXhjbHVkZWQgZnJvbSBzb3J0aW5nLiBDYW4gYmUgdXNlZCBhcyBhIHNob3J0aGFuZCBpbnN0ZWFkIG9mIGBpbmNsdWRlZGAuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5kZWZhdWx0U29ydGluZ10gLSBhbiBhcnJheSBvZiBvYmplY3RzIHRoYXQgc3BlY2lmeSBkZWZhdWx0IHNvcnRpbmdcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVmYXVsdFNvcnRpbmcuY29sdW1uIC0gY29sdW1uIGluZGV4XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmRlZmF1bHRTb3J0aW5nLmRpcmVjdGlvbiAtIHNvcnQgZGlyZWN0aW9uIChgYXNjYHxgZGVzY2ApXHJcbiAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbnMuZGF0YSAtIGRhdGEgd2l0aCBpbmZvcm1hdGlvbiBmb3Igcm93cyB0byBiZSBzb3J0ZWRcclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tdWx0aWRpbWVuc2lvbmFsPWZhbHNlXSAtIGlmIGBkYXRhYCBpcyBzaW5nbGUtZGltZW5zaW9uYWwgKGNvbnRhaW5zIHJvd3Mgd2l0aCBkYXRhIHRvIGJlIHNvcnRlZCBhcyBpbW1lZGlhdGUgYXJyYXkgaXRlbXM6IGBkYXRhIFtyb3dJdGVtLi4uXWApLCB0aGVuIGl0IGlzIGBmYWxzZWAuIElmIGl0IGhhcyBibG9ja3Mgb2YgZGF0YSBhcyBpdGVtcyAoZWFjaCBibG9jayBjb250YWluaW5nIGFuIGFycmF5IG9mIHJvd3MgdG8gYmUgc29ydGVkOiBkYXRhIFtibG9jayBbcm93SXRlbS4uLl0uLi5dKSwgdGhlbiBzZXQgaXQgdG8gYHRydWVgLiBDdXJyZW50bHkgaXQgc3VwcG9ydHMgb25seSBhIHR3by1sZXZlbCBhZ2dyZWdhdGlvbiBtYXggKGRhdGEtPmJsb2NrLT5yb3dJdGVtKS5cclxuICogQHByb3Age0hUTUxUYWJsZUVsZW1lbnR9IHNvdXJjZSAtIHNvdXJjZSB0YWJsZVxyXG4gKiBAcHJvcCB7QXJyYXl9IGRhdGEgLSBkYXRhIGFycmF5IHRvIGJlIHNvcnRlZFxyXG4gKiBAcHJvcCB7Qm9vbGVhbn0gbXVsdGlkaW1lbnNpb25hbCAtIGlmIGBkYXRhYCBpcyBtb25vLWRpbWVuc2lvbmFsIChjb250YWlucyByb3dzIHdpdGggZGF0YSB0byBiZSBzb3J0ZWQgYXMgaW1tZWRpYXRlIGFycmF5IGl0ZW1zOiBgZGF0YSBbcm93SXRlbS4uLl1gKSwgdGhlbiBpdCBpcyBgZmFsc2VgLiBJZiBpdCBoYXMgYmxvY2tzIG9mIGRhdGEgYXMgaXRlbXMgKGVhY2ggYmxvY2sgY29udGFpbmluZyBhbiBhcnJheSBvZiByb3dzIHRvIGJlIHNvcnRlZDogZGF0YSBbYmxvY2sgW3Jvd0l0ZW0uLi5dLi4uXSksIHRoZW4gc2V0IGl0IHRvIGB0cnVlYC4gQ3VycmVudGx5IGl0IHN1cHBvcnRzIG9ubHkgYSB0d28tbGV2ZWwgYWdncmVnYXRpb24gbWF4IChkYXRhLT5ibG9jay0+cm93SXRlbSkuXHJcbiAqIEBwcm9wIHtTb3J0T3JkZXJ9IHNvcnRPcmRlciAtIGluc3RhbmNlIG9mIHtAbGluayBTb3J0T3JkZXJ9XHJcbiAqIEBwcm9wIHtUYWJsZUNvbHVtbnN9IGNvbHVtbnMgLSBpbnN0YW5jZSBvZiB7QGxpbmsgVGFibGVDb2x1bW5zfSB3aXRoIGEgbW9kaWZpZWQgcHJvdG90eXBlIChhZGRlZCBgc29ydGFibGU6dHJ1ZWAgYW5kIGAuc29ydGFibGVgIHRvIHNvcnRhYmxlIGNvbHVtbnMpXHJcbiAqIEBjbGFzcyBTb3J0VGFibGVcclxuICogKi9cclxuY2xhc3MgU29ydFRhYmxlIHtcclxuICAvKipcclxuICAgKlxyXG4gICAqXHJcbiAgICogICovXHJcblxyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpe1xyXG4gICAgbGV0IHtzb3VyY2UscmVmU291cmNlLGRlZmF1bHRIZWFkZXJSb3c9LTEsaW5jbHVkZWQsZXhjbHVkZWQsZGVmYXVsdFNvcnRpbmc9W10sZGF0YT1bXSxtdWx0aWRpbWVuc2lvbmFsPWZhbHNlfT1vcHRpb25zO1xyXG4gICAgdGhpcy5fc29ydEV2ZW50ID0gUmVwb3J0YWxCYXNlLm5ld0V2ZW50KCdyZXBvcnRhbC10YWJsZS1zb3J0Jyk7XHJcblxyXG4gICAgICBpZihzb3VyY2Upe1xyXG4gICAgICAgIHRoaXMuc291cmNlPXNvdXJjZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bzb3VyY2VgIHRhYmxlIGlzIG5vdCBzcGVjaWZpZWQgZm9yIFNvcnRUYWJsZScpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgIHRoaXMubXVsdGlkaW1lbnNpb25hbCA9IG11bHRpZGltZW5zaW9uYWw7XHJcblxyXG4gICAgICAvL2xldCB0YWJsZUNvbHVtbnM9IG5ldyBUYWJsZUNvbHVtbnMoe3NvdXJjZSwgcmVmU291cmNlLCBkZWZhdWx0SGVhZGVyUm93fSk7XHJcbiAgICAgIGxldCBzb3J0YWJsZUNvbHVtbnM9U29ydFRhYmxlLmRlZmluZVNvcnRhYmxlQ29sdW1ucyhuZXcgVGFibGVDb2x1bW5zKHtzb3VyY2UsIHJlZlNvdXJjZSwgZGVmYXVsdEhlYWRlclJvd30pLCBpbmNsdWRlZCwgZXhjbHVkZWQpO1xyXG4gICAgICB0aGlzLmNvbHVtbnMgPSBzb3J0YWJsZUNvbHVtbnM7XHJcbiAgICAgIC8vIHNldHVwIHNvcnQgb3JkZXIgYW5kIGRvIGluaXRpYWwgZGVmYXVsdCBzb3J0aW5nXHJcbiAgICAgIHRoaXMuc29ydE9yZGVyID0ge3NvcnRPcmRlcjpbXX0gPSBuZXcgU29ydE9yZGVyKHtjb2x1bW5zOnNvcnRhYmxlQ29sdW1ucywgc29ydENhbGxiYWNrOnRoaXMuc29ydCwgc29ydENhbGxiYWNrU2NvcGU6dGhpcywgZGVmYXVsdFNvcnRpbmd9KTtcclxuICAgICAgW3NvdXJjZSxyZWZTb3VyY2VdLmZvckVhY2goc3JjPT57aWYoc3JjKXtTb3J0VGFibGUubGlzdGVuRm9yU29ydChUYWJsZUNvbHVtbnMuZ2V0SGVhZGVyKHNyYyksc29ydGFibGVDb2x1bW5zLCB0aGlzLnNvcnRPcmRlcil9fSk7Ly8gc2V0IHVwIGxpc3RlbmVycyBmb3IgaGVhZGVyc1xyXG5cclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgdGhlIHRhYmxlIGNvbHVtbnMgYXJyYXkgYWdhaW5zdCB0aGUgYGluY2x1ZGVkYC9gZXhjbHVkZWRgIGNvbHVtbnMgYXJyYXlzIGFuZCBhZGRzIGEgYHNvcnRhYmxlOnRydWVgIHByb3BlcnR5IGFuZCBhIGAuc29ydGFibGVgIGNsYXNzIHRvIHRoZSBzb3J0YWJsZSBvbmVzXHJcbiAgICogQHBhcmFtIHtUYWJsZUNvbHVtbnN9IGNvbHVtbnMgLSBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgVGFibGVDb2x1bW5zfVxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtpbmNsdWRlZF0gLSBhcnJheSBvZiBpbmNsdWRlZCBjb2x1bW5zIGluZGljZXNcclxuICAgKiBAcGFyYW0ge0FycmF5fSBbZXhjbHVkZWRdIC0gYXJyYXkgb2YgZXhjbHVkZWQgY29sdW1ucyBpbmRpY2VzXHJcbiAgICogKi9cclxuICBzdGF0aWMgZGVmaW5lU29ydGFibGVDb2x1bW5zKGNvbHVtbnMsIGluY2x1ZGVkLCBleGNsdWRlZCl7XHJcbiAgICBsZXQgc29ydGFibGVDb2x1bW5zID0gW10uc2xpY2UuY2FsbChjb2x1bW5zKTtcclxuICAgIHNvcnRhYmxlQ29sdW1ucy5mb3JFYWNoKChjb2x1bW4saW5kZXgpPT57XHJcbiAgICAgIGxldCBzb3J0YWJsZT0oKCFpbmNsdWRlZCAmJiAhZXhjbHVkZWQpIHx8IChpbmNsdWRlZCAmJiBpbmNsdWRlZC5pbmRleE9mKGluZGV4KSE9LTEpIHx8IChleGNsdWRlZCAmJiBleGNsdWRlZC5pbmRleE9mKGluZGV4KT09LTEpKTtcclxuICAgICAgaWYoc29ydGFibGUpe1xyXG4gICAgICAgIGNvbHVtbi5jZWxsLmNsYXNzTGlzdC5hZGQoJ3NvcnRhYmxlJyk7XHJcbiAgICAgICAgaWYoY29sdW1uLnJlZkNlbGwpe2NvbHVtbi5yZWZDZWxsLmNsYXNzTGlzdC5hZGQoJ3NvcnRhYmxlJyk7fVxyXG4gICAgICAgIGNvbHVtbi5zb3J0YWJsZSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHNvcnRhYmxlQ29sdW1uc1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogc2V0cyB1cCBsaXN0ZW5lcnMgZm9yIGNvbHVtbiBoZWFkZXJzIGF2YWlsYWJsZSBmb3IgY2xpY2tcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkZWxlZ2F0ZWRUYXJnZXQgLSBlbGVtZW50IHRoYXQgd2lsbCByZWNlaXZlIGNsaWNrcyBhbmQgc2VlIGlmIHRoZXkgYXJlIHZhbGlkLCBgdGhlYWRgIGlzIHJlY29tbWVuZGVkIHRvIGJvaWwgZG93biB0byBoZWFkZXIgY2xpY2tzIG9ubHlcclxuICAgKiBAcGFyYW0ge1RhYmxlQ29sdW1uc30gY29sdW1ucyAtIGFycmF5IG9mIHRhYmxlIGNvbHVtbnMgZnJvbSB7QGxpbmsgU29ydFRhYmxlI2RlZmluZVNvcnRhYmxlQ29sdW1uc31cclxuICAgKiBAcGFyYW0ge1NvcnRPcmRlcn0gc29ydE9yZGVyIC0gaW5zdGFuY2Ugb2Yge0BsaW5rIFNvcnRPcmRlcn1cclxuICAgKiBAbGlzdGVucyBjbGlja1xyXG4gICAqICovXHJcbiAgc3RhdGljIGxpc3RlbkZvclNvcnQoZGVsZWdhdGVkVGFyZ2V0LCBjb2x1bW5zLCBzb3J0T3JkZXIpe1xyXG4gICAgZGVsZWdhdGVkVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxlPT57XHJcbiAgICAgIC8vIGlmIGl0J3MgYSB0YWJsZSBjZWxsLCBpcyBpbiBjb2x1bW5zIGFycmF5IGFuZCBpcyBzb3J0YWJsZVxyXG4gICAgICBsZXQgY2xpY2tlZENvbHVtbjtcclxuICAgICAgZm9yKGxldCBpPTA7aTxjb2x1bW5zLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIGlmKGUudGFyZ2V0PT1jb2x1bW5zW2ldLmNlbGwgfHwgZS50YXJnZXQ9PWNvbHVtbnNbaV0ucmVmQ2VsbCl7XHJcbiAgICAgICAgICBjbGlja2VkQ29sdW1uPSBjb2x1bW5zW2ldOyBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYoKGUudGFyZ2V0LnRhZ05hbWUgPT0gJ1REJyB8fCBlLnRhcmdldC50YWdOYW1lID09ICdUSCcpICYmIGNsaWNrZWRDb2x1bW4uc29ydGFibGUpe1xyXG4gICAgICAgIHNvcnRPcmRlci5yZXBsYWNlKHtjb2x1bW46Y29sdW1ucy5pbmRleE9mKGNsaWNrZWRDb2x1bW4pLCBkaXJlY3Rpb246IGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYXNjJyk/J2Rlc2MnOidhc2MnfSk7XHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUGVyZm9ybXMgY2hhbm5lbGluZyBvZiBzb3J0aW5nIGJhc2VkIG9uIHdoZXRoZXIgYHRoaXMuZGF0YWAgaXMgYG11bHRpZGltZW5zaW9uYWxgXHJcbiAgICogQHBhcmFtIHtTb3J0T3JkZXJ9IHNvcnRPcmRlciAtIGluc3RhbmNlIG9mIHtAbGluayBTb3J0T3JkZXJ9IHBhc3NlZCBieSB0aGUge0BsaW5rIFNvcnRPcmRlciNzb3J0fSBvbiBpbml0aWFsIHNvcnRcclxuICAgKiBAZmlyZXMgU29ydFRhYmxlfnJlcG9ydGFsLXRhYmxlLXNvcnRcclxuICAgKiAqL1xyXG4gIHNvcnQoc29ydE9yZGVyKXtcclxuICAgIGxldCBzbyA9IHNvcnRPcmRlci5zb3J0T3JkZXIgfHwgdGhpcy5zb3J0T3JkZXIuc29ydE9yZGVyLFxyXG4gICAgICBjb2x1bW5zID0gdGhpcy5jb2x1bW5zO1xyXG4gICAgaWYoc28gJiYgc28ubGVuZ3RoPjApe1xyXG4gICAgICBpZighdGhpcy5tdWx0aWRpbWVuc2lvbmFsKXtcclxuICAgICAgICBTb3J0VGFibGUuc29ydERpbWVuc2lvbih0aGlzLmRhdGEsIGNvbHVtbnMsIHNvKTtcclxuICAgICAgfSBlbHNlIHsgLy8gaWYgYXJyYXkgaGFzIG5lc3RlZCBhcnJheSBibG9ja3NcclxuICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaChkaW1lbnNpb249PntcclxuICAgICAgICAgIFNvcnRUYWJsZS5zb3J0RGltZW5zaW9uKGRpbWVuc2lvbiwgdGhpcy5jb2x1bW5zLCBzbyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgY29sdW1uc1tzb1swXS5jb2x1bW5dLmNlbGwuZGlzcGF0Y2hFdmVudCh0aGlzLl9zb3J0RXZlbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBTcGxpdHMgc29ydGluZyBpbnRvIG9uZS1jb2x1bW4gb3IgdHdvLWNvbHVtbi4gVGhlIHByZWNlZGVuY2Ugb2YgY29sdW1ucyBpbiBgc29ydE9yZGVyYCBpcyB0aGUgZmFjdG9yIGRlZmluaW5nIHNvcnQgcHJpb3JpdHlcclxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIC0gYXJyYXkgY29udGFpbmluZyByb3cgaXRlbXMgdG8gYmUgc29ydGVkXHJcbiAgICogQHBhcmFtIHtUYWJsZUNvbHVtbnN9IGNvbHVtbnMgLSBhcnJheSBvZiB0YWJsZSBjb2x1bW5zIGZyb20ge0BsaW5rIFNvcnRUYWJsZSNkZWZpbmVTb3J0YWJsZUNvbHVtbnN9XHJcbiAgICogQHBhcmFtIHtTb3J0T3JkZXJ9IHNvcnRPcmRlciAtIGluc3RhbmNlIG9mIHtAbGluayBTb3J0T3JkZXJ9XHJcbiAgICogKi9cclxuICBzdGF0aWMgc29ydERpbWVuc2lvbihkYXRhLGNvbHVtbnMsc29ydE9yZGVyKXtcclxuICAgIGxldCBnZXRJbmRleCA9IChpKT0+e3JldHVybiBjb2x1bW5zW3NvcnRPcmRlcltpXS5jb2x1bW5dLmluZGV4fTtcclxuICAgIGxldCBnZXREaXJlY3Rpb249KGkpPT57cmV0dXJuIHNvcnRPcmRlcltpXS5kaXJlY3Rpb24gPT09ICdkZXNjJyA/IC0xIDogMX07XHJcbiAgICAvLyBUT0RPOiBhZGQgcG9zc2liaWxpdHkgdG8gc29ydCB0aGUgZGF0YSB0aGF0IHdhcyBzdHJpcHBlZCBieSBjb2x1bW4uXHJcbiAgICBkYXRhLnNvcnQoKGEsIGIpPT57IC8vIHNvcnQgcm93c1xyXG4gICAgICBpZihzb3J0T3JkZXIubGVuZ3RoPT0xKXsgLy9zb3J0IG9uZSBjb2x1bW4gb25seVxyXG4gICAgICAgIHJldHVybiBTb3J0VGFibGUuc29ydGVyKCBhW2dldEluZGV4KDApXSwgYltnZXRJbmRleCgwKV0sIGdldERpcmVjdGlvbigwKSApXHJcbiAgICAgIH0gZWxzZSB7IC8vc29ydCBhZ2FpbnN0IHR3byBjb2x1bW5zXHJcbiAgICAgICAgcmV0dXJuIFNvcnRUYWJsZS5zb3J0ZXIoIGFbZ2V0SW5kZXgoMCldLCBiW2dldEluZGV4KDApXSwgZ2V0RGlyZWN0aW9uKDApICkgfHwgU29ydFRhYmxlLnNvcnRlciggYVtnZXRJbmRleCgxKV0sIGJbZ2V0SW5kZXgoMSldLCBnZXREaXJlY3Rpb24oMSkgKVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgY2FzZSBpbnNlbnNpdGl2ZSBzb3J0aW5nIGluIHRoZSBhcnJheS4gSXQgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW4gbnVtYmVycywgbnVtYmVycyBhcyBzdHJpbmdzLCBIVE1MIGFuZCBwbGFpbiBzdHJpbmdzXHJcbiAgICogKi9cclxuICBzdGF0aWMgc29ydGVyKGEsYixsZXNzZXIpe1xyXG4gICAgbGV0IHJlZ2V4ID0gL1s8Pl0vZztcclxuICAgIGlmKHJlZ2V4LnRlc3QoYSkgfHwgcmVnZXgudGVzdChiKSl7IC8vIGlmIHdlIG5lZWQgdG8gc29ydCBlbGVtZW50cyB0aGF0IGhhdmUgSFRNTCBsaWtlIGxpbmtzXHJcbiAgICAgIGxldCB0ZW1wRWwxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpOyB0ZW1wRWwxLmlubmVySFRNTCA9IGE7XHJcbiAgICAgIGE9dGVtcEVsMS50ZXh0Q29udGVudC50cmltKCk7XHJcbiAgICAgIGxldCB0ZW1wRWwyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpOyB0ZW1wRWwyLmlubmVySFRNTCA9IGI7XHJcbiAgICAgIGI9dGVtcEVsMi50ZXh0Q29udGVudC50cmltKCk7XHJcbiAgICB9XHJcbiAgICBpZih0eXBlb2YgYT09J29iamVjdCcgJiYgdHlwZW9mIGEuZGF0YSAhPSB1bmRlZmluZWQpe2E9YS5kYXRhfVxyXG4gICAgaWYodHlwZW9mIGI9PSdvYmplY3QnICYmIHR5cGVvZiBiLmRhdGEgIT0gdW5kZWZpbmVkKXtiPWIuZGF0YX1cclxuICAgIGlmKCFpc05hTihhKSAmJiAhaXNOYU4oYikpeyAvL3RoZXkgbWlnaHQgYmUgbnVtYmVycyBvciBudWxsXHJcbiAgICAgIGlmKGE9PT1udWxsKXtyZXR1cm4gMX0gZWxzZSBpZiAoYj09PW51bGwpe3JldHVybiAtMX1cclxuICAgICAgcmV0dXJuIGEgPCAgYiA/IGxlc3NlciA6ICBhID4gIGIgPyAtbGVzc2VyIDogMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYoIWlzTmFOKHBhcnNlRmxvYXQoYSkpICYmICFpc05hTihwYXJzZUZsb2F0KGIpKSl7IC8vIHRoZXkgbWlnaHQgYmUgbnVtYmVyIHN0cmluZ3NcclxuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYSkgPCAgcGFyc2VGbG9hdChiKSA/IGxlc3NlciA6ICBwYXJzZUZsb2F0KGEpID4gIHBhcnNlRmxvYXQoYikgPyAtbGVzc2VyIDogMDtcclxuICAgIH0gZWxzZSB7IC8vdGhleSBtaWdodCBiZSBzaW1wbGUgc3RyaW5nc1xyXG4gICAgICByZXR1cm4gYS50b0xvd2VyQ2FzZSgpIDwgYi50b0xvd2VyQ2FzZSgpID8gbGVzc2VyIDogYS50b0xvd2VyQ2FzZSgpID4gYi50b0xvd2VyQ2FzZSgpID8gLWxlc3NlciA6IDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU29ydFRhYmxlXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vci1zb3J0LXRhYmxlL3NyYy9zb3J0LXRhYmxlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 9 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Created by IvanP on 09.09.2016.\r\n */\n\nvar TableColumns = function () {\n  /**\r\n   * Creates an array of objects corresponding to the cells of `defaultHeaderRow`, that contain `sortable` property, denoting the column is sortable,\r\n   * `index` of the column and reference to the `cell`. Adds `.sortable` to a sortable cell\r\n   * @param {Object} options - options passed to configure the Sorting\r\n   * @param {HTMLTableElement} options.source - source table sorting will be applied to\r\n   * @param {HTMLTableElement} options.refSource - floating header if any\r\n   * @param {Number|Object} [options.defaultHeaderRow=-1] - index of the row in `thead` (incremented from 0) that will have sorting enabled for columns. If `-1` then last row.\r\n   * @return {{index:Number, title:String, colSpan:Number, cell: HTMLTableCellElement, ?refCell:HTMLTableCellElement}} - an array of objects that have this structure\r\n   * */\n  function TableColumns(options) {\n    _classCallCheck(this, TableColumns);\n\n    var source = options.source,\n        refSource = options.refSource,\n        _options$defaultHeade = options.defaultHeaderRow,\n        defaultHeaderRow = _options$defaultHeade === undefined ? -1 : _options$defaultHeade;\n\n    var thead = void 0,\n        refThead = void 0;\n    if (source) {\n      thead = TableColumns.getHeader(source);\n    } else {\n      throw new TypeError('`source` table is not specified, cannot create TableColumns');\n    }\n    if (refSource) {\n      refThead = TableColumns.getHeader(refSource);\n    }\n    return TableColumns.computeColumns(thead, refThead, defaultHeaderRow);\n  }\n\n  /**\r\n   * Gets a header\r\n   * @param {HTMLTableElement} source - source table headers are created for\r\n   * */\n\n\n  _createClass(TableColumns, null, [{\n    key: 'getHeader',\n    value: function getHeader(source) {\n      if (source && source.tagName == 'TABLE') {\n        var header = source.querySelector(\"thead\");\n        if (header && header.children.length > 0) {\n          return header;\n        } else {\n          throw new TypeError('`source` table has no header or rows');\n        }\n      } else {\n        throw new TypeError('`source` is not specified or is not a table');\n      }\n    }\n\n    /**\r\n     * Calculates defaultHeaderRow for a passed `thead`\r\n     * @param {!HTMLTableElement} thead - source table header\r\n     * @param {!Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n     * @return {{index:Number, row: HTMLTableRowElement}}\r\n     * */\n\n  }, {\n    key: 'getDefaultHeaderRow',\n    value: function getDefaultHeaderRow(thead, defaultHeaderRowIndex) {\n      // calculate default header row\n      var headerRows = thead.children,\n          headerRowIndex = defaultHeaderRowIndex == -1 ? headerRows.length + defaultHeaderRowIndex : defaultHeaderRowIndex;\n      return {\n        index: headerRowIndex,\n        row: headerRows.item(headerRowIndex)\n      };\n    }\n\n    /**\r\n     * Gets an array of header cell nodes from default header row\r\n     * @param {?HTMLTableElement} thead - source table header\r\n     * @param {!Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n     * @return {?Array} Returns an array of header cell nodes or null if `thead` is not specified\r\n     * */\n\n  }, {\n    key: 'getHeaderCells',\n    value: function getHeaderCells(thead, defaultHeaderRowIndex) {\n      if (thead) {\n        if (defaultHeaderRowIndex != null) {\n          var _ret = function () {\n            var defaultHeaderRow = TableColumns.getDefaultHeaderRow(thead, defaultHeaderRowIndex);\n            var headerRows = thead.children;\n            var rowsLength = headerRows.length;\n            var abstr = {};\n\n            var _loop = function _loop(r) {\n              var row = headerRows.item(r);\n              var augmentIndex = 0; // index that will account for colSpan of upper rows' cells\n              [].slice.call(row.children).forEach(function (cell, index) {\n                //iterate through cells\n                for (var rs = 0; rs <= cell.rowSpan - 1; rs++) {\n                  //spread cell across its rowspan\n                  var rowA = abstr[r + rs] = abstr[r + rs] || {}; //create row if not exists\n                  if (!rowA[augmentIndex]) {\n                    //insert cell into slot if not filled\n                    rowA[augmentIndex] = cell;\n                  } else {\n                    //if filled look for the next empty because rowspanned columns fill them in a linear way\n                    var i = 0;\n                    while (true) {\n                      if (!rowA[i]) {\n                        rowA[i] = cell;\n                        augmentIndex = i;\n                        break;\n                      }\n                      i++;\n                    }\n                  }\n                }\n                augmentIndex += cell.colSpan;\n              });\n            };\n\n            for (var r = 0; r < rowsLength; r++) {\n              _loop(r);\n            }\n            return {\n              v: Object.keys(abstr[defaultHeaderRow.index]).map(function (k) {\n                return abstr[defaultHeaderRow.index][k];\n              })\n            };\n          }();\n\n          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n        } else {\n          throw new TypeError('TableColumns.getHeaderCells: defaultHeaderRowIndex is not specified or is not a Number');\n        }\n      }\n      return null;\n    }\n\n    /**\r\n     * Gets an array of columns from the table\r\n     * @param {!HTMLTableElement} thead - source table header\r\n     * @param {!HTMLTableElement} refThead - reference table header from floating header if any\r\n     * @param {Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n     * @return {?Array} Returns an array of header cell nodes or null if `thead` is not specified\r\n     * */\n\n  }, {\n    key: 'computeColumns',\n    value: function computeColumns(thead, refThead, defaultHeaderRowIndex) {\n      var theadCells = TableColumns.getHeaderCells(thead, defaultHeaderRowIndex);\n      var refTheadCells = TableColumns.getHeaderCells(refThead, defaultHeaderRowIndex);\n      var realColumnIndex = 0;\n      return theadCells.map(function (cell, index) {\n        var obj = {\n          index: realColumnIndex,\n          title: cell.textContent,\n          cell: cell,\n          colSpan: cell.colSpan\n        };\n        if (refTheadCells != null) {\n          obj.refCell = refTheadCells[index];\n        }\n        // we need to increment the colspan only for columns that follow rowheader because the block is not in data.\n        realColumnIndex = realColumnIndex > 0 ? realColumnIndex + cell.colSpan : realColumnIndex + 1;\n        return obj;\n      });\n    }\n  }]);\n\n  return TableColumns;\n}();\n\nexports.default = TableColumns;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Itc29ydC10YWJsZS9zcmMvdGFibGUtY29sdW1ucy5qcz9jYWFkIl0sIm5hbWVzIjpbIlRhYmxlQ29sdW1ucyIsIm9wdGlvbnMiLCJzb3VyY2UiLCJyZWZTb3VyY2UiLCJkZWZhdWx0SGVhZGVyUm93IiwidGhlYWQiLCJyZWZUaGVhZCIsImdldEhlYWRlciIsIlR5cGVFcnJvciIsImNvbXB1dGVDb2x1bW5zIiwidGFnTmFtZSIsImhlYWRlciIsInF1ZXJ5U2VsZWN0b3IiLCJjaGlsZHJlbiIsImxlbmd0aCIsImRlZmF1bHRIZWFkZXJSb3dJbmRleCIsImhlYWRlclJvd3MiLCJoZWFkZXJSb3dJbmRleCIsImluZGV4Iiwicm93IiwiaXRlbSIsImdldERlZmF1bHRIZWFkZXJSb3ciLCJyb3dzTGVuZ3RoIiwiYWJzdHIiLCJyIiwiYXVnbWVudEluZGV4Iiwic2xpY2UiLCJjYWxsIiwiZm9yRWFjaCIsImNlbGwiLCJycyIsInJvd1NwYW4iLCJyb3dBIiwiaSIsImNvbFNwYW4iLCJPYmplY3QiLCJrZXlzIiwibWFwIiwiayIsInRoZWFkQ2VsbHMiLCJnZXRIZWFkZXJDZWxscyIsInJlZlRoZWFkQ2VsbHMiLCJyZWFsQ29sdW1uSW5kZXgiLCJvYmoiLCJ0aXRsZSIsInRleHRDb250ZW50IiwicmVmQ2VsbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7SUFJTUEsWTtBQUNKOzs7Ozs7Ozs7QUFTQSx3QkFBWUMsT0FBWixFQUFvQjtBQUFBOztBQUFBLFFBQ2JDLE1BRGEsR0FDMkJELE9BRDNCLENBQ2JDLE1BRGE7QUFBQSxRQUNOQyxTQURNLEdBQzJCRixPQUQzQixDQUNORSxTQURNO0FBQUEsZ0NBQzJCRixPQUQzQixDQUNJRyxnQkFESjtBQUFBLFFBQ0lBLGdCQURKLHlDQUNxQixDQUFDLENBRHRCOztBQUVsQixRQUFJQyxjQUFKO0FBQUEsUUFBVUMsaUJBQVY7QUFDQSxRQUFHSixNQUFILEVBQVU7QUFBQ0csY0FBTUws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aUJBQU9XLE9BQU9DLElBQVAsQ0FBWWIsTUFBTW5CLGlCQUFpQmMsS0FBdkIsQ0FBWixFQUEyQ21CLEdBQTNDLENBQStDO0FBQUEsdUJBQUtkLE1BQU1uQixpQkFBaUJjLEtBQXZCLEVBQThCb0IsQ0FBOUIsQ0FBTDtBQUFBLGVBQS9DO0FBQVA7QUE1QjZCOztBQUFBO0FBNkI5QixTQTdCRCxNQTZCTztBQUNMLGdCQUFNLElBQUk5QixTQUFKLENBQWMsd0ZBQWQsQ0FBTjtBQUNEO0FBQ0Y7QUFDRCxhQUFPLElBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7OzttQ0FPc0JILEssRUFBTUMsUSxFQUFTUyxxQixFQUFzQjtBQUN6RCxVQUFJd0IsYUFBYXZDLGFBQWF3QyxjQUFiLENBQTRCbkMsS0FBNUIsRUFBa0NVLHFCQUFsQyxDQUFqQjtBQUNBLFVBQUkwQixnQkFBZ0J6QyxhQUFhd0MsY0FBYixDQUE0QmxDLFFBQTVCLEVBQXFDUyxxQkFBckMsQ0FBcEI7QUFDQSxVQUFJMkIsa0JBQWdCLENBQXBCO0FBQ0EsYUFBT0gsV0FBV0YsR0FBWCxDQUFlLFVBQUNSLElBQUQsRUFBTVgsS0FBTixFQUFjO0FBQ2xDLFlBQUl5QixNQUFNO0FBQ1J6QixpQkFBT3dCLGVBREM7QUFFUkUsaUJBQU9mLEtBQUtnQixXQUZKO0FBR1JoQixvQkFIUTtBQUlSSyxtQkFBUUwsS0FBS0s7QUFKTCxTQUFWO0FBTUEsWUFBR08saUJBQWUsSUFBbEIsRUFBdUI7QUFBQ0UsY0FBSUcsT0FBSixHQUFjTCxjQUFjdkIsS0FBZCxDQUFkO0FBQW1DO0FBQzNEO0FBQ0F3QiwwQkFBaUJBLGtCQUFnQixDQUFoQixHQUFtQkEsa0JBQWtCYixLQUFLSyxPQUExQyxHQUFtRFEsa0JBQWdCLENBQXBGO0FBQ0EsZUFBT0MsR0FBUDtBQUNELE9BWE0sQ0FBUDtBQVlEOzs7Ozs7a0JBRVkzQyxZIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ3JlYXRlZCBieSBJdmFuUCBvbiAwOS4wOS4yMDE2LlxyXG4gKi9cclxuXHJcbmNsYXNzIFRhYmxlQ29sdW1uc3tcclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG9iamVjdHMgY29ycmVzcG9uZGluZyB0byB0aGUgY2VsbHMgb2YgYGRlZmF1bHRIZWFkZXJSb3dgLCB0aGF0IGNvbnRhaW4gYHNvcnRhYmxlYCBwcm9wZXJ0eSwgZGVub3RpbmcgdGhlIGNvbHVtbiBpcyBzb3J0YWJsZSxcclxuICAgKiBgaW5kZXhgIG9mIHRoZSBjb2x1bW4gYW5kIHJlZmVyZW5jZSB0byB0aGUgYGNlbGxgLiBBZGRzIGAuc29ydGFibGVgIHRvIGEgc29ydGFibGUgY2VsbFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBwYXNzZWQgdG8gY29uZmlndXJlIHRoZSBTb3J0aW5nXHJcbiAgICogQHBhcmFtIHtIVE1MVGFibGVFbGVtZW50fSBvcHRpb25zLnNvdXJjZSAtIHNvdXJjZSB0YWJsZSBzb3J0aW5nIHdpbGwgYmUgYXBwbGllZCB0b1xyXG4gICAqIEBwYXJhbSB7SFRNTFRhYmxlRWxlbWVudH0gb3B0aW9ucy5yZWZTb3VyY2UgLSBmbG9hdGluZyBoZWFkZXIgaWYgYW55XHJcbiAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbb3B0aW9ucy5kZWZhdWx0SGVhZGVyUm93PS0xXSAtIGluZGV4IG9mIHRoZSByb3cgaW4gYHRoZWFkYCAoaW5jcmVtZW50ZWQgZnJvbSAwKSB0aGF0IHdpbGwgaGF2ZSBzb3J0aW5nIGVuYWJsZWQgZm9yIGNvbHVtbnMuIElmIGAtMWAgdGhlbiBsYXN0IHJvdy5cclxuICAgKiBAcmV0dXJuIHt7aW5kZXg6TnVtYmVyLCB0aXRsZTpTdHJpbmcsIGNvbFNwYW46TnVtYmVyLCBjZWxsOiBIVE1MVGFibGVDZWxsRWxlbWVudCwgP3JlZkNlbGw6SFRNTFRhYmxlQ2VsbEVsZW1lbnR9fSAtIGFuIGFycmF5IG9mIG9iamVjdHMgdGhhdCBoYXZlIHRoaXMgc3RydWN0dXJlXHJcbiAgICogKi9cclxuICBjb25zdHJ1Y3RvcihvcHRpb25zKXtcclxuICAgIGxldCB7c291cmNlLHJlZlNvdXJjZSxkZWZhdWx0SGVhZGVyUm93PS0xfSA9IG9wdGlvbnM7XHJcbiAgICBsZXQgdGhlYWQscmVmVGhlYWQ7XHJcbiAgICBpZihzb3VyY2Upe3RoZWFkPVRhYmxlQ29sdW1ucy5nZXRIZWFkZXIoc291cmNlKX0gZWxzZSB7dGhyb3cgbmV3IFR5cGVFcnJvcignYHNvdXJjZWAgdGFibGUgaXMgbm90IHNwZWNpZmllZCwgY2Fubm90IGNyZWF0ZSBUYWJsZUNvbHVtbnMnKX1cclxuICAgIGlmKHJlZlNvdXJjZSl7cmVmVGhlYWQ9VGFibGVDb2x1bW5zLmdldEhlYWRlcihyZWZTb3VyY2UpfVxyXG4gICAgcmV0dXJuIFRhYmxlQ29sdW1ucy5jb21wdXRlQ29sdW1ucyh0aGVhZCxyZWZUaGVhZCxkZWZhdWx0SGVhZGVyUm93KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYSBoZWFkZXJcclxuICAgKiBAcGFyYW0ge0hUTUxUYWJsZUVsZW1lbnR9IHNvdXJjZSAtIHNvdXJjZSB0YWJsZSBoZWFkZXJzIGFyZSBjcmVhdGVkIGZvclxyXG4gICAqICovXHJcbiAgc3RhdGljIGdldEhlYWRlcihzb3VyY2Upe1xyXG4gICAgaWYoc291cmNlICYmIHNvdXJjZS50YWdOYW1lID09ICdUQUJMRScpe1xyXG4gICAgICBsZXQgaGVhZGVyID0gc291cmNlLnF1ZXJ5U2VsZWN0b3IoXCJ0aGVhZFwiKTtcclxuICAgICAgaWYoaGVhZGVyICYmIGhlYWRlci5jaGlsZHJlbi5sZW5ndGg+MCkge1xyXG4gICAgICAgIHJldHVybiBoZWFkZXI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYHNvdXJjZWAgdGFibGUgaGFzIG5vIGhlYWRlciBvciByb3dzJyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Bzb3VyY2VgIGlzIG5vdCBzcGVjaWZpZWQgb3IgaXMgbm90IGEgdGFibGUnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgZGVmYXVsdEhlYWRlclJvdyBmb3IgYSBwYXNzZWQgYHRoZWFkYFxyXG4gICAqIEBwYXJhbSB7IUhUTUxUYWJsZUVsZW1lbnR9IHRoZWFkIC0gc291cmNlIHRhYmxlIGhlYWRlclxyXG4gICAqIEBwYXJhbSB7IU51bWJlcn0gZGVmYXVsdEhlYWRlclJvd0luZGV4IC0gaW5kZXggb2YgdGhlIHJvdyBpbiBgdGhlYWRgIChpbmNyZW1lbnRlZCBmcm9tIDApIHRoYXQgd2lsbCBiZSBjb25zaWRlcmVkIGRlZmF1bHQgdG8gaGF2ZSBhY3Rpb25zIGV4ZWN1dGVkIHVwb24uXHJcbiAgICogQHJldHVybiB7e2luZGV4Ok51bWJlciwgcm93OiBIVE1MVGFibGVSb3dFbGVtZW50fX1cclxuICAgKiAqL1xyXG4gIHN0YXRpYyBnZXREZWZhdWx0SGVhZGVyUm93KHRoZWFkLGRlZmF1bHRIZWFkZXJSb3dJbmRleCl7XHJcbiAgICAvLyBjYWxjdWxhdGUgZGVmYXVsdCBoZWFkZXIgcm93XHJcbiAgICBsZXQgaGVhZGVyUm93cyA9IHRoZWFkLmNoaWxkcmVuLFxyXG4gICAgICBoZWFkZXJSb3dJbmRleCA9IGRlZmF1bHRIZWFkZXJSb3dJbmRleD09LTEgPyBoZWFkZXJSb3dzLmxlbmd0aCArIGRlZmF1bHRIZWFkZXJSb3dJbmRleCA6IGRlZmF1bHRIZWFkZXJSb3dJbmRleDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGluZGV4OmhlYWRlclJvd0luZGV4LFxyXG4gICAgICByb3c6aGVhZGVyUm93cy5pdGVtKGhlYWRlclJvd0luZGV4KVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYW4gYXJyYXkgb2YgaGVhZGVyIGNlbGwgbm9kZXMgZnJvbSBkZWZhdWx0IGhlYWRlciByb3dcclxuICAgKiBAcGFyYW0gez9IVE1MVGFibGVFbGVtZW50fSB0aGVhZCAtIHNvdXJjZSB0YWJsZSBoZWFkZXJcclxuICAgKiBAcGFyYW0geyFOdW1iZXJ9IGRlZmF1bHRIZWFkZXJSb3dJbmRleCAtIGluZGV4IG9mIHRoZSByb3cgaW4gYHRoZWFkYCAoaW5jcmVtZW50ZWQgZnJvbSAwKSB0aGF0IHdpbGwgYmUgY29uc2lkZXJlZCBkZWZhdWx0IHRvIGhhdmUgYWN0aW9ucyBleGVjdXRlZCB1cG9uLlxyXG4gICAqIEByZXR1cm4gez9BcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBoZWFkZXIgY2VsbCBub2RlcyBvciBudWxsIGlmIGB0aGVhZGAgaXMgbm90IHNwZWNpZmllZFxyXG4gICAqICovXHJcbiAgc3RhdGljIGdldEhlYWRlckNlbGxzKHRoZWFkLGRlZmF1bHRIZWFkZXJSb3dJbmRleCl7XHJcbiAgICBpZih0aGVhZCl7XHJcbiAgICAgIGlmKGRlZmF1bHRIZWFkZXJSb3dJbmRleCE9bnVsbCl7XHJcbiAgICAgICAgbGV0IGRlZmF1bHRIZWFkZXJSb3cgPSBUYWJsZUNvbHVtbnMuZ2V0RGVmYXVsdEhlYWRlclJvdyh0aGVhZCxkZWZhdWx0SGVhZGVyUm93SW5kZXgpO1xyXG4gICAgICAgIGxldCBoZWFkZXJSb3dzID0gdGhlYWQuY2hpbGRyZW47XHJcbiAgICAgICAgbGV0IHJvd3NMZW5ndGggPSBoZWFkZXJSb3dzLmxlbmd0aDtcclxuICAgICAgICBsZXQgYWJzdHIgPSB7fTtcclxuICAgICAgICBmb3IobGV0IHI9MDtyPHJvd3NMZW5ndGg7cisrKXtcclxuICAgICAgICAgIGxldCByb3cgPSBoZWFkZXJSb3dzLml0ZW0ocik7XHJcbiAgICAgICAgICBsZXQgYXVnbWVudEluZGV4PTA7IC8vIGluZGV4IHRoYXQgd2lsbCBhY2NvdW50IGZvciBjb2xTcGFuIG9mIHVwcGVyIHJvd3MnIGNlbGxzXHJcbiAgICAgICAgICBbXS5zbGljZS5jYWxsKHJvdy5jaGlsZHJlbikuZm9yRWFjaCgoY2VsbCxpbmRleCk9PnsgLy9pdGVyYXRlIHRocm91Z2ggY2VsbHNcclxuICAgICAgICAgICAgZm9yKGxldCBycz0wOyByczw9Y2VsbC5yb3dTcGFuLTE7cnMrKyl7IC8vc3ByZWFkIGNlbGwgYWNyb3NzIGl0cyByb3dzcGFuXHJcbiAgICAgICAgICAgICAgbGV0IHJvd0EgPSBhYnN0cltyK3JzXSA9IGFic3RyW3IrcnNdIHx8IHt9OyAvL2NyZWF0ZSByb3cgaWYgbm90IGV4aXN0c1xyXG4gICAgICAgICAgICAgIGlmKCFyb3dBW2F1Z21lbnRJbmRleF0peyAvL2luc2VydCBjZWxsIGludG8gc2xvdCBpZiBub3QgZmlsbGVkXHJcbiAgICAgICAgICAgICAgICByb3dBW2F1Z21lbnRJbmRleF09Y2VsbDtcclxuICAgICAgICAgICAgICB9IGVsc2UgeyAvL2lmIGZpbGxlZCBsb29rIGZvciB0aGUgbmV4dCBlbXB0eSBiZWNhdXNlIHJvd3NwYW5uZWQgY29sdW1ucyBmaWxsIHRoZW0gaW4gYSBsaW5lYXIgd2F5XHJcbiAgICAgICAgICAgICAgICBsZXQgaT0wO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUodHJ1ZSl7XHJcbiAgICAgICAgICAgICAgICAgIGlmKCFyb3dBW2ldKXtcclxuICAgICAgICAgICAgICAgICAgICByb3dBW2ldPWNlbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgYXVnbWVudEluZGV4PWk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhdWdtZW50SW5kZXgrPWNlbGwuY29sU3BhbjtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhYnN0cltkZWZhdWx0SGVhZGVyUm93LmluZGV4XSkubWFwKGsgPT4gYWJzdHJbZGVmYXVsdEhlYWRlclJvdy5pbmRleF1ba10pXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGFibGVDb2x1bW5zLmdldEhlYWRlckNlbGxzOiBkZWZhdWx0SGVhZGVyUm93SW5kZXggaXMgbm90IHNwZWNpZmllZCBvciBpcyBub3QgYSBOdW1iZXInKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbiBhcnJheSBvZiBjb2x1bW5zIGZyb20gdGhlIHRhYmxlXHJcbiAgICogQHBhcmFtIHshSFRNTFRhYmxlRWxlbWVudH0gdGhlYWQgLSBzb3VyY2UgdGFibGUgaGVhZGVyXHJcbiAgICogQHBhcmFtIHshSFRNTFRhYmxlRWxlbWVudH0gcmVmVGhlYWQgLSByZWZlcmVuY2UgdGFibGUgaGVhZGVyIGZyb20gZmxvYXRpbmcgaGVhZGVyIGlmIGFueVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWZhdWx0SGVhZGVyUm93SW5kZXggLSBpbmRleCBvZiB0aGUgcm93IGluIGB0aGVhZGAgKGluY3JlbWVudGVkIGZyb20gMCkgdGhhdCB3aWxsIGJlIGNvbnNpZGVyZWQgZGVmYXVsdCB0byBoYXZlIGFjdGlvbnMgZXhlY3V0ZWQgdXBvbi5cclxuICAgKiBAcmV0dXJuIHs/QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgaGVhZGVyIGNlbGwgbm9kZXMgb3IgbnVsbCBpZiBgdGhlYWRgIGlzIG5vdCBzcGVjaWZpZWRcclxuICAgKiAqL1xyXG4gIHN0YXRpYyBjb21wdXRlQ29sdW1ucyh0aGVhZCxyZWZUaGVhZCxkZWZhdWx0SGVhZGVyUm93SW5kZXgpe1xyXG4gICAgbGV0IHRoZWFkQ2VsbHMgPSBUYWJsZUNvbHVtbnMuZ2V0SGVhZGVyQ2VsbHModGhlYWQsZGVmYXVsdEhlYWRlclJvd0luZGV4KTtcclxuICAgIGxldCByZWZUaGVhZENlbGxzID0gVGFibGVDb2x1bW5zLmdldEhlYWRlckNlbGxzKHJlZlRoZWFkLGRlZmF1bHRIZWFkZXJSb3dJbmRleCk7XHJcbiAgICBsZXQgcmVhbENvbHVtbkluZGV4PTA7XHJcbiAgICByZXR1cm4gdGhlYWRDZWxscy5tYXAoKGNlbGwsaW5kZXgpPT57XHJcbiAgICAgIGxldCBvYmogPSB7XHJcbiAgICAgICAgaW5kZXg6IHJlYWxDb2x1bW5JbmRleCxcclxuICAgICAgICB0aXRsZTogY2VsbC50ZXh0Q29udGVudCxcclxuICAgICAgICBjZWxsLFxyXG4gICAgICAgIGNvbFNwYW46Y2VsbC5jb2xTcGFuXHJcbiAgICAgIH07XHJcbiAgICAgIGlmKHJlZlRoZWFkQ2VsbHMhPW51bGwpe29iai5yZWZDZWxsID0gcmVmVGhlYWRDZWxsc1tpbmRleF19XHJcbiAgICAgIC8vIHdlIG5lZWQgdG8gaW5jcmVtZW50IHRoZSBjb2xzcGFuIG9ubHkgZm9yIGNvbHVtbnMgdGhhdCBmb2xsb3cgcm93aGVhZGVyIGJlY2F1c2UgdGhlIGJsb2NrIGlzIG5vdCBpbiBkYXRhLlxyXG4gICAgICByZWFsQ29sdW1uSW5kZXg9IHJlYWxDb2x1bW5JbmRleD4wPyhyZWFsQ29sdW1uSW5kZXggKyBjZWxsLmNvbFNwYW4pOnJlYWxDb2x1bW5JbmRleCsxO1xyXG4gICAgICByZXR1cm4gb2JqO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IFRhYmxlQ29sdW1ucztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yLXNvcnQtdGFibGUvc3JjL3RhYmxlLWNvbHVtbnMuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _tableColumns = __webpack_require__(11);\n\nvar _tableColumns2 = _interopRequireDefault(_tableColumns);\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\r\n * Created by IvanP on 07.09.2016.\r\n */\nwindow.Reportal = window.Reportal || {};\n_rReportalBase2.default.mixin(window.Reportal, {\n  TableColumns: _tableColumns2.default\n});\n\nexports.default = _tableColumns2.default;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItdGFibGUtY29sdW1ucy9zcmMvbWFpbi5qcz8xZjg4Il0sIm5hbWVzIjpbIndpbmRvdyIsIlJlcG9ydGFsIiwibWl4aW4iLCJUYWJsZUNvbHVtbnMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUdBOzs7O0FBQ0E7Ozs7OztBQUpBOzs7QUFNQUEsT0FBT0MsUUFBUCxHQUFrQkQsT0FBT0MsUUFBUCxJQUFtQixFQUFyQztBQUNBLHdCQUFhQyxLQUFiLENBQW1CRixPQUFPQyxRQUExQixFQUFtQztBQUNqQ0U7QUFEaUMsQ0FBbkMiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ3JlYXRlZCBieSBJdmFuUCBvbiAwNy4wOS4yMDE2LlxyXG4gKi9cclxuaW1wb3J0IFRhYmxlQ29sdW1ucyBmcm9tIFwiLi90YWJsZS1jb2x1bW5zXCI7XHJcbmltcG9ydCBSZXBvcnRhbEJhc2UgZnJvbSBcInItcmVwb3J0YWwtYmFzZVwiO1xyXG5cclxud2luZG93LlJlcG9ydGFsID0gd2luZG93LlJlcG9ydGFsIHx8IHt9O1xyXG5SZXBvcnRhbEJhc2UubWl4aW4od2luZG93LlJlcG9ydGFsLHtcclxuICBUYWJsZUNvbHVtbnMsXHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGFibGVDb2x1bW5zO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3ItdGFibGUtY29sdW1ucy9zcmMvbWFpbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 11 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Created by IvanP on 09.09.2016.\r\n */\n\nvar TableColumns = function () {\n  /**\r\n   * Creates an array of objects corresponding to the cells of `defaultHeaderRow`.\r\n   * @param {Object} options - options passed to configure the Sorting\r\n   * @param {HTMLTableElement} options.source - source table sorting will be applied to\r\n   * @param {HTMLTableElement} options.refSource - floating header if any\r\n   * @param {Number|Object} [options.defaultHeaderRow=-1] - index of the row in `thead` (incremented from 0) that will have sorting enabled for columns. If `-1` then last row.\r\n   * @return {{index:Number, title:String, colSpan:Number, cell: HTMLTableCellElement, ?refCell:HTMLTableCellElement}} - an array of objects that have this structure\r\n   * */\n  function TableColumns(options) {\n    _classCallCheck(this, TableColumns);\n\n    var source = options.source,\n        refSource = options.refSource,\n        _options$defaultHeade = options.defaultHeaderRow,\n        defaultHeaderRow = _options$defaultHeade === undefined ? -1 : _options$defaultHeade;\n\n    var thead = void 0,\n        refThead = void 0;\n    if (source) {\n      thead = TableColumns.getHeader(source);\n    } else {\n      throw new TypeError('`source` table is not specified, cannot create TableColumns');\n    }\n    if (refSource) {\n      refThead = TableColumns.getHeader(refSource);\n    }\n    return TableColumns.computeColumns(thead, refThead, defaultHeaderRow);\n  }\n\n  /**\r\n   * Gets a header\r\n   * @param {HTMLTableElement} source - source table headers are created for\r\n   * */\n\n\n  _createClass(TableColumns, null, [{\n    key: 'getHeader',\n    value: function getHeader(source) {\n      if (source && source.tagName == 'TABLE') {\n        var header = source.querySelector(\"thead\");\n        if (header && header.children.length > 0) {\n          return header;\n        } else {\n          throw new TypeError('`source` table has no header or rows');\n        }\n      } else {\n        throw new TypeError('`source` is not specified or is not a table');\n      }\n    }\n\n    /**\r\n     * Calculates defaultHeaderRow for a passed `thead`\r\n     * @param {!HTMLTableElement} thead - source table header\r\n     * @param {!Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n     * @return {{index:Number, row: HTMLTableRowElement}}\r\n     * */\n\n  }, {\n    key: 'getDefaultHeaderRow',\n    value: function getDefaultHeaderRow(thead, defaultHeaderRowIndex) {\n      // calculate default header row\n      var headerRows = thead.children,\n          headerRowIndex = defaultHeaderRowIndex == -1 ? headerRows.length + defaultHeaderRowIndex : defaultHeaderRowIndex;\n      return {\n        index: headerRowIndex,\n        row: headerRows.item(headerRowIndex)\n      };\n    }\n\n    /**\r\n     * Gets an array of header cell nodes from default header row\r\n     * @param {?HTMLTableElement} thead - source table header\r\n     * @param {!Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n     * @return {?Array} Returns an array of header cell nodes or null if `thead` is not specified\r\n     * */\n\n  }, {\n    key: 'getHeaderCells',\n    value: function getHeaderCells(thead, defaultHeaderRowIndex) {\n      if (thead) {\n        if (defaultHeaderRowIndex != null) {\n          var _ret = function () {\n            var defaultHeaderRow = TableColumns.getDefaultHeaderRow(thead, defaultHeaderRowIndex);\n            var headerRows = thead.children;\n            var rowsLength = headerRows.length;\n            var abstr = {};\n\n            var _loop = function _loop(r) {\n              var row = headerRows.item(r);\n              var augmentIndex = 0; // index that will account for colSpan of upper rows' cells\n              [].slice.call(row.children).forEach(function (cell, index) {\n                //iterate through cells\n                for (var rs = 0; rs <= cell.rowSpan - 1; rs++) {\n                  //spread cell across its rowspan\n                  var rowA = abstr[r + rs] = abstr[r + rs] || {}; //create row if not exists\n                  if (!rowA[augmentIndex]) {\n                    //insert cell into slot if not filled\n                    rowA[augmentIndex] = cell;\n                  } else {\n                    //if filled look for the next empty because rowspanned columns fill them in a linear way\n                    var i = 0;\n                    while (true) {\n                      if (!rowA[i]) {\n                        rowA[i] = cell;\n                        augmentIndex = i;\n                        break;\n                      }\n                      i++;\n                    }\n                  }\n                }\n                augmentIndex += cell.colSpan;\n              });\n            };\n\n            for (var r = 0; r < rowsLength; r++) {\n              _loop(r);\n            }\n            return {\n              v: Object.keys(abstr[defaultHeaderRow.index]).map(function (k) {\n                return abstr[defaultHeaderRow.index][k];\n              })\n            };\n          }();\n\n          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n        } else {\n          throw new TypeError('TableColumns.getHeaderCells: defaultHeaderRowIndex is not specified or is not a Number');\n        }\n      }\n      return null;\n    }\n\n    /**\r\n     * Gets an array of columns from the table\r\n     * @param {!HTMLTableElement} thead - source table header\r\n     * @param {!HTMLTableElement} refThead - reference table header from floating header if any\r\n     * @param {Number} defaultHeaderRowIndex - index of the row in `thead` (incremented from 0) that will be considered default to have actions executed upon.\r\n     * @return {?Array} Returns an array of header cell nodes or null if `thead` is not specified\r\n     * */\n\n  }, {\n    key: 'computeColumns',\n    value: function computeColumns(thead, refThead, defaultHeaderRowIndex) {\n      var theadCells = TableColumns.getHeaderCells(thead, defaultHeaderRowIndex);\n      var refTheadCells = TableColumns.getHeaderCells(refThead, defaultHeaderRowIndex);\n      var realColumnIndex = 0;\n      return theadCells.map(function (cell, index) {\n        var obj = {\n          index: realColumnIndex,\n          title: cell.textContent,\n          cell: cell,\n          colSpan: cell.colSpan\n        };\n        if (refTheadCells != null) {\n          obj.refCell = refTheadCells[index];\n        }\n        // we need to increment the colspan only for columns that follow rowheader because the block is not in data.\n        realColumnIndex = realColumnIndex > 0 ? realColumnIndex + cell.colSpan : realColumnIndex + 1;\n        return obj;\n      });\n    }\n  }]);\n\n  return TableColumns;\n}();\n\nexports.default = TableColumns;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItdGFibGUtY29sdW1ucy9zcmMvdGFibGUtY29sdW1ucy5qcz9kMjk4Il0sIm5hbWVzIjpbIlRhYmxlQ29sdW1ucyIsIm9wdGlvbnMiLCJzb3VyY2UiLCJyZWZTb3VyY2UiLCJkZWZhdWx0SGVhZGVyUm93IiwidGhlYWQiLCJyZWZUaGVhZCIsImdldEhlYWRlciIsIlR5cGVFcnJvciIsImNvbXB1dGVDb2x1bW5zIiwidGFnTmFtZSIsImhlYWRlciIsInF1ZXJ5U2VsZWN0b3IiLCJjaGlsZHJlbiIsImxlbmd0aCIsImRlZmF1bHRIZWFkZXJSb3dJbmRleCIsImhlYWRlclJvd3MiLCJoZWFkZXJSb3dJbmRleCIsImluZGV4Iiwicm93IiwiaXRlbSIsImdldERlZmF1bHRIZWFkZXJSb3ciLCJyb3dzTGVuZ3RoIiwiYWJzdHIiLCJyIiwiYXVnbWVudEluZGV4Iiwic2xpY2UiLCJjYWxsIiwiZm9yRWFjaCIsImNlbGwiLCJycyIsInJvd1NwYW4iLCJyb3dBIiwiaSIsImNvbFNwYW4iLCJPYmplY3QiLCJrZXlzIiwibWFwIiwiayIsInRoZWFkQ2VsbHMiLCJnZXRIZWFkZXJDZWxscyIsInJlZlRoZWFkQ2VsbHMiLCJyZWFsQ29sdW1uSW5kZXgiLCJvYmoiLCJ0aXRsZSIsInRleHRDb250ZW50IiwicmVmQ2VsbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7SUFJTUEsWTtBQUNKOzs7Ozs7OztBQVFBLHdCQUFZQyxPQUFaLEVBQW9CO0FBQUE7O0FBQUEsUUFDYkMsTUFEYSxHQUMyQkQsT0FEM0IsQ0FDYkMsTUFEYTtBQUFBLFFBQ05DLFNBRE0sR0FDMkJGLE9BRDNCLENBQ05FLFNBRE07QUFBQSxnQ0FDMkJGLE9BRDNCLENBQ0lHLGdCQURKO0FBQUEsUUFDSUEsZ0JBREoseUNBQ3FCLENBQUMsQ0FEdEI7O0FBRWxCLFFBQUlDLGNBQUo7QUFBQSxRQUFVQyxpQkFBVjtBQUNBLFFBQUdKLE1BQUgsRUFBVTtBQUFDRyxjQUFN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QSxpQkFBT1csT0FBT0MsSUFBUCxDQUFZYixNQUFNbkIsaUJBQWlCYyxLQUF2QixDQUFaLEVBQTJDbUIsR0FBM0MsQ0FBK0M7QUFBQSx1QkFBS2QsTUFBTW5CLGlCQUFpQmMsS0FBdkIsRUFBOEJvQixDQUE5QixDQUFMO0FBQUEsZUFBL0M7QUFBUDtBQTVCNkI7O0FBQUE7QUE2QjlCLFNBN0JELE1BNkJPO0FBQ0wsZ0JBQU0sSUFBSTlCLFNBQUosQ0FBYyx3RkFBZCxDQUFOO0FBQ0Q7QUFDRjtBQUNELGFBQU8sSUFBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7O21DQU9zQkgsSyxFQUFNQyxRLEVBQVNTLHFCLEVBQXNCO0FBQ3pELFVBQUl3QixhQUFhdkMsYUFBYXdDLGNBQWIsQ0FBNEJuQyxLQUE1QixFQUFrQ1UscUJBQWxDLENBQWpCO0FBQ0EsVUFBSTBCLGdCQUFnQnpDLGFBQWF3QyxjQUFiLENBQTRCbEMsUUFBNUIsRUFBcUNTLHFCQUFyQyxDQUFwQjtBQUNBLFVBQUkyQixrQkFBZ0IsQ0FBcEI7QUFDQSxhQUFPSCxXQUFXRixHQUFYLENBQWUsVUFBQ1IsSUFBRCxFQUFNWCxLQUFOLEVBQWM7QUFDbEMsWUFBSXlCLE1BQU07QUFDUnpCLGlCQUFPd0IsZUFEQztBQUVSRSxpQkFBT2YsS0FBS2dCLFdBRko7QUFHUmhCLG9CQUhRO0FBSVJLLG1CQUFRTCxLQUFLSztBQUpMLFNBQVY7QUFNQSxZQUFHTyxpQkFBZSxJQUFsQixFQUF1QjtBQUFDRSxjQUFJRyxPQUFKLEdBQWNMLGNBQWN2QixLQUFkLENBQWQ7QUFBbUM7QUFDM0Q7QUFDQXdCLDBCQUFpQkEsa0JBQWdCLENBQWhCLEdBQW1CQSxrQkFBa0JiLEtBQUtLLE9BQTFDLEdBQW1EUSxrQkFBZ0IsQ0FBcEY7QUFDQSxlQUFPQyxHQUFQO0FBQ0QsT0FYTSxDQUFQO0FBWUQ7Ozs7OztrQkFFWTNDLFkiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ3JlYXRlZCBieSBJdmFuUCBvbiAwOS4wOS4yMDE2LlxyXG4gKi9cclxuXHJcbmNsYXNzIFRhYmxlQ29sdW1uc3tcclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG9iamVjdHMgY29ycmVzcG9uZGluZyB0byB0aGUgY2VsbHMgb2YgYGRlZmF1bHRIZWFkZXJSb3dgLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBwYXNzZWQgdG8gY29uZmlndXJlIHRoZSBTb3J0aW5nXHJcbiAgICogQHBhcmFtIHtIVE1MVGFibGVFbGVtZW50fSBvcHRpb25zLnNvdXJjZSAtIHNvdXJjZSB0YWJsZSBzb3J0aW5nIHdpbGwgYmUgYXBwbGllZCB0b1xyXG4gICAqIEBwYXJhbSB7SFRNTFRhYmxlRWxlbWVudH0gb3B0aW9ucy5yZWZTb3VyY2UgLSBmbG9hdGluZyBoZWFkZXIgaWYgYW55XHJcbiAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbb3B0aW9ucy5kZWZhdWx0SGVhZGVyUm93PS0xXSAtIGluZGV4IG9mIHRoZSByb3cgaW4gYHRoZWFkYCAoaW5jcmVtZW50ZWQgZnJvbSAwKSB0aGF0IHdpbGwgaGF2ZSBzb3J0aW5nIGVuYWJsZWQgZm9yIGNvbHVtbnMuIElmIGAtMWAgdGhlbiBsYXN0IHJvdy5cclxuICAgKiBAcmV0dXJuIHt7aW5kZXg6TnVtYmVyLCB0aXRsZTpTdHJpbmcsIGNvbFNwYW46TnVtYmVyLCBjZWxsOiBIVE1MVGFibGVDZWxsRWxlbWVudCwgP3JlZkNlbGw6SFRNTFRhYmxlQ2VsbEVsZW1lbnR9fSAtIGFuIGFycmF5IG9mIG9iamVjdHMgdGhhdCBoYXZlIHRoaXMgc3RydWN0dXJlXHJcbiAgICogKi9cclxuICBjb25zdHJ1Y3RvcihvcHRpb25zKXtcclxuICAgIGxldCB7c291cmNlLHJlZlNvdXJjZSxkZWZhdWx0SGVhZGVyUm93PS0xfSA9IG9wdGlvbnM7XHJcbiAgICBsZXQgdGhlYWQscmVmVGhlYWQ7XHJcbiAgICBpZihzb3VyY2Upe3RoZWFkPVRhYmxlQ29sdW1ucy5nZXRIZWFkZXIoc291cmNlKX0gZWxzZSB7dGhyb3cgbmV3IFR5cGVFcnJvcignYHNvdXJjZWAgdGFibGUgaXMgbm90IHNwZWNpZmllZCwgY2Fubm90IGNyZWF0ZSBUYWJsZUNvbHVtbnMnKX1cclxuICAgIGlmKHJlZlNvdXJjZSl7cmVmVGhlYWQ9VGFibGVDb2x1bW5zLmdldEhlYWRlcihyZWZTb3VyY2UpfVxyXG4gICAgcmV0dXJuIFRhYmxlQ29sdW1ucy5jb21wdXRlQ29sdW1ucyh0aGVhZCxyZWZUaGVhZCxkZWZhdWx0SGVhZGVyUm93KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYSBoZWFkZXJcclxuICAgKiBAcGFyYW0ge0hUTUxUYWJsZUVsZW1lbnR9IHNvdXJjZSAtIHNvdXJjZSB0YWJsZSBoZWFkZXJzIGFyZSBjcmVhdGVkIGZvclxyXG4gICAqICovXHJcbiAgc3RhdGljIGdldEhlYWRlcihzb3VyY2Upe1xyXG4gICAgaWYoc291cmNlICYmIHNvdXJjZS50YWdOYW1lID09ICdUQUJMRScpe1xyXG4gICAgICBsZXQgaGVhZGVyID0gc291cmNlLnF1ZXJ5U2VsZWN0b3IoXCJ0aGVhZFwiKTtcclxuICAgICAgaWYoaGVhZGVyICYmIGhlYWRlci5jaGlsZHJlbi5sZW5ndGg+MCkge1xyXG4gICAgICAgIHJldHVybiBoZWFkZXI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYHNvdXJjZWAgdGFibGUgaGFzIG5vIGhlYWRlciBvciByb3dzJyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Bzb3VyY2VgIGlzIG5vdCBzcGVjaWZpZWQgb3IgaXMgbm90IGEgdGFibGUnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgZGVmYXVsdEhlYWRlclJvdyBmb3IgYSBwYXNzZWQgYHRoZWFkYFxyXG4gICAqIEBwYXJhbSB7IUhUTUxUYWJsZUVsZW1lbnR9IHRoZWFkIC0gc291cmNlIHRhYmxlIGhlYWRlclxyXG4gICAqIEBwYXJhbSB7IU51bWJlcn0gZGVmYXVsdEhlYWRlclJvd0luZGV4IC0gaW5kZXggb2YgdGhlIHJvdyBpbiBgdGhlYWRgIChpbmNyZW1lbnRlZCBmcm9tIDApIHRoYXQgd2lsbCBiZSBjb25zaWRlcmVkIGRlZmF1bHQgdG8gaGF2ZSBhY3Rpb25zIGV4ZWN1dGVkIHVwb24uXHJcbiAgICogQHJldHVybiB7e2luZGV4Ok51bWJlciwgcm93OiBIVE1MVGFibGVSb3dFbGVtZW50fX1cclxuICAgKiAqL1xyXG4gIHN0YXRpYyBnZXREZWZhdWx0SGVhZGVyUm93KHRoZWFkLGRlZmF1bHRIZWFkZXJSb3dJbmRleCl7XHJcbiAgICAvLyBjYWxjdWxhdGUgZGVmYXVsdCBoZWFkZXIgcm93XHJcbiAgICBsZXQgaGVhZGVyUm93cyA9IHRoZWFkLmNoaWxkcmVuLFxyXG4gICAgICBoZWFkZXJSb3dJbmRleCA9IGRlZmF1bHRIZWFkZXJSb3dJbmRleD09LTEgPyBoZWFkZXJSb3dzLmxlbmd0aCArIGRlZmF1bHRIZWFkZXJSb3dJbmRleCA6IGRlZmF1bHRIZWFkZXJSb3dJbmRleDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGluZGV4OmhlYWRlclJvd0luZGV4LFxyXG4gICAgICByb3c6aGVhZGVyUm93cy5pdGVtKGhlYWRlclJvd0luZGV4KVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYW4gYXJyYXkgb2YgaGVhZGVyIGNlbGwgbm9kZXMgZnJvbSBkZWZhdWx0IGhlYWRlciByb3dcclxuICAgKiBAcGFyYW0gez9IVE1MVGFibGVFbGVtZW50fSB0aGVhZCAtIHNvdXJjZSB0YWJsZSBoZWFkZXJcclxuICAgKiBAcGFyYW0geyFOdW1iZXJ9IGRlZmF1bHRIZWFkZXJSb3dJbmRleCAtIGluZGV4IG9mIHRoZSByb3cgaW4gYHRoZWFkYCAoaW5jcmVtZW50ZWQgZnJvbSAwKSB0aGF0IHdpbGwgYmUgY29uc2lkZXJlZCBkZWZhdWx0IHRvIGhhdmUgYWN0aW9ucyBleGVjdXRlZCB1cG9uLlxyXG4gICAqIEByZXR1cm4gez9BcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBoZWFkZXIgY2VsbCBub2RlcyBvciBudWxsIGlmIGB0aGVhZGAgaXMgbm90IHNwZWNpZmllZFxyXG4gICAqICovXHJcbiAgc3RhdGljIGdldEhlYWRlckNlbGxzKHRoZWFkLGRlZmF1bHRIZWFkZXJSb3dJbmRleCl7XHJcbiAgICBpZih0aGVhZCl7XHJcbiAgICAgIGlmKGRlZmF1bHRIZWFkZXJSb3dJbmRleCE9bnVsbCl7XHJcbiAgICAgICAgbGV0IGRlZmF1bHRIZWFkZXJSb3cgPSBUYWJsZUNvbHVtbnMuZ2V0RGVmYXVsdEhlYWRlclJvdyh0aGVhZCxkZWZhdWx0SGVhZGVyUm93SW5kZXgpO1xyXG4gICAgICAgIGxldCBoZWFkZXJSb3dzID0gdGhlYWQuY2hpbGRyZW47XHJcbiAgICAgICAgbGV0IHJvd3NMZW5ndGggPSBoZWFkZXJSb3dzLmxlbmd0aDtcclxuICAgICAgICBsZXQgYWJzdHIgPSB7fTtcclxuICAgICAgICBmb3IobGV0IHI9MDtyPHJvd3NMZW5ndGg7cisrKXtcclxuICAgICAgICAgIGxldCByb3cgPSBoZWFkZXJSb3dzLml0ZW0ocik7XHJcbiAgICAgICAgICBsZXQgYXVnbWVudEluZGV4PTA7IC8vIGluZGV4IHRoYXQgd2lsbCBhY2NvdW50IGZvciBjb2xTcGFuIG9mIHVwcGVyIHJvd3MnIGNlbGxzXHJcbiAgICAgICAgICBbXS5zbGljZS5jYWxsKHJvdy5jaGlsZHJlbikuZm9yRWFjaCgoY2VsbCxpbmRleCk9PnsgLy9pdGVyYXRlIHRocm91Z2ggY2VsbHNcclxuICAgICAgICAgICAgZm9yKGxldCBycz0wOyByczw9Y2VsbC5yb3dTcGFuLTE7cnMrKyl7IC8vc3ByZWFkIGNlbGwgYWNyb3NzIGl0cyByb3dzcGFuXHJcbiAgICAgICAgICAgICAgbGV0IHJvd0EgPSBhYnN0cltyK3JzXSA9IGFic3RyW3IrcnNdIHx8IHt9OyAvL2NyZWF0ZSByb3cgaWYgbm90IGV4aXN0c1xyXG4gICAgICAgICAgICAgIGlmKCFyb3dBW2F1Z21lbnRJbmRleF0peyAvL2luc2VydCBjZWxsIGludG8gc2xvdCBpZiBub3QgZmlsbGVkXHJcbiAgICAgICAgICAgICAgICByb3dBW2F1Z21lbnRJbmRleF09Y2VsbDtcclxuICAgICAgICAgICAgICB9IGVsc2UgeyAvL2lmIGZpbGxlZCBsb29rIGZvciB0aGUgbmV4dCBlbXB0eSBiZWNhdXNlIHJvd3NwYW5uZWQgY29sdW1ucyBmaWxsIHRoZW0gaW4gYSBsaW5lYXIgd2F5XHJcbiAgICAgICAgICAgICAgICBsZXQgaT0wO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUodHJ1ZSl7XHJcbiAgICAgICAgICAgICAgICAgIGlmKCFyb3dBW2ldKXtcclxuICAgICAgICAgICAgICAgICAgICByb3dBW2ldPWNlbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgYXVnbWVudEluZGV4PWk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhdWdtZW50SW5kZXgrPWNlbGwuY29sU3BhbjtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhYnN0cltkZWZhdWx0SGVhZGVyUm93LmluZGV4XSkubWFwKGsgPT4gYWJzdHJbZGVmYXVsdEhlYWRlclJvdy5pbmRleF1ba10pXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGFibGVDb2x1bW5zLmdldEhlYWRlckNlbGxzOiBkZWZhdWx0SGVhZGVyUm93SW5kZXggaXMgbm90IHNwZWNpZmllZCBvciBpcyBub3QgYSBOdW1iZXInKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbiBhcnJheSBvZiBjb2x1bW5zIGZyb20gdGhlIHRhYmxlXHJcbiAgICogQHBhcmFtIHshSFRNTFRhYmxlRWxlbWVudH0gdGhlYWQgLSBzb3VyY2UgdGFibGUgaGVhZGVyXHJcbiAgICogQHBhcmFtIHshSFRNTFRhYmxlRWxlbWVudH0gcmVmVGhlYWQgLSByZWZlcmVuY2UgdGFibGUgaGVhZGVyIGZyb20gZmxvYXRpbmcgaGVhZGVyIGlmIGFueVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWZhdWx0SGVhZGVyUm93SW5kZXggLSBpbmRleCBvZiB0aGUgcm93IGluIGB0aGVhZGAgKGluY3JlbWVudGVkIGZyb20gMCkgdGhhdCB3aWxsIGJlIGNvbnNpZGVyZWQgZGVmYXVsdCB0byBoYXZlIGFjdGlvbnMgZXhlY3V0ZWQgdXBvbi5cclxuICAgKiBAcmV0dXJuIHs/QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgaGVhZGVyIGNlbGwgbm9kZXMgb3IgbnVsbCBpZiBgdGhlYWRgIGlzIG5vdCBzcGVjaWZpZWRcclxuICAgKiAqL1xyXG4gIHN0YXRpYyBjb21wdXRlQ29sdW1ucyh0aGVhZCxyZWZUaGVhZCxkZWZhdWx0SGVhZGVyUm93SW5kZXgpe1xyXG4gICAgbGV0IHRoZWFkQ2VsbHMgPSBUYWJsZUNvbHVtbnMuZ2V0SGVhZGVyQ2VsbHModGhlYWQsZGVmYXVsdEhlYWRlclJvd0luZGV4KTtcclxuICAgIGxldCByZWZUaGVhZENlbGxzID0gVGFibGVDb2x1bW5zLmdldEhlYWRlckNlbGxzKHJlZlRoZWFkLGRlZmF1bHRIZWFkZXJSb3dJbmRleCk7XHJcbiAgICBsZXQgcmVhbENvbHVtbkluZGV4PTA7XHJcbiAgICByZXR1cm4gdGhlYWRDZWxscy5tYXAoKGNlbGwsaW5kZXgpPT57XHJcbiAgICAgIGxldCBvYmogPSB7XHJcbiAgICAgICAgaW5kZXg6IHJlYWxDb2x1bW5JbmRleCxcclxuICAgICAgICB0aXRsZTogY2VsbC50ZXh0Q29udGVudCxcclxuICAgICAgICBjZWxsLFxyXG4gICAgICAgIGNvbFNwYW46Y2VsbC5jb2xTcGFuXHJcbiAgICAgIH07XHJcbiAgICAgIGlmKHJlZlRoZWFkQ2VsbHMhPW51bGwpe29iai5yZWZDZWxsID0gcmVmVGhlYWRDZWxsc1tpbmRleF19XHJcbiAgICAgIC8vIHdlIG5lZWQgdG8gaW5jcmVtZW50IHRoZSBjb2xzcGFuIG9ubHkgZm9yIGNvbHVtbnMgdGhhdCBmb2xsb3cgcm93aGVhZGVyIGJlY2F1c2UgdGhlIGJsb2NrIGlzIG5vdCBpbiBkYXRhLlxyXG4gICAgICByZWFsQ29sdW1uSW5kZXg9IHJlYWxDb2x1bW5JbmRleD4wPyhyZWFsQ29sdW1uSW5kZXggKyBjZWxsLmNvbFNwYW4pOnJlYWxDb2x1bW5JbmRleCsxO1xyXG4gICAgICByZXR1cm4gb2JqO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IFRhYmxlQ29sdW1ucztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yLXRhYmxlLWNvbHVtbnMvc3JjL3RhYmxlLWNvbHVtbnMuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TableFloatingHeaderStyle = __webpack_require__(17);\n\n/**\r\n * FixedHeader class enables a fixed header appear on tables that have `.reportal-fixed-header` class when the table header is scrolled under address bar.\r\n */\n\nvar TableFloatingHeader = function () {\n  /**\r\n   * @param {HTMLTableElement} source - source table that needs a cloned header\r\n   * */\n  function TableFloatingHeader(source) {\n    var _this = this;\n\n    _classCallCheck(this, TableFloatingHeader);\n\n    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) == undefined || source.tagName != 'TABLE') {\n      throw new TypeError('`source` must be defined and must be a table');\n    }\n\n    TableFloatingHeader.wrapTable(source);\n\n    /**\r\n     *  The cloned floating header without TBODY\r\n     *  @type {HTMLTableElement}\r\n     *  @memberOf TableFloatingHeader\r\n     *  */\n    this.header = TableFloatingHeader.cloneHeader(source);\n\n    /**\r\n     *  The source table\r\n     *  @type {HTMLTableElement}\r\n     *  @memberOf TableFloatingHeader\r\n     *  */\n    this.source = source;\n    /**\r\n     *  Visibility status of the table\r\n     *  @type {Boolean}\r\n     *  @memberOf TableFloatingHeader\r\n     *  */\n    this.visible = false;\n\n    this._meta = {\n      lastScrollY: 0,\n      sourceTHEAD: source.querySelector('thead'),\n      ticking: false\n    };\n\n    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n\n    this.resizeFixed();\n\n    window.addEventListener(\"resize\", function () {\n      return _this.resizeFixed.call(_this);\n    }, false); // attach a resize listener to resize the header\n    window.addEventListener(\"scroll\", function () {\n      return _this.scrollFixed.call(_this);\n    }, false); // attach a resize listener to resize the header\n  }\n\n  /**\r\n   * calculates offset height of the table\r\n   * @param {HTMLTableElement} source - source table\r\n   * */\n\n\n  _createClass(TableFloatingHeader, [{\n    key: 'requestTick',\n\n\n    /**\r\n     * function that polls the callback\r\n     * @param {Function} callback - function that's going to be passed to `requestAnimationFrame` for execution\r\n     * */\n    value: function requestTick(callback) {\n      if (!this._meta.ticking) {\n        requestAnimationFrame(callback);\n        this._meta.ticking = true;\n      }\n    }\n  }, {\n    key: 'resizeFixed',\n\n\n    /**\r\n     * Calculates widths for all columns in the fixed header based on the `source`\r\n     * */\n    value: function resizeFixed() {\n      this.requestTick(TableFloatingHeader._resizeCallback.bind(this));\n    }\n  }, {\n    key: 'scrollFixed',\n\n\n    /**\r\n     * Displays a fixed header when the table header is scrolled off the screen\r\n     * */\n    value: function scrollFixed() {\n      this._meta.lastScrollY = window.pageYOffset;\n      this.requestTick(TableFloatingHeader._scrollCallback.bind(this));\n    }\n  }], [{\n    key: 'calcOffsetHeight',\n    value: function calcOffsetHeight(source) {\n      this._meta.tableOffsetTop = source.parentNode.offsetTop;\n      this._meta.tableOffsetBottom = source.parentNode.offsetTop + source.offsetHeight - this._meta.sourceTHEAD.offsetHeight;\n    }\n\n    /**\r\n     * Event reporting that a header is visible\r\n     * @event TableFloatingHeader~reportal-fixed-header-visible\r\n     */\n\n    /**\r\n     * Event reporting that a header is hidden\r\n     * @event TableFloatingHeader~reportal-fixed-header-hidden\r\n     */\n\n    /**\r\n     * sets visibility of the table\r\n     * @param {HTMLTableElement} source - source table\r\n     * @param {HTMLTableElement} header - cloned table with header only\r\n     * @param {Boolean} visible - visibility status\r\n     * @fires TableFloatingHeader~reportal-fixed-header-visible\r\n     * @fires TableFloatingHeader~reportal-fixed-header-visible\r\n     * */\n\n  }, {\n    key: 'setVisibility',\n    value: function setVisibility(source, header, visible) {\n      if (visible) {\n        header.style.display = 'table';\n        source.dispatchEvent(_rReportalBase2.default.newEvent('reportal-fixed-header-visible'));\n      } else {\n        header.style.display = 'none';\n        source.dispatchEvent(_rReportalBase2.default.newEvent('reportal-fixed-header-hidden'));\n      }\n    }\n\n    /**\r\n     * wraps the `source` table into a `div.aggregatedTableContainer`\r\n     * */\n\n  }, {\n    key: 'wrapTable',\n    value: function wrapTable(source) {\n      var wrapper = document.createElement('div');\n      wrapper.classList.add('aggregatedTableContainer');\n      source.parentNode.appendChild(wrapper);\n      wrapper.appendChild(source);\n    }\n\n    /**\r\n     * clones header of `source` table and appends to wrapper\r\n     * */\n\n  }, {\n    key: 'cloneHeader',\n    value: function cloneHeader(source) {\n      var header = source.cloneNode(true);\n      header.classList.add('fixed');\n      source.parentNode.appendChild(header);\n      [].slice.call(header.children).forEach(function (child) {\n        if (child.nodeName == 'TBODY') {\n          header.removeChild(child);\n        }\n      });\n      return header;\n    }\n  }, {\n    key: '_resizeCallback',\n    value: function _resizeCallback() {\n      var initialHeader = this._meta.sourceTHEAD.querySelectorAll('tr>*'),\n          clonedHeader = this.header.querySelectorAll('thead>tr>*'),\n          headerWidth = this.source.offsetWidth + 'px',\n          widths = [];\n      // do reflow\n      for (var i = 0; i < initialHeader.length; i++) {\n        widths.push(initialHeader[i].offsetWidth);\n      }\n      //do repaint\n      for (var c = 0; c < clonedHeader.length; c++) {\n        clonedHeader[c].style.width = widths[c] + 'px';\n      }\n      this.header.style.width = headerWidth;\n\n      TableFloatingHeader.calcOffsetHeight.call(this, this.source); //recalc height of the table after reflow\n      this._meta.ticking = false;\n      this.scrollFixed(); // to compensate top offset in case after resize the table is less in height and top has changed\n    }\n  }, {\n    key: '_scrollCallback',\n    value: function _scrollCallback() {\n      var offset = this._meta.lastScrollY,\n          tableOffsetTop = this._meta.tableOffsetTop,\n          tableOffsetBottom = this._meta.tableOffsetBottom;\n      if ((offset < tableOffsetTop || offset > tableOffsetBottom) && this.visible) {\n        this.visible = false;\n        TableFloatingHeader.setVisibility(this.source, this.header, false);\n      } else if (offset >= tableOffsetTop && offset <= tableOffsetBottom) {\n        this.header.style.top = offset - tableOffsetTop + 'px';\n        if (!this.visible) {\n          this.visible = true;\n          TableFloatingHeader.setVisibility(this.source, this.header, true);\n        }\n      }\n      this._meta.ticking = false;\n    }\n  }]);\n\n  return TableFloatingHeader;\n}();\n\nexports.default = TableFloatingHeader;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItdGFibGUtZmxvYXRpbmctaGVhZGVyL3NyYy90YWJsZS1mbG9hdGluZy1oZWFkZXIuanM/NzdhNyJdLCJuYW1lcyI6WyJUYWJsZUZsb2F0aW5nSGVhZGVyU3R5bGUiLCJyZXF1aXJlIiwiVGFibGVGbG9hdGluZ0hlYWRlciIsInNvdXJjZSIsInVuZGVmaW5lZCIsInRhZ05hbWUiLCJUeXBlRXJyb3IiLCJ3cmFwVGFibGUiLCJoZWFkZXIiLCJjbG9uZUhlYWRlciIsInZpc2libGUiLCJfbWV0YSIsImxhc3RTY3JvbGxZIiwic291cmNlVEhFQUQiLCJxdWVyeVNlbGVjdG9yIiwidGlja2luZyIsIndpbmRvdyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicmVzaXplRml4ZWQiLCJhZGRFdmVudExpc3RlbmVyIiwiY2FsbCIsInNjcm9sbEZpeGVkIiwiY2FsbGJhY2siLCJyZXF1ZXN0VGljayIsIl9yZXNpemVDYWxsYmFjayIsImJpbmQiLCJwYWdlWU9mZnNldCIsIl9zY3JvbGxDYWxsYmFjayIsInRhYmxlT2Zmc2V0VG9wIiwicGFyZW50Tm9kZSIsIm9mZnNldFRvcCIsInRhYmxlT2Zmc2V0Qm90dG9tIiwib2Zmc2V0SGVpZ2h0Iiwic3R5bGUiLCJkaXNwbGF5IiwiZGlzcGF0Y2hFdmVudCIsIm5ld0V2ZW50Iiwid3JhcHBlciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTGlzdCIsImFkZCIsImFwcGVuZENoaWxkIiwiY2xvbmVOb2RlIiwic2xpY2UiLCJjaGlsZHJlbiIsImZvckVhY2giLCJjaGlsZCIsIm5vZGVOYW1lIiwicmVtb3ZlQ2hpbGQiLCJpbml0aWFsSGVhZGVyIiwicXVlcnlTZWxlY3RvckFsbCIsImNsb25lZEhlYWRlciIsImhlYWRlcldpZHRoIiwib2Zmc2V0V2lkdGgiLCJ3aWR0aHMiLCJpIiwibGVuZ3RoIiwicHVzaCIsImMiLCJ3aWR0aCIsImNhbGNPZmZzZXRIZWlnaHQiLCJvZmZzZXQiLCJzZXRWaXNpYmlsaXR5IiwidG9wIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBRUEsSUFBSUEsMkJBQTJCLG1CQUFBQyxDQUFRLEVBQVIsQ0FBL0I7O0FBRUE7Ozs7SUFHTUMsbUI7QUFDSjs7O0FBR0EsK0JBQVlDLE1BQVosRUFBbUI7QUFBQTs7QUFBQTs7QUFDakIsUUFBRyxRQUFPQSxNQUFQLHlDQUFPQSxNQUFQLE1BQWlCQyxTQUFqQixJQUE4QkQsT0FBT0UsT0FBUCxJQUFrQixPQUFuRCxFQUEyRDtBQUN6RCxZQUFNLElBQUlDLFNBQUosQ0FBYyw4Q0FBZCxDQUFOO0FBQ0Q7O0FBRURKLHdCQUFvQkssU0FBcEIsQ0FBOEJKLE1BQTlCOztBQUVBOzs7OztBQUtBLFNBQUtLLE1BQUwsR0FBZU4sb0JBQW9CTyxXQUFwQixDQUFnQ04sTUFBaEMsQ0FBZjs7QUFFQTs7Ozs7QUFLQSxTQUFLQSxNQUFMLEdBQWNBLE1BQWQ7QUFDQTs7Ozs7QUFLQSxTQUFLTyxPQUFMLEdBQWUsS0FBZjs7QUFFQSxTQUFLQyxLQUFMLEdBQWE7QUFDWEMsbUJBQVksQ0FERDtBQUVYQyxtQkFBYVYsT0FBT1csYUFBUCxDQUFxQixPQUFyQixDQUZGO0FBR1hDLGVBQVE7QUFIRyxLQUFiOztBQU1BQyxXQUFPQyxxQkFBUCxHQUErQkQsT0FBT0MscUJBQVAsSUFBZ0NELE9BQU9FLHdCQUF2QyxJQUFtRUYsT0FBT0csMkJBQTFFLElBQXlHSCxPQUFPSSx1QkFBL0k7O0FBRUEsU0FBS0MsV0FBTDs7QUFFQUwsV0FBT00sZ0JBQVAsQ0FBd0IsUUFBeEIsRUFBa0M7QUFBQSxhQUFJLE1BQUtELFdBQUwsQ0FBaUJFLElBQWpCLE9BQUo7QUFBQSxLQUFsQyxFQUFtRSxLQUFuRSxFQXJDaUIsQ0FxQzBEO0FBQzNFUCxXQUFPTSxnQkFBUCxDQUF3QixRQUF4QixFQUFr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LFlBQUcsQ0FBQyxLQUFLckIsT0FBVCxFQUFpQjtBQUNmLGVBQUtBLE9BQUwsR0FBYSxJQUFiO0FBQ0FSLDhCQUFvQmdFLGFBQXBCLENBQWtDLEtBQUsvRCxNQUF2QyxFQUE4QyxLQUFLSyxNQUFuRCxFQUEwRCxJQUExRDtBQUNEO0FBQ0Y7QUFDRCxXQUFLRyxLQUFMLENBQVdJLE9BQVgsR0FBbUIsS0FBbkI7QUFDRDs7Ozs7O2tCQWFZYixtQiIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZXBvcnRhbEJhc2UgZnJvbSBcInItcmVwb3J0YWwtYmFzZVwiO1xyXG5cclxudmFyIFRhYmxlRmxvYXRpbmdIZWFkZXJTdHlsZSA9IHJlcXVpcmUoJy4vdGFibGUtZmxvYXRpbmctaGVhZGVyLXN0eWxlcy5jc3MnKTtcclxuXHJcbi8qKlxyXG4gKiBGaXhlZEhlYWRlciBjbGFzcyBlbmFibGVzIGEgZml4ZWQgaGVhZGVyIGFwcGVhciBvbiB0YWJsZXMgdGhhdCBoYXZlIGAucmVwb3J0YWwtZml4ZWQtaGVhZGVyYCBjbGFzcyB3aGVuIHRoZSB0YWJsZSBoZWFkZXIgaXMgc2Nyb2xsZWQgdW5kZXIgYWRkcmVzcyBiYXIuXHJcbiAqL1xyXG5jbGFzcyBUYWJsZUZsb2F0aW5nSGVhZGVyIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge0hUTUxUYWJsZUVsZW1lbnR9IHNvdXJjZSAtIHNvdXJjZSB0YWJsZSB0aGF0IG5lZWRzIGEgY2xvbmVkIGhlYWRlclxyXG4gICAqICovXHJcbiAgY29uc3RydWN0b3Ioc291cmNlKXtcclxuICAgIGlmKHR5cGVvZiBzb3VyY2UgPT0gdW5kZWZpbmVkIHx8IHNvdXJjZS50YWdOYW1lICE9ICdUQUJMRScpe1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgc291cmNlYCBtdXN0IGJlIGRlZmluZWQgYW5kIG11c3QgYmUgYSB0YWJsZScpXHJcbiAgICB9XHJcblxyXG4gICAgVGFibGVGbG9hdGluZ0hlYWRlci53cmFwVGFibGUoc291cmNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqICBUaGUgY2xvbmVkIGZsb2F0aW5nIGhlYWRlciB3aXRob3V0IFRCT0RZXHJcbiAgICAgKiAgQHR5cGUge0hUTUxUYWJsZUVsZW1lbnR9XHJcbiAgICAgKiAgQG1lbWJlck9mIFRhYmxlRmxvYXRpbmdIZWFkZXJcclxuICAgICAqICAqL1xyXG4gICAgdGhpcy5oZWFkZXIgID0gVGFibGVGbG9hdGluZ0hlYWRlci5jbG9uZUhlYWRlcihzb3VyY2UpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBzb3VyY2UgdGFibGVcclxuICAgICAqICBAdHlwZSB7SFRNTFRhYmxlRWxlbWVudH1cclxuICAgICAqICBAbWVtYmVyT2YgVGFibGVGbG9hdGluZ0hlYWRlclxyXG4gICAgICogICovXHJcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgIC8qKlxyXG4gICAgICogIFZpc2liaWxpdHkgc3RhdHVzIG9mIHRoZSB0YWJsZVxyXG4gICAgICogIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogIEBtZW1iZXJPZiBUYWJsZUZsb2F0aW5nSGVhZGVyXHJcbiAgICAgKiAgKi9cclxuICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuX21ldGEgPSB7XHJcbiAgICAgIGxhc3RTY3JvbGxZOjAsXHJcbiAgICAgIHNvdXJjZVRIRUFEOiBzb3VyY2UucXVlcnlTZWxlY3RvcigndGhlYWQnKSxcclxuICAgICAgdGlja2luZzpmYWxzZVxyXG4gICAgfTtcclxuXHJcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xyXG5cclxuICAgIHRoaXMucmVzaXplRml4ZWQoKTtcclxuXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCAoKT0+dGhpcy5yZXNpemVGaXhlZC5jYWxsKHRoaXMpLCBmYWxzZSk7IC8vIGF0dGFjaCBhIHJlc2l6ZSBsaXN0ZW5lciB0byByZXNpemUgdGhlIGhlYWRlclxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgKCk9PnRoaXMuc2Nyb2xsRml4ZWQuY2FsbCh0aGlzKSwgZmFsc2UpOyAvLyBhdHRhY2ggYSByZXNpemUgbGlzdGVuZXIgdG8gcmVzaXplIHRoZSBoZWFkZXJcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGNhbGN1bGF0ZXMgb2Zmc2V0IGhlaWdodCBvZiB0aGUgdGFibGVcclxuICAgKiBAcGFyYW0ge0hUTUxUYWJsZUVsZW1lbnR9IHNvdXJjZSAtIHNvdXJjZSB0YWJsZVxyXG4gICAqICovXHJcbiAgc3RhdGljIGNhbGNPZmZzZXRIZWlnaHQoc291cmNlKXtcclxuICAgIHRoaXMuX21ldGEudGFibGVPZmZzZXRUb3AgPSBzb3VyY2UucGFyZW50Tm9kZS5vZmZzZXRUb3A7XHJcbiAgICB0aGlzLl9tZXRhLnRhYmxlT2Zmc2V0Qm90dG9tID0gc291cmNlLnBhcmVudE5vZGUub2Zmc2V0VG9wICsgc291cmNlLm9mZnNldEhlaWdodCAtIHRoaXMuX21ldGEuc291cmNlVEhFQUQub2Zmc2V0SGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRXZlbnQgcmVwb3J0aW5nIHRoYXQgYSBoZWFkZXIgaXMgdmlzaWJsZVxyXG4gICAqIEBldmVudCBUYWJsZUZsb2F0aW5nSGVhZGVyfnJlcG9ydGFsLWZpeGVkLWhlYWRlci12aXNpYmxlXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEV2ZW50IHJlcG9ydGluZyB0aGF0IGEgaGVhZGVyIGlzIGhpZGRlblxyXG4gICAqIEBldmVudCBUYWJsZUZsb2F0aW5nSGVhZGVyfnJlcG9ydGFsLWZpeGVkLWhlYWRlci1oaWRkZW5cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogc2V0cyB2aXNpYmlsaXR5IG9mIHRoZSB0YWJsZVxyXG4gICAqIEBwYXJhbSB7SFRNTFRhYmxlRWxlbWVudH0gc291cmNlIC0gc291cmNlIHRhYmxlXHJcbiAgICogQHBhcmFtIHtIVE1MVGFibGVFbGVtZW50fSBoZWFkZXIgLSBjbG9uZWQgdGFibGUgd2l0aCBoZWFkZXIgb25seVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSAtIHZpc2liaWxpdHkgc3RhdHVzXHJcbiAgICogQGZpcmVzIFRhYmxlRmxvYXRpbmdIZWFkZXJ+cmVwb3J0YWwtZml4ZWQtaGVhZGVyLXZpc2libGVcclxuICAgKiBAZmlyZXMgVGFibGVGbG9hdGluZ0hlYWRlcn5yZXBvcnRhbC1maXhlZC1oZWFkZXItdmlzaWJsZVxyXG4gICAqICovXHJcbiAgc3RhdGljIHNldFZpc2liaWxpdHkoc291cmNlLCBoZWFkZXIsIHZpc2libGUpe1xyXG4gICAgaWYodmlzaWJsZSl7XHJcbiAgICAgIGhlYWRlci5zdHlsZS5kaXNwbGF5PSd0YWJsZSc7XHJcbiAgICAgIHNvdXJjZS5kaXNwYXRjaEV2ZW50KFJlcG9ydGFsQmFzZS5uZXdFdmVudCgncmVwb3J0YWwtZml4ZWQtaGVhZGVyLXZpc2libGUnKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBoZWFkZXIuc3R5bGUuZGlzcGxheT0nbm9uZSc7XHJcbiAgICAgIHNvdXJjZS5kaXNwYXRjaEV2ZW50KFJlcG9ydGFsQmFzZS5uZXdFdmVudCgncmVwb3J0YWwtZml4ZWQtaGVhZGVyLWhpZGRlbicpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHdyYXBzIHRoZSBgc291cmNlYCB0YWJsZSBpbnRvIGEgYGRpdi5hZ2dyZWdhdGVkVGFibGVDb250YWluZXJgXHJcbiAgICogKi9cclxuICBzdGF0aWMgd3JhcFRhYmxlKHNvdXJjZSl7XHJcbiAgICBsZXQgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdhZ2dyZWdhdGVkVGFibGVDb250YWluZXInKTtcclxuICAgIHNvdXJjZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHdyYXBwZXIpO1xyXG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChzb3VyY2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogY2xvbmVzIGhlYWRlciBvZiBgc291cmNlYCB0YWJsZSBhbmQgYXBwZW5kcyB0byB3cmFwcGVyXHJcbiAgICogKi9cclxuICBzdGF0aWMgY2xvbmVIZWFkZXIoc291cmNlKXtcclxuICAgIGxldCBoZWFkZXIgPSBzb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgaGVhZGVyLmNsYXNzTGlzdC5hZGQoJ2ZpeGVkJyk7XHJcbiAgICBzb3VyY2UucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChoZWFkZXIpO1xyXG4gICAgW10uc2xpY2UuY2FsbChoZWFkZXIuY2hpbGRyZW4pLmZvckVhY2goY2hpbGQ9PntcclxuICAgICAgaWYoY2hpbGQubm9kZU5hbWU9PSdUQk9EWScpe1xyXG4gICAgICAgIGhlYWRlci5yZW1vdmVDaGlsZChjaGlsZCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGhlYWRlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGZ1bmN0aW9uIHRoYXQgcG9sbHMgdGhlIGNhbGxiYWNrXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBmdW5jdGlvbiB0aGF0J3MgZ29pbmcgdG8gYmUgcGFzc2VkIHRvIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGZvciBleGVjdXRpb25cclxuICAgKiAqL1xyXG4gIHJlcXVlc3RUaWNrKGNhbGxiYWNrKXtcclxuICAgIGlmKCF0aGlzLl9tZXRhLnRpY2tpbmcpIHtcclxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcclxuICAgICAgdGhpcy5fbWV0YS50aWNraW5nID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXRpYyBfcmVzaXplQ2FsbGJhY2soKXtcclxuICAgIGxldCBpbml0aWFsSGVhZGVyID0gdGhpcy5fbWV0YS5zb3VyY2VUSEVBRC5xdWVyeVNlbGVjdG9yQWxsKCd0cj4qJyksXHJcbiAgICAgIGNsb25lZEhlYWRlciA9IHRoaXMuaGVhZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RoZWFkPnRyPionKSxcclxuICAgICAgaGVhZGVyV2lkdGggPSB0aGlzLnNvdXJjZS5vZmZzZXRXaWR0aCArICdweCcsXHJcbiAgICAgIHdpZHRocz1bXTtcclxuICAgIC8vIGRvIHJlZmxvd1xyXG4gICAgZm9yKGxldCBpPTA7aTxpbml0aWFsSGVhZGVyLmxlbmd0aDtpKyspe1xyXG4gICAgICB3aWR0aHMucHVzaChpbml0aWFsSGVhZGVyW2ldLm9mZnNldFdpZHRoKTtcclxuICAgIH1cclxuICAgIC8vZG8gcmVwYWludFxyXG4gICAgZm9yKGxldCBjPTA7YzxjbG9uZWRIZWFkZXIubGVuZ3RoO2MrKyl7XHJcbiAgICAgIGNsb25lZEhlYWRlcltjXS5zdHlsZS53aWR0aCA9IHdpZHRoc1tjXSArICdweCc7XHJcbiAgICB9XHJcbiAgICB0aGlzLmhlYWRlci5zdHlsZS53aWR0aCA9IGhlYWRlcldpZHRoO1xyXG5cclxuICAgIFRhYmxlRmxvYXRpbmdIZWFkZXIuY2FsY09mZnNldEhlaWdodC5jYWxsKHRoaXMsdGhpcy5zb3VyY2UpOyAvL3JlY2FsYyBoZWlnaHQgb2YgdGhlIHRhYmxlIGFmdGVyIHJlZmxvd1xyXG4gICAgdGhpcy5fbWV0YS50aWNraW5nPWZhbHNlO1xyXG4gICAgdGhpcy5zY3JvbGxGaXhlZCgpOyAvLyB0byBjb21wZW5zYXRlIHRvcCBvZmZzZXQgaW4gY2FzZSBhZnRlciByZXNpemUgdGhlIHRhYmxlIGlzIGxlc3MgaW4gaGVpZ2h0IGFuZCB0b3AgaGFzIGNoYW5nZWRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgd2lkdGhzIGZvciBhbGwgY29sdW1ucyBpbiB0aGUgZml4ZWQgaGVhZGVyIGJhc2VkIG9uIHRoZSBgc291cmNlYFxyXG4gICAqICovXHJcbiAgcmVzaXplRml4ZWQoKXtcclxuICAgIHRoaXMucmVxdWVzdFRpY2soVGFibGVGbG9hdGluZ0hlYWRlci5fcmVzaXplQ2FsbGJhY2suYmluZCh0aGlzKSlcclxuICB9XHJcblxyXG5cclxuICBzdGF0aWMgX3Njcm9sbENhbGxiYWNrKCl7XHJcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5fbWV0YS5sYXN0U2Nyb2xsWSxcclxuICAgICAgdGFibGVPZmZzZXRUb3AgPSB0aGlzLl9tZXRhLnRhYmxlT2Zmc2V0VG9wLFxyXG4gICAgICB0YWJsZU9mZnNldEJvdHRvbSA9IHRoaXMuX21ldGEudGFibGVPZmZzZXRCb3R0b207XHJcbiAgICBpZigob2Zmc2V0IDwgdGFibGVPZmZzZXRUb3AgfHwgb2Zmc2V0ID4gdGFibGVPZmZzZXRCb3R0b20pICYmIHRoaXMudmlzaWJsZSl7XHJcbiAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICBUYWJsZUZsb2F0aW5nSGVhZGVyLnNldFZpc2liaWxpdHkodGhpcy5zb3VyY2UsdGhpcy5oZWFkZXIsZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZihvZmZzZXQgPj0gdGFibGVPZmZzZXRUb3AgJiYgb2Zmc2V0IDw9IHRhYmxlT2Zmc2V0Qm90dG9tKXtcclxuICAgICAgdGhpcy5oZWFkZXIuc3R5bGUudG9wPW9mZnNldC10YWJsZU9mZnNldFRvcCsncHgnO1xyXG4gICAgICBpZighdGhpcy52aXNpYmxlKXtcclxuICAgICAgICB0aGlzLnZpc2libGU9dHJ1ZTtcclxuICAgICAgICBUYWJsZUZsb2F0aW5nSGVhZGVyLnNldFZpc2liaWxpdHkodGhpcy5zb3VyY2UsdGhpcy5oZWFkZXIsdHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuX21ldGEudGlja2luZz1mYWxzZTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBEaXNwbGF5cyBhIGZpeGVkIGhlYWRlciB3aGVuIHRoZSB0YWJsZSBoZWFkZXIgaXMgc2Nyb2xsZWQgb2ZmIHRoZSBzY3JlZW5cclxuICAgKiAqL1xyXG4gIHNjcm9sbEZpeGVkKCkge1xyXG4gICAgICB0aGlzLl9tZXRhLmxhc3RTY3JvbGxZID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xyXG4gICAgICB0aGlzLnJlcXVlc3RUaWNrKFRhYmxlRmxvYXRpbmdIZWFkZXIuX3Njcm9sbENhbGxiYWNrLmJpbmQodGhpcykpO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRhYmxlRmxvYXRpbmdIZWFkZXI7XHJcblxyXG5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yLXRhYmxlLWZsb2F0aW5nLWhlYWRlci9zcmMvdGFibGUtZmxvYXRpbmctaGVhZGVyLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nvar _rAsyncHierarchyTable = __webpack_require__(6);\n\nvar _rAsyncHierarchyTable2 = _interopRequireDefault(_rAsyncHierarchyTable);\n\nvar _mapHierarchy = __webpack_require__(14);\n\nvar _mapHierarchy2 = _interopRequireDefault(_mapHierarchy);\n\nvar _rAggregatedTable = __webpack_require__(5);\n\nvar _rAggregatedTable2 = _interopRequireDefault(_rAggregatedTable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n__webpack_require__(18);\n\n//var CircularJSON=function(e,t){function l(e,t,o){var u=[],f=[e],l=[e],c=[o?n:\"[Circular]\"],h=e,p=1,d;return function(e,v){return t&&(v=t.call(this,e,v)),e!==\"\"&&(h!==this&&(d=p-a.call(f,this)-1,p-=d,f.splice(p,f.length),u.splice(p-1,u.length),h=this),typeof v==\"object\"&&v?(a.call(f,v)<0&&f.push(h=v),p=f.length,d=a.call(l,v),d<0?(d=l.push(v)-1,o?(u.push((\"\"+e).replace(s,r)),c[d]=n+u.join(n)):c[d]=c[0]):v=c[d]):typeof v==\"string\"&&o&&(v=v.replace(r,i).replace(n,r))),v}}function c(e,t){for(;var r=0,i=t.length;r<i;e=e[t[r++].replace(o,n)]);return e}function h(e){return function(t,s){var o=typeof s==\"string\";return o&&s.charAt(0)===n?new f(s.slice(1)):(t===\"\"&&(s=v(s,s,{})),o&&(s=s.replace(u,\"$1\"+n).replace(i,r)),e?e.call(this,t,s):s)}}function p(e,t,n){for(var r=0,i=t.length;r<i;r++)t[r]=v(e,t[r],n);return t}function d(e,t,n){for(var r in t)t.hasOwnProperty(r)&&(t[r]=v(e,t[r],n));return t}function v(e,t,r){return t instanceof Array?p(e,t,r):t instanceof f?t.length?r.hasOwnProperty(t)?r[t]:r[t]=c(e,t.split(n)):e:t instanceof Object?d(e,t,r):t}function m(t,n,r,i){return e.stringify(t,l(t,n,!i),r)}function g(t,n){return e.parse(t,h(n))}var n=\"~\",r=\"\\\\x\"+(\"0\"+n.charCodeAt(0).toString(16)).slice(-2),i=\"\\\\\"+r,s=new t(r,\"g\"),o=new t(i,\"g\"),u=new t(\"(?:^|([^\\\\\\\\]))\"+i),a=[].indexOf||function(e){for(var t=this.length;t--&&this[t]!==e;);return t},f=String;return{stringify:m,parse:g}}(JSON,RegExp);\n\nvar DrilldownMap = function (_MapHierarchy) {\n  _inherits(DrilldownMap, _MapHierarchy);\n\n  /**\n   * Creates a drilldown map\n   * @param {Object} hierarchy - a hierarchical object for a map to be built upon\n   * @param {String} containerID - id of the container the map will be drawn to\n   * @param {Function} mappointCallback - executed when a mappoint (city) is clicked\n   * @param {Array.<{from:Number, to:Number, color:String, name:String}>} dataClasses - color bands for conditional formatting\n   * @param {Object} options - options passed to HighMap to restyle/configure it\n   * @param {Function} colorFn - A function that allows custom color coding computation based on value and target.\n   * `colorFn` accepts two attributes: `value` and `target` and must return a color string based on those two attributes.\n   * Make sure hierarchy has `target` loaded from DBDesigner table into each hierarchy level, otherwise a default config `dataClasses` takes precedence on value\n   * Example:\n   *\n   * ``` javascript\n   *    {\n   *    //some constructor configuration above\n   *      colorFn: function(value,target){\n   *        return (value!=null && target!=null)? (value - target >= 0) ? \"#18BC9C\" : ((value >= 0.9*target) ? \"#FF4900\" : \"#E45335\") : undefined;\n   *      }\n   *     //some constructor configuration below\n   *    }\n   * ```\n   * @param {Number} [valueColumn=1] - Zero-based column index that contains primary value which will be used for map coloring\n   * */\n  function DrilldownMap() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        source = _ref.source,\n        rowheaders = _ref.rowheaders,\n        hierarchy = _ref.hierarchy,\n        _ref$initMap = _ref.initMap,\n        initMap = _ref$initMap === undefined ? \"custom/world-highres2\" : _ref$initMap,\n        containerID = _ref.containerID,\n        mappointCallback = _ref.mappointCallback,\n        excludeColumns = _ref.excludeColumns,\n        excludeRows = _ref.excludeRows,\n        _ref$valueColumn = _ref.valueColumn,\n        valueColumn = _ref$valueColumn === undefined ? 1 : _ref$valueColumn,\n        _ref$colorFn = _ref.colorFn,\n        colorFn = _ref$colorFn === undefined ? function (value, target) {\n      return value != null ? value >= 80 ? \"#4caf50\" : value < 80 && value >= 60 ? \"#ffc107\" : \"#ff5722\" : \"blue\";\n    } : _ref$colorFn,\n        _ref$pageStateId = _ref.pageStateId,\n        pageStateId = _ref$pageStateId === undefined ? document.querySelector('#PageStateId') ? document.querySelector('#PageStateId').value : undefined : _ref$pageStateId,\n        _ref$languageCode = _ref.languageCode,\n        languageCode = _ref$languageCode === undefined ? 9 : _ref$languageCode,\n        tableID = _ref.tableID,\n        normals = _ref.normals,\n        normalsSeparator = _ref.normalsSeparator,\n        _ref$options = _ref.options,\n        options = _ref$options === undefined ? {} : _ref$options;\n\n    _classCallCheck(this, DrilldownMap);\n\n    var _this = _possibleConstructorReturn(this, (DrilldownMap.__proto__ || Object.getPrototypeOf(DrilldownMap)).call(this, hierarchy, normals, normalsSeparator));\n\n    _this.constructor.parseTableData({ source: source, excludeRows: excludeRows, excludeColumns: excludeColumns, rowheaders: rowheaders.map(function (rh) {\n        return rh[0];\n      }), flatHierarchy: _this.flatHierarchy });\n    if (colorFn && typeof colorFn == \"function\") {\n      _this.colorFn = colorFn;\n    }\n    _this.valueColumn = valueColumn;\n    _this.hierarchyID = hierarchyID;\n    _this.hierarchyControlID = hierarchyControlID;\n    _this.pageStateId = pageStateId;\n    _this.languageCode = languageCode;\n    _this.tableID = tableID;\n\n    if (mappointCallback && mappointCallback != null) {\n      if (typeof mappointCallback == 'function') {\n        _this.mappointCallback = mappointCallback;\n      } else {\n        throw new TypeError(\"mappointCallback must be a function\");\n      }\n    }\n    var config = _this.config = _rReportalBase2.default.mixin(options, {/*colorAxis:{dataClasses}*/});\n    if ((typeof Highcharts === \"undefined\" ? \"undefined\" : _typeof(Highcharts)) == undefined) {\n      throw new Error('Highcharts must be declared. Probably they are missing');\n    }\n    if (_typeof(Highcharts.maps) == undefined) {\n      throw new Error('HighMaps must be loaded. Probably they are missing');\n    }\n    //\n    _this.drawMap(rowheaders, containerID, initMap, config);\n    return _this;\n  }\n\n  _createClass(DrilldownMap, [{\n    key: \"initMap\",\n\n\n    /**\n     * Get series for the first time map initialization\n     * @param {Object} curLVL - current level in hierarchy\n     * @param {Array} [series=[]] - series\n     * @returns {Array}\n     * */\n    value: function initMap(curLVL) {\n      var _this2 = this;\n\n      var series = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      curLVL.subcells.forEach(function (subcell) {\n        if (subcell.mapID) {\n          var seriesItem = _this2.composeSeries(subcell);\n          series.push(seriesItem);\n        }\n      });\n      return series;\n    }\n\n    /**\n     * Load map from HighMaps map collection\n     * @param source\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"getSeriesData\",\n\n\n    /**\n     * Creates a single series data for HighMap series option\n     * @param {Object} level - a level in hierarchy\n     * @returns {Object}\n     */\n    value: function getSeriesData(level) {\n      var _this3 = this;\n\n      var drilldown = level.subcells ? level.text : null;\n      if (typeof level.mapID === 'string') {\n        return [{\n          drilldown: drilldown,\n          code: level.mapID,\n          value: DrilldownMap.getPrimaryValue(level, this.valueColumn),\n          data: level._data\n        }];\n      } else if (Array.isArray(level.mapID)) {\n        return level.mapID.map(function (mapID) {\n\n          return {\n            drilldown: drilldown,\n            code: mapID,\n            value: DrilldownMap.getPrimaryValue(level, _this3.valueColumn),\n            data: level._data\n          };\n        });\n      } else {\n        throw new Error(\"Data element is corrupted\");\n      }\n    }\n\n    /**\n     * Executes `colorFn` passed by user to compute color by passing `value` and `target` to it\n     * */\n\n  }, {\n    key: \"getCoordinateSeries\",\n\n\n    /**\n     * Create a single mappoint series\n     * @param {Object} subcell\n     * @param {Object} mapData\n     * @param {Object} chart\n     * @returns {Object} series for map points\n     * */\n    value: function getCoordinateSeries(subcell, mapData, chart) {\n      chart.mapTransforms = mapData ? mapData[\"hc-transform\"] : Highcharts.maps[\"custom/world-highres2\"][\"hc-transform\"];\n      var pos = chart.fromLatLonToPoint({ lat: subcell.coordinates[0], lon: subcell.coordinates[1] });\n      var config = {\n        type: \"mappoint\", // or \"mapbubble,\n        name: subcell.text,\n        marker: {\n          lineColor: \"black\",\n          lineWidth: 1,\n          radius: 4,\n          symbol: \"circle\"\n        },\n        data: [{\n          color: DrilldownMap.getColor(subcell.value, this.config.colorAxis.dataClasses),\n          name: subcell.text,\n          value: subcell.value,\n          x: pos.x,\n          y: pos.y\n        }]\n      };\n      if (this.mappointCallback) {\n        config.events = {\n          click: this.mappointCallback\n        };\n      }\n      return config;\n    }\n\n    /**\n     * Creates a single series item for Highmaps series option\n     * @param {Object} subcell - a subcell\n     * @param mapData\n     * @param chart\n     * @returns {Object} Returns series\n     */\n\n  }, {\n    key: \"composeSeries\",\n    value: function composeSeries(subcell, mapData, chart) {\n      if (!subcell.coordinates) {\n        mapData = mapData ? Highcharts.geojson(DrilldownMap.createCustomGeoJSON(mapData, subcell.mapID, subcell.text)) : Highcharts.geojson(DrilldownMap.createCustomGeoJSON(Highcharts.maps['custom/world-highres2'], subcell.mapID, subcell.text));\n        if (subcell.mapID) {\n          var target = subcell.target;\n          if (!target || target == null) {\n            target = this.hierarchy[0].target;\n          }\n          return {\n            name: subcell.text,\n            dataLabels: {\n              enabled: true,\n              formatter: function formatter() {\n                if (this.series.data[0].name == this.point.name) return this.series.name;\n              }\n            },\n            /*tooltip: {\n             pointFormat: 'NPS : {point.value}'\n             },*/\n            color: DrilldownMap.computeColor(this.colorFn, DrilldownMap.getPrimaryValue(subcell, this.valueColumn), target),\n            allAreas: false,\n            parent: subcell.parent.text,\n            mapData: mapData,\n            joinBy: ['hc-key', 'code'],\n            data: this.getSeriesData(subcell)\n          };\n        }\n      } else {\n        return this.getCoordinateSeries(subcell, mapData, chart);\n      }\n    }\n\n    /**\n     * get subcell by text rather than by id\n     * @param {Object} curLVL - current level\n     * @param {String} name - name of the subcell we're looking for\n     * @returns {Object} Returns a subcell which has that name\n     * */\n\n  }, {\n    key: \"updateMap\",\n\n\n    /**\n     * Updates your map view after drilldown click\n     * @param {Object} curLVL\n     * @param {Object} chart\n     * @param {Object} e - drilldown event object\n     * @returns {Object} Returns curLVL\n     */\n    value: function updateMap(curLVL, chart, e) {\n      var _this4 = this;\n\n      //curLVL = curLVL.subcells.filter( el => el.text == e.point.series.name)[0];\n      if (curLVL && curLVL.mapName) {\n        // if we have another map to load\n        var map = DrilldownMap.loadMap(curLVL.mapName);\n        map.then(function (mapData) {\n          _this4.addSeries(curLVL, chart, e, mapData);\n        });\n      } else if (curLVL && !curLVL.mapName) {\n        this.addSeries(curLVL, chart, e);\n      }\n      //return curLVL;\n    }\n\n    /**\n     * Composes a series for your HighMaps options config\n     * @param {Object} curLVL\n     * @param {Object} chart\n     * @param {Object} e - drilldown event object\n     * @param {Object} mapData - mapData geoJSON\n     */\n\n  }, {\n    key: \"addSeries\",\n    value: function addSeries(curLVL, chart, e, mapData) {\n      var _this5 = this;\n\n      if (curLVL.subcells) {\n        // if it's an end point\n        if (curLVL.subcells[0].coordinates) {\n          var seriesItem = this.composeSeries(curLVL, mapData, chart);\n          seriesItem.data.forEach(function (dataItem) {\n            dataItem.drilldown = null;\n            dataItem.value = null;\n          });\n          chart.addSingleSeriesAsDrilldown(e.point, seriesItem);\n        }\n        curLVL.subcells.forEach(function (subcell) {\n          if (!subcell.mapID && !subcell.coordinates) return;\n\n          var seriesItem = _this5.composeSeries(subcell, mapData, chart);\n          chart.addSingleSeriesAsDrilldown(e.point, seriesItem);\n        });\n        chart.applyDrilldown();\n      } else {\n        var _seriesItem = this.composeSeries(curLVL, mapData, chart);\n        _seriesItem.data.map(function (dataItem) {\n          dataItem.drilldown = null;\n          dataItem.value = null;\n        });\n        chart.addSeriesAsDrilldown(e.point, _seriesItem);\n      }\n    }\n\n    /**\n     * Generates chart subtitle returning region and main value\n     * */\n\n  }, {\n    key: \"getTooltip\",\n\n\n    /**\n     * Generates a serialized dataset for a tooltip\n     * */\n    value: function getTooltip() {\n      var data = this.curLVL._data;\n      return data.map(function (item, index) {\n        return \"<span class=\\\"tooltip-level-label\\\">\" + item.title + \":</span><span class=\\\"tooltip-level-value\\\"> {point.data.\" + index + \".value}</span>\";\n      }).join(\"<br />\");\n    }\n\n    /**\n     * @param hierarchy\n     * @param containerID\n     * @param options\n     */\n\n  }, {\n    key: \"drawMap\",\n    value: function drawMap(rowheaders, containerID, initMap, options) {\n      this.curLVL = this.flatHierarchy[rowheaders[0]];\n      var self = this;\n      var config = {\n        lang: {\n          drillUpText: '< to {series.parent}'\n        },\n        tooltip: {\n          pointFormat: self.getTooltip()\n        },\n        title: {\n          text: ''\n        },\n        legend: {\n          enabled: true\n        },\n        plotOptions: {\n          series: {\n            states: {\n              normal: {\n                animation: false\n              }\n            },\n            point: {\n              events: {\n                mouseOver: function mouseOver(e) {\n                  this.series.data.forEach(function (el) {\n                    return el.setState(\"hover\");\n                  });\n                },\n                mouseOut: function mouseOut(e) {\n                  this.series.data.forEach(function (el) {\n                    return el.setState();\n                  });\n                }\n              }\n            }\n          }\n        },\n        mapNavigation: {\n          enabled: true,\n          buttons: {\n            zoomIn: {\n              verticalAlign: \"bottom\"\n            },\n            zoomOut: {\n              verticalAlign: \"bottom\"\n            }\n          }\n        },\n        subtitle: {\n          align: 'right',\n          text: self.subtitle,\n          floating: true\n        },\n        drilldown: {\n          drillUpButton: {\n            position: {\n              align: \"left\",\n              y: 0\n            },\n            relativeTo: 'spacingBox'\n          }\n        },\n        chart: {\n          events: {\n            drilldown: function drilldown(e) {\n              //this == chart reference;\n              //console.log(CircularJSON.parse(CircularJSON.stringify(e.point)));\n              var chart = e.target;\n              self.curLVL = DrilldownMap.getLevelByName(self.curLVL, e.point.series.name);\n              var curLVL = self.curLVL;\n              if (curLVL) {\n                chart.showLoading('fetching data');\n                var table = _rAsyncHierarchyTable2.default.fetchChildTable(curLVL.id, curLVL.parent ? curLVL.parent.id : null, self.tableID, self.pageStateId).then(function (table) {\n                  // parse data loaded from table\n                  DrilldownMap.parseTableData({\n                    source: table,\n                    excludeRows: 0,\n                    rowheaders: curLVL.subcells.map(function (lvl) {\n                      return lvl.id;\n                    }),\n                    flatHierarchy: self.flatHierarchy\n                  });\n                  self.updateMap(curLVL, chart, e);\n                  chart.subtitle.update({ text: self.subtitle });\n                  chart.hideLoading();\n                });\n              }\n            },\n            drillupall: function drillupall(e) {\n              self.curLVL = self.curLVL.parent;\n              if (self.curLVL) {\n                e.target.subtitle.update({ text: self.subtitle });\n              }\n            }\n          }\n        },\n        series: self.initMap(self.curLVL, [{\n          showInLegend: false,\n          mapData: Highcharts.maps[initMap]\n        }])\n      };\n\n      config = _rReportalBase2.default.mixin(config, options);\n      Highcharts.mapChart(containerID, config);\n    }\n  }, {\n    key: \"subtitle\",\n    get: function get() {\n      //return `${this.curLVL._data[0].title}: ${this.curLVL._data[0].value}<br> ${this.curLVL._data[this.valueColumn].title}: ${this.curLVL._data[this.valueColumn].value}`\n      return this.curLVL._data.map(function (item) {\n        return \"<span class=\\\"tooltip-level-label\\\">\" + item.title + \":</span><span class=\\\"tooltip-level-value\\\"> \" + item.value + \"</span>\";\n      }).join(\"<br />\");\n    }\n  }], [{\n    key: \"parseTableData\",\n    value: function parseTableData() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          source = _ref2.source,\n          excludeRows = _ref2.excludeRows,\n          excludeColumns = _ref2.excludeColumns,\n          rowheaders = _ref2.rowheaders,\n          flatHierarchy = _ref2.flatHierarchy;\n\n      var AT = new _rAggregatedTable2.default({\n        source: source,\n        excludeColumns: excludeColumns, excludeRows: excludeRows\n      });\n      if (rowheaders && rowheaders != null && rowheaders.length > 0) {\n        rowheaders.forEach(function (rh, i) {\n          if (!flatHierarchy[rh]._data) {\n            flatHierarchy[rh]._data = AT.data[i].map(function (dataItem, index) {\n              return {\n                value: dataItem.data,\n                title: index != 0 ? AT.columns[index].title : \"Region\"\n              };\n            });\n          }\n        });\n      } else {\n        throw new Error('rowheaders must be present to parse data');\n      }\n    }\n\n    /**\n     * Creates custom geoJSON file\n     * @param {Object} mapData - initial map\n     * @param {Array}countriesList - list of countries IDs\n     * @param {String} mapName\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"createCustomGeoJSON\",\n    value: function createCustomGeoJSON(mapData, countriesList, mapName) {\n      var geojson = {\n        title: \"\",\n        version: \"0.1.0\",\n        type: \"FeatureCollection\",\n        copyright: \"Copyright (c) 2015 Highsoft AS, Based on data from Natural Earth\",\n        copyrightShort: \"Natural Earth\",\n        copyrightUrl: \"http://www.naturalearthdata.com\",\n        crs: {\n          type: \"name\",\n          properties: {\n            name: \"urn:ogc:def:crs:EPSG:54003\"\n          }\n        },\n        \"hc-transform\": {\n          default: {\n            crs: \"+proj=mill +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +R_A +datum=WGS84 +units=m +no_defs\",\n            scale: 1.72182781654e-05,\n            jsonres: 15.5,\n            jsonmarginX: -999,\n            jsonmarginY: 9851.0,\n            xoffset: -19495356.3693,\n            yoffset: 12635908.1982\n          }\n        },\n        features: DrilldownMap.getFeatures(countriesList, mapData) //[[]]\n      };\n\n      geojson.title = mapName;\n      return geojson;\n    }\n\n    /**\n     * Get array of features from geoJSON file\n     * @param {Array | String}countriesList - countries IDs\n     * @param {Object} mapData - your initial map\n     * @param {String} key for geojson features comparing\n     * @returns {Array} features list\n     */\n\n  }, {\n    key: \"getFeatures\",\n    value: function getFeatures(countriesList, mapData) {\n      var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"hc-key\";\n\n      if (typeof countriesList === 'string') {\n        return mapData.features.filter(function (feature) {\n          return feature.properties[key] === countriesList;\n        });\n      } else if (Array.isArray(countriesList)) {\n        return mapData.features.filter(function (feature) {\n          return countriesList.indexOf(feature.properties[key]) != -1;\n        });\n      }\n    }\n  }, {\n    key: \"loadMap\",\n    value: function loadMap(source) {\n      return new Promise(function (resolve, reject) {\n        jQuery.getScript('https://code.highcharts.com/mapdata/' + source + '.js', function () {\n          resolve(Highcharts.maps[source]);\n        });\n      });\n    }\n  }, {\n    key: \"getPrimaryValue\",\n    value: function getPrimaryValue(level, valueColumn) {\n      return level._data[valueColumn].value;\n    }\n  }, {\n    key: \"computeColor\",\n    value: function computeColor(colorFn, value, target) {\n      if (colorFn) {\n        return colorFn(value, target);\n      } else {\n        return undefined;\n      }\n    }\n\n    /**\n     * Pick a color for mappoint\n     * @param val\n     * @param dataClasses\n     * @returns {String} point color\n     */\n\n  }, {\n    key: \"getColor\",\n    value: function getColor(val, dataClasses) {\n      var color = void 0;\n      dataClasses.forEach(function (dataClass) {\n        if (val >= dataClass.from && val < dataClass.to) {\n          color = dataClass.color;\n        }\n      });\n      return color;\n    }\n  }, {\n    key: \"getLevelByName\",\n    value: function getLevelByName(curLVL, name) {\n      return curLVL.subcells.filter(function (el) {\n        return el.text == name;\n      })[0];\n    }\n  }]);\n\n  return DrilldownMap;\n}(_mapHierarchy2.default);\n\nexports.default = DrilldownMap;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvRHJpbGxkb3duTWFwLmpzP2UwMjkiXSwibmFtZXMiOlsicmVxdWlyZSIsIkRyaWxsZG93bk1hcCIsInNvdXJjZSIsInJvd2hlYWRlcnMiLCJoaWVyYXJjaHkiLCJpbml0TWFwIiwiY29udGFpbmVySUQiLCJtYXBwb2ludENhbGxiYWNrIiwiZXhjbHVkZUNvbHVtbnMiLCJleGNsdWRlUm93cyIsInZhbHVlQ29sdW1uIiwiY29sb3JGbiIsInZhbHVlIiwidGFyZ2V0IiwicGFnZVN0YXRlSWQiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJ1bmRlZmluZWQiLCJsYW5ndWFnZUNvZGUiLCJ0YWJsZUlEIiwibm9ybWFscyIsIm5vcm1hbHNTZXBhcmF0b3IiLCJvcHRpb25zIiwiY29uc3RydWN0b3IiLCJwYXJzZVRhYmxlRGF0YSIsIm1hcCIsInJoIiwiZmxhdEhpZXJhcmNoeSIsImhpZXJhcmNoeUlEIiwiaGllcmFyY2h5Q29udHJvbElEIiwiVHlwZUVycm9yIiwiY29uZmlnIiwibWl4aW4iLCJIaWdoY2hhcnRzIiwiRXJyb3IiLCJtYXBzIiwiZHJhd01hcCIsImN1ckxWTCIsInNlcmllcyIsInN1YmNlbGxzIiwiZm9yRWFjaCIsInN1YmNlbGwiLCJtYXBJRCIsInNlcmllc0l0ZW0iLCJjb21wb3NlU2VyaWVzIiwicHVzaCIsImxldmVsIiwiZHJpbGxkb3duIiwidGV4dCIsImNvZGUiLCJnZXRQcmltYXJ5VmFsdWUiLCJkYXRhIiwiX2RhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJtYXBEYXRhIiwiY2hhcnQiLCJtYXBUcmFuc2Zvcm1zIiwicG9zIiwiZnJvbUxhdExvblRvUG9pbnQiLCJsYXQiLCJjb29yZGluYXRlcyIsImxvbiIsInR5cGUiLCJuYW1lIiwibWFya2VyIiwibGluZUNvbG9yIiwibGluZVdpZHRoIiwicmFkaXVzIiwic3ltYm9sIiwiY29sb3IiLCJnZXRDb2xvciIsImNvbG9yQXhpcyIsImRhdGFDbGFzc2VzIiwieCIsInkiLCJldmVudHMiLCJjbGljayIsImdlb2pzb24iLCJjcmVhdGVDdXN0b21HZW9KU09OIiwiZGF0YUxhYmVscyIsImVuYWJsZWQiLCJmb3JtYXR0ZXIiLCJwb2ludCIsImNvbXB1dGVDb2xvciIsImFsbEFyZWFzIiwicGFyZW50Iiwiam9pbkJ5IiwiZ2V0U2VyaWVzRGF0YSIsImdldENvb3JkaW5hdGVTZXJpZXMiLCJlIiwibWFwTmFtZSIsImxvYWRNYXAiLCJ0aGVuIiwiYWRkU2VyaWVzIiwiZGF0YUl0ZW0iLCJhZGRTaW5nbGVTZXJpZXNBc0RyaWxsZG93biIsImFwcGx5RHJpbGxkb3duIiwiYWRkU2VyaWVzQXNEcmlsbGRvd24iLCJpdGVtIiwiaW5kZXgiLCJ0aXRsZSIsImpvaW4iLCJzZWxmIiwibGFuZyIsImRyaWxsVXBUZXh0IiwidG9vbHRpcCIsInBvaW50Rm9ybWF0IiwiZ2V0VG9vbHRpcCIsImxlZ2VuZCIsInBsb3RPcHRpb25zIiwic3RhdGVzIiwibm9ybWFsIiwiYW5pbWF0aW9uIiwibW91c2VPdmVyIiwiZWwiLCJzZXRTdGF0ZSIsIm1vdXNlT3V0IiwibWFwTmF2aWdhdGlvbiIsImJ1dHRvbnMiLCJ6b29tSW4iLCJ2ZXJ0aWNhbEFsaWduIiwiem9vbU91dCIsInN1YnRpdGxlIiwiYWxpZ24iLCJmbG9hdGluZyIsImRyaWxsVXBCdXR0b24iLCJwb3NpdGlvbiIsInJlbGF0aXZlVG8iLCJnZXRMZXZlbEJ5TmFtZSIsInNob3dMb2FkaW5nIiwidGFibGUiLCJmZXRjaENoaWxkVGFibGUiLCJpZCIsImx2bCIsInVwZGF0ZU1hcCIsInVwZGF0ZSIsImhpZGVMb2FkaW5nIiwiZHJpbGx1cGFsbCIsInNob3dJbkxlZ2VuZCIsIm1hcENoYXJ0IiwiQVQiLCJsZW5ndGgiLCJpIiwiY29sdW1ucyIsImNvdW50cmllc0xpc3QiLCJ2ZXJzaW9uIiwiY29weXJpZ2h0IiwiY29weXJpZ2h0U2hvcnQiLCJjb3B5cmlnaHRVcmwiLCJjcnMiLCJwcm9wZXJ0aWVzIiwiZGVmYXVsdCIsInNjYWxlIiwianNvbnJlcyIsImpzb25tYXJnaW5YIiwianNvbm1hcmdpblkiLCJ4b2Zmc2V0IiwieW9mZnNldCIsImZlYXR1cmVzIiwiZ2V0RmVhdHVyZXMiLCJrZXkiLCJmaWx0ZXIiLCJmZWF0dXJlIiwiaW5kZXhPZiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwialF1ZXJ5IiwiZ2V0U2NyaXB0IiwidmFsIiwiZGF0YUNsYXNzIiwiZnJvbSIsInRvIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUpBLG1CQUFBQSxDQUFRLEVBQVI7O0FBTUE7O0lBRU1DLFk7OztBQUNKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQSwwQkFRMkM7QUFBQSxtRkFBSCxFQUFHO0FBQUEsUUFQekNDLE1BT3lDLFFBUHpDQSxNQU95QztBQUFBLFFBUGxDQyxVQU9rQyxRQVBsQ0EsVUFPa0M7QUFBQSxRQU56Q0MsU0FNeUMsUUFOekNBLFNBTXlDO0FBQUEsNEJBTjlCQyxPQU04QjtBQUFBLFFBTjlCQSxPQU04QixnQ0FOdEIsdUJBTXNCO0FBQUEsUUFOR0MsV0FNSCxRQU5HQSxXQU1IO0FBQUEsUUFOZ0JDLGdCQU1oQixRQU5nQkEsZ0JBTWhCO0FBQUEsUUFMekNDLGNBS3lDLFFBTHpDQSxjQUt5QztBQUFBLFFBTHpCQyxXQUt5QixRQUx6QkEsV0FLeUI7QUFBQSxnQ0FMWkMsV0FLWTtBQUFBLFFBTFpBLFdBS1ksb0NBTEEsQ0FLQTtBQUFBLDRCQUp6Q0MsT0FJeUM7QUFBQSxRQUp6Q0EsT0FJeUMsZ0NBSmpDLFVBQVNDLEtBQVQsRUFBZUMsTUFBZixFQUFzQjtBQUMzQixhQUFPRCxTQUFPLElBQVAsR0FBYUEsU0FBUyxFQUFULEdBQWMsU0FBZCxHQUE0QkEsUUFBTyxFQUFQLElBQWFBLFNBQU8sRUFBckIsR0FBNEIsU0FBNUIsR0FBd0MsU0FBaEYsR0FBNkYsTUFBcEc7QUFDRixLQUV3QztBQUFBLGdDQUR6Q0UsV0FDeUM7QUFBQSxRQUR6Q0EsV0FD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RCxFQUFTQyxNQUFULEVBQWtCO0FBQ25DQyxlQUFPQyxTQUFQLENBQWlCLHlDQUF5Q3ZLLE1BQXpDLEdBQWtELEtBQW5FLEVBQTBFLFlBQVk7QUFDcEZvSyxrQkFBUXJJLFdBQVdFLElBQVgsQ0FBZ0JqQyxNQUFoQixDQUFSO0FBQ0QsU0FGRDtBQUdELE9BSk0sQ0FBUDtBQUtEOzs7b0NBRXNCNEMsSyxFQUFNcEMsVyxFQUFZO0FBQ3ZDLGFBQU9vQyxNQUFNTSxLQUFOLENBQVkxQyxXQUFaLEVBQXlCRSxLQUFoQztBQUNEOzs7aUNBcUNtQkQsTyxFQUFTQyxLLEVBQU9DLE0sRUFBTztBQUN6QyxVQUFHRixPQUFILEVBQVc7QUFDVCxlQUFPQSxRQUFRQyxLQUFSLEVBQWVDLE1BQWYsQ0FBUDtBQUNELE9BRkQsTUFFTztBQUNMLGVBQU9JLFNBQVA7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7NkJBTWdCeUosRyxFQUFLakcsVyxFQUFZO0FBQy9CLFVBQUlILGNBQUo7QUFDQUcsa0JBQVlqQyxPQUFaLENBQW9CLHFCQUFZO0FBQzlCLFlBQUdrSSxPQUFPQyxVQUFVQyxJQUFqQixJQUF5QkYsTUFBTUMsVUFBVUUsRUFBNUMsRUFBZ0Q7QUFDOUN2RyxrQkFBUXFHLFVBQVVyRyxLQUFsQjtBQUNEO0FBQ0YsT0FKRDtBQUtBLGFBQU9BLEtBQVA7QUFDRDs7O21DQWlGcUJqQyxNLEVBQU8yQixJLEVBQUs7QUFDaEMsYUFBTzNCLE9BQU9FLFFBQVAsQ0FBZ0IySCxNQUFoQixDQUF1QjtBQUFBLGVBQU0vQyxHQUFHbkUsSUFBSCxJQUFXZ0IsSUFBakI7QUFBQSxPQUF2QixFQUE4QyxDQUE5QyxDQUFQO0FBQ0Q7Ozs7OztrQkEyTFkvRCxZIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIi4vZHJpbGxkb3duLW1hcC5jc3NcIik7XG5pbXBvcnQgUmVwb3J0YWxCYXNlIGZyb20gXCJyLXJlcG9ydGFsLWJhc2VcIjtcbmltcG9ydCBBc3luY0hpZXJhcmNoeVRhYmxlIGZyb20gXCJyLWFzeW5jLWhpZXJhcmNoeS10YWJsZVwiO1xuaW1wb3J0IE1hcEhpZXJhcmNoeSBmcm9tIFwiLi9tYXAtaGllcmFyY2h5XCI7XG5pbXBvcnQgQWdncmVnYXRlZFRhYmxlIGZyb20gXCJyLWFnZ3JlZ2F0ZWQtdGFibGVcIjtcblxuLy92YXIgQ2lyY3VsYXJKU09OPWZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gbChlLHQsbyl7dmFyIHU9W10sZj1bZV0sbD1bZV0sYz1bbz9uOlwiW0NpcmN1bGFyXVwiXSxoPWUscD0xLGQ7cmV0dXJuIGZ1bmN0aW9uKGUsdil7cmV0dXJuIHQmJih2PXQuY2FsbCh0aGlzLGUsdikpLGUhPT1cIlwiJiYoaCE9PXRoaXMmJihkPXAtYS5jYWxsKGYsdGhpcyktMSxwLT1kLGYuc3BsaWNlKHAsZi5sZW5ndGgpLHUuc3BsaWNlKHAtMSx1Lmxlbmd0aCksaD10aGlzKSx0eXBlb2Ygdj09XCJvYmplY3RcIiYmdj8oYS5jYWxsKGYsdik8MCYmZi5wdXNoKGg9dikscD1mLmxlbmd0aCxkPWEuY2FsbChsLHYpLGQ8MD8oZD1sLnB1c2godiktMSxvPyh1LnB1c2goKFwiXCIrZSkucmVwbGFjZShzLHIpKSxjW2RdPW4rdS5qb2luKG4pKTpjW2RdPWNbMF0pOnY9Y1tkXSk6dHlwZW9mIHY9PVwic3RyaW5nXCImJm8mJih2PXYucmVwbGFjZShyLGkpLnJlcGxhY2UobixyKSkpLHZ9fWZ1bmN0aW9uIGMoZSx0KXtmb3IoO3ZhciByPTAsaT10Lmxlbmd0aDtyPGk7ZT1lW3RbcisrXS5yZXBsYWNlKG8sbildKTtyZXR1cm4gZX1mdW5jdGlvbiBoKGUpe3JldHVybiBmdW5jdGlvbih0LHMpe3ZhciBvPXR5cGVvZiBzPT1cInN0cmluZ1wiO3JldHVybiBvJiZzLmNoYXJBdCgwKT09PW4/bmV3IGYocy5zbGljZSgxKSk6KHQ9PT1cIlwiJiYocz12KHMscyx7fSkpLG8mJihzPXMucmVwbGFjZSh1LFwiJDFcIituKS5yZXBsYWNlKGkscikpLGU/ZS5jYWxsKHRoaXMsdCxzKTpzKX19ZnVuY3Rpb24gcChlLHQsbil7Zm9yKHZhciByPTAsaT10Lmxlbmd0aDtyPGk7cisrKXRbcl09dihlLHRbcl0sbik7cmV0dXJuIHR9ZnVuY3Rpb24gZChlLHQsbil7Zm9yKHZhciByIGluIHQpdC5oYXNPd25Qcm9wZXJ0eShyKSYmKHRbcl09dihlLHRbcl0sbikpO3JldHVybiB0fWZ1bmN0aW9uIHYoZSx0LHIpe3JldHVybiB0IGluc3RhbmNlb2YgQXJyYXk/cChlLHQscik6dCBpbnN0YW5jZW9mIGY/dC5sZW5ndGg/ci5oYXNPd25Qcm9wZXJ0eSh0KT9yW3RdOnJbdF09YyhlLHQuc3BsaXQobikpOmU6dCBpbnN0YW5jZW9mIE9iamVjdD9kKGUsdCxyKTp0fWZ1bmN0aW9uIG0odCxuLHIsaSl7cmV0dXJuIGUuc3RyaW5naWZ5KHQsbCh0LG4sIWkpLHIpfWZ1bmN0aW9uIGcodCxuKXtyZXR1cm4gZS5wYXJzZSh0LGgobikpfXZhciBuPVwiflwiLHI9XCJcXFxceFwiKyhcIjBcIituLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMiksaT1cIlxcXFxcIityLHM9bmV3IHQocixcImdcIiksbz1uZXcgdChpLFwiZ1wiKSx1PW5ldyB0KFwiKD86XnwoW15cXFxcXFxcXF0pKVwiK2kpLGE9W10uaW5kZXhPZnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXRoaXMubGVuZ3RoO3QtLSYmdGhpc1t0XSE9PWU7KTtyZXR1cm4gdH0sZj1TdHJpbmc7cmV0dXJue3N0cmluZ2lmeTptLHBhcnNlOmd9fShKU09OLFJlZ0V4cCk7XG5cbmNsYXNzIERyaWxsZG93bk1hcCBleHRlbmRzIE1hcEhpZXJhcmNoeSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZHJpbGxkb3duIG1hcFxuICAgKiBAcGFyYW0ge09iamVjdH0gaGllcmFyY2h5IC0gYSBoaWVyYXJjaGljYWwgb2JqZWN0IGZvciBhIG1hcCB0byBiZSBidWlsdCB1cG9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb250YWluZXJJRCAtIGlkIG9mIHRoZSBjb250YWluZXIgdGhlIG1hcCB3aWxsIGJlIGRyYXduIHRvXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1hcHBvaW50Q2FsbGJhY2sgLSBleGVjdXRlZCB3aGVuIGEgbWFwcG9pbnQgKGNpdHkpIGlzIGNsaWNrZWRcbiAgICogQHBhcmFtIHtBcnJheS48e2Zyb206TnVtYmVyLCB0bzpOdW1iZXIsIGNvbG9yOlN0cmluZywgbmFtZTpTdHJpbmd9Pn0gZGF0YUNsYXNzZXMgLSBjb2xvciBiYW5kcyBmb3IgY29uZGl0aW9uYWwgZm9ybWF0dGluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgcGFzc2VkIHRvIEhpZ2hNYXAgdG8gcmVzdHlsZS9jb25maWd1cmUgaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29sb3JGbiAtIEEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgY3VzdG9tIGNvbG9yIGNvZGluZyBjb21wdXRhdGlvbiBiYXNlZCBvbiB2YWx1ZSBhbmQgdGFyZ2V0LlxuICAgKiBgY29sb3JGbmAgYWNjZXB0cyB0d28gYXR0cmlidXRlczogYHZhbHVlYCBhbmQgYHRhcmdldGAgYW5kIG11c3QgcmV0dXJuIGEgY29sb3Igc3RyaW5nIGJhc2VkIG9uIHRob3NlIHR3byBhdHRyaWJ1dGVzLlxuICAgKiBNYWtlIHN1cmUgaGllcmFyY2h5IGhhcyBgdGFyZ2V0YCBsb2FkZWQgZnJvbSBEQkRlc2lnbmVyIHRhYmxlIGludG8gZWFjaCBoaWVyYXJjaHkgbGV2ZWwsIG90aGVyd2lzZSBhIGRlZmF1bHQgY29uZmlnIGBkYXRhQ2xhc3Nlc2AgdGFrZXMgcHJlY2VkZW5jZSBvbiB2YWx1ZVxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGAgamF2YXNjcmlwdFxuICAgKiAgICB7XG4gICAqICAgIC8vc29tZSBjb25zdHJ1Y3RvciBjb25maWd1cmF0aW9uIGFib3ZlXG4gICAqICAgICAgY29sb3JGbjogZnVuY3Rpb24odmFsdWUsdGFyZ2V0KXtcbiAgICogICAgICAgIHJldHVybiAodmFsdWUhPW51bGwgJiYgdGFyZ2V0IT1udWxsKT8gKHZhbHVlIC0gdGFyZ2V0ID49IDApID8gXCIjMThCQzlDXCIgOiAoKHZhbHVlID49IDAuOSp0YXJnZXQpID8gXCIjRkY0OTAwXCIgOiBcIiNFNDUzMzVcIikgOiB1bmRlZmluZWQ7XG4gICAqICAgICAgfVxuICAgKiAgICAgLy9zb21lIGNvbnN0cnVjdG9yIGNvbmZpZ3VyYXRpb24gYmVsb3dcbiAgICogICAgfVxuICAgKiBgYGBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt2YWx1ZUNvbHVtbj0xXSAtIFplcm8tYmFzZWQgY29sdW1uIGluZGV4IHRoYXQgY29udGFpbnMgcHJpbWFyeSB2YWx1ZSB3aGljaCB3aWxsIGJlIHVzZWQgZm9yIG1hcCBjb2xvcmluZ1xuICAgKiAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgc291cmNlLHJvd2hlYWRlcnMsIC8vIGluaXRpYWwgdGFibGVcbiAgICBoaWVyYXJjaHksIGluaXRNYXA9XCJjdXN0b20vd29ybGQtaGlnaHJlczJcIiwgY29udGFpbmVySUQsIG1hcHBvaW50Q2FsbGJhY2ssXG4gICAgZXhjbHVkZUNvbHVtbnMsIGV4Y2x1ZGVSb3dzLCB2YWx1ZUNvbHVtbj0xLFxuICAgIGNvbG9yRm49ZnVuY3Rpb24odmFsdWUsdGFyZ2V0KXtcbiAgICAgICByZXR1cm4gdmFsdWUhPW51bGw/IHZhbHVlID49IDgwID8gXCIjNGNhZjUwXCIgOiAoKHZhbHVlIDw4MCAmJiB2YWx1ZT49NjAgKSA/IFwiI2ZmYzEwN1wiIDogXCIjZmY1NzIyXCIpIDogXCJibHVlXCI7XG4gICAgfSxcbiAgICBwYWdlU3RhdGVJZD0oZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI1BhZ2VTdGF0ZUlkJyk/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNQYWdlU3RhdGVJZCcpLnZhbHVlOiB1bmRlZmluZWQpLGxhbmd1YWdlQ29kZT05LHRhYmxlSUQsXG4gICAgbm9ybWFscyxub3JtYWxzU2VwYXJhdG9yLCBvcHRpb25zPXt9fT17fSl7XG4gICAgc3VwZXIoaGllcmFyY2h5LG5vcm1hbHMsbm9ybWFsc1NlcGFyYXRvcik7XG5cbiAgICB0aGlzLmNvbnN0cnVjdG9yLnBhcnNlVGFibGVEYXRhKHtzb3VyY2UsZXhjbHVkZVJvd3MsZXhjbHVkZUNvbHVtbnMscm93aGVhZGVyczpyb3doZWFkZXJzLm1hcChyaD0+cmhbMF0pLGZsYXRIaWVyYXJjaHk6dGhpcy5mbGF0SGllcmFyY2h5fSk7XG4gICAgaWYoY29sb3JGbiAmJiB0eXBlb2YgY29sb3JGbiA9PSBcImZ1bmN0aW9uXCIpe1xuICAgICAgdGhpcy5jb2xvckZuID0gY29sb3JGbjtcbiAgICB9XG4gICAgdGhpcy52YWx1ZUNvbHVtbiA9IHZhbHVlQ29sdW1uO1xuICAgIHRoaXMuaGllcmFyY2h5SUQ9IGhpZXJhcmNoeUlEO1xuICAgIHRoaXMuaGllcmFyY2h5Q29udHJvbElEPSBoaWVyYXJjaHlDb250cm9sSUQ7XG4gICAgdGhpcy5wYWdlU3RhdGVJZD1wYWdlU3RhdGVJZDtcbiAgICB0aGlzLmxhbmd1YWdlQ29kZT1sYW5ndWFnZUNvZGU7XG4gICAgdGhpcy50YWJsZUlEID0gdGFibGVJRDtcblxuICAgIGlmKG1hcHBvaW50Q2FsbGJhY2sgJiYgbWFwcG9pbnRDYWxsYmFjayE9bnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBtYXBwb2ludENhbGxiYWNrID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5tYXBwb2ludENhbGxiYWNrID0gbWFwcG9pbnRDYWxsYmFja1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm1hcHBvaW50Q2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpXG4gICAgICB9XG4gICAgfVxuICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZyA9IFJlcG9ydGFsQmFzZS5taXhpbihvcHRpb25zLCB7Lypjb2xvckF4aXM6e2RhdGFDbGFzc2VzfSovfSk7XG4gICAgaWYodHlwZW9mIEhpZ2hjaGFydHMgPT0gdW5kZWZpbmVkKXt0aHJvdyBuZXcgRXJyb3IoJ0hpZ2hjaGFydHMgbXVzdCBiZSBkZWNsYXJlZC4gUHJvYmFibHkgdGhleSBhcmUgbWlzc2luZycpfVxuICAgIGlmKHR5cGVvZiBIaWdoY2hhcnRzLm1hcHMgPT0gdW5kZWZpbmVkKXt0aHJvdyBuZXcgRXJyb3IoJ0hpZ2hNYXBzIG11c3QgYmUgbG9hZGVkLiBQcm9iYWJseSB0aGV5IGFyZSBtaXNzaW5nJyl9XG4gICAgLy9cbiAgICB0aGlzLmRyYXdNYXAocm93aGVhZGVycywgY29udGFpbmVySUQsIGluaXRNYXAsIGNvbmZpZyk7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VUYWJsZURhdGEoe3NvdXJjZSxleGNsdWRlUm93cyxleGNsdWRlQ29sdW1ucyxyb3doZWFkZXJzLCBmbGF0SGllcmFyY2h5fT17fSl7XG4gICAgbGV0IEFUID0gbmV3IEFnZ3JlZ2F0ZWRUYWJsZSh7XG4gICAgICBzb3VyY2UsXG4gICAgICBleGNsdWRlQ29sdW1ucyxleGNsdWRlUm93c1xuICAgIH0pO1xuICAgIGlmKHJvd2hlYWRlcnMgJiYgcm93aGVhZGVycyE9bnVsbCAmJiByb3doZWFkZXJzLmxlbmd0aD4wKXtcbiAgICAgIHJvd2hlYWRlcnMuZm9yRWFjaCgocmgsaSk9PntcbiAgICAgICAgaWYoIWZsYXRIaWVyYXJjaHlbcmhdLl9kYXRhKXtcbiAgICAgICAgICBmbGF0SGllcmFyY2h5W3JoXS5fZGF0YT1BVC5kYXRhW2ldLm1hcCgoZGF0YUl0ZW0saW5kZXgpPT57XG4gICAgICAgICAgICByZXR1cm57XG4gICAgICAgICAgICAgIHZhbHVlOiBkYXRhSXRlbS5kYXRhLFxuICAgICAgICAgICAgICB0aXRsZTogaW5kZXghPTA/QVQuY29sdW1uc1tpbmRleF0udGl0bGU6XCJSZWdpb25cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncm93aGVhZGVycyBtdXN0IGJlIHByZXNlbnQgdG8gcGFyc2UgZGF0YScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGN1c3RvbSBnZW9KU09OIGZpbGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcERhdGEgLSBpbml0aWFsIG1hcFxuICAgKiBAcGFyYW0ge0FycmF5fWNvdW50cmllc0xpc3QgLSBsaXN0IG9mIGNvdW50cmllcyBJRHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1hcE5hbWVcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVDdXN0b21HZW9KU09OKG1hcERhdGEsIGNvdW50cmllc0xpc3QsIG1hcE5hbWUpIHtcbiAgICBsZXQgZ2VvanNvbiA9IHtcbiAgICAgIHRpdGxlOlwiXCIsXG4gICAgICB2ZXJzaW9uOlwiMC4xLjBcIixcbiAgICAgIHR5cGU6XCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICAgICAgY29weXJpZ2h0OlwiQ29weXJpZ2h0IChjKSAyMDE1IEhpZ2hzb2Z0IEFTLCBCYXNlZCBvbiBkYXRhIGZyb20gTmF0dXJhbCBFYXJ0aFwiLFxuICAgICAgY29weXJpZ2h0U2hvcnQ6XCJOYXR1cmFsIEVhcnRoXCIsXG4gICAgICBjb3B5cmlnaHRVcmw6XCJodHRwOi8vd3d3Lm5hdHVyYWxlYXJ0aGRhdGEuY29tXCIsXG4gICAgICBjcnM6e1xuICAgICAgICB0eXBlOlwibmFtZVwiLFxuICAgICAgICBwcm9wZXJ0aWVzOntcbiAgICAgICAgICBuYW1lOlwidXJuOm9nYzpkZWY6Y3JzOkVQU0c6NTQwMDNcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJoYy10cmFuc2Zvcm1cIjp7XG4gICAgICAgIGRlZmF1bHQ6e1xuICAgICAgICAgIGNyczpcIitwcm9qPW1pbGwgK2xhdF8wPTAgK2xvbl8wPTAgK3hfMD0wICt5XzA9MCArUl9BICtkYXR1bT1XR1M4NCArdW5pdHM9bSArbm9fZGVmc1wiLFxuICAgICAgICAgIHNjYWxlOjEuNzIxODI3ODE2NTRlLTA1LFxuICAgICAgICAgIGpzb25yZXM6MTUuNSxcbiAgICAgICAgICBqc29ubWFyZ2luWDotOTk5LFxuICAgICAgICAgIGpzb25tYXJnaW5ZOjk4NTEuMCxcbiAgICAgICAgICB4b2Zmc2V0Oi0xOTQ5NTM1Ni4zNjkzLFxuICAgICAgICAgIHlvZmZzZXQ6MTI2MzU5MDguMTk4MlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmVhdHVyZXM6IERyaWxsZG93bk1hcC5nZXRGZWF0dXJlcyhjb3VudHJpZXNMaXN0LG1hcERhdGEpLy9bW11dXG4gICAgfTtcblxuICAgIGdlb2pzb24udGl0bGUgPSBtYXBOYW1lO1xuICAgIHJldHVybiBnZW9qc29uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhcnJheSBvZiBmZWF0dXJlcyBmcm9tIGdlb0pTT04gZmlsZVxuICAgKiBAcGFyYW0ge0FycmF5IHwgU3RyaW5nfWNvdW50cmllc0xpc3QgLSBjb3VudHJpZXMgSURzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBEYXRhIC0geW91ciBpbml0aWFsIG1hcFxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IGZvciBnZW9qc29uIGZlYXR1cmVzIGNvbXBhcmluZ1xuICAgKiBAcmV0dXJucyB7QXJyYXl9IGZlYXR1cmVzIGxpc3RcbiAgICovXG4gIHN0YXRpYyBnZXRGZWF0dXJlcyhjb3VudHJpZXNMaXN0LG1hcERhdGEsa2V5PVwiaGMta2V5XCIpe1xuICAgIGlmICh0eXBlb2YgY291bnRyaWVzTGlzdCA9PT0gJ3N0cmluZycpe1xuICAgICAgcmV0dXJuIG1hcERhdGEuZmVhdHVyZXMuZmlsdGVyKGZlYXR1cmUgPT4gZmVhdHVyZS5wcm9wZXJ0aWVzW2tleV0gPT09IGNvdW50cmllc0xpc3QpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb3VudHJpZXNMaXN0KSl7XG4gICAgICByZXR1cm4gbWFwRGF0YS5mZWF0dXJlcy5maWx0ZXIoZmVhdHVyZSA9PiBjb3VudHJpZXNMaXN0LmluZGV4T2YoZmVhdHVyZS5wcm9wZXJ0aWVzW2tleV0pIT0tMSk7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogR2V0IHNlcmllcyBmb3IgdGhlIGZpcnN0IHRpbWUgbWFwIGluaXRpYWxpemF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjdXJMVkwgLSBjdXJyZW50IGxldmVsIGluIGhpZXJhcmNoeVxuICAgKiBAcGFyYW0ge0FycmF5fSBbc2VyaWVzPVtdXSAtIHNlcmllc1xuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqICovXG4gIGluaXRNYXAoY3VyTFZMLCBzZXJpZXMgPSBbXSl7XG4gICAgY3VyTFZMLnN1YmNlbGxzLmZvckVhY2goIHN1YmNlbGwgPT4ge1xuICAgICAgaWYgKHN1YmNlbGwubWFwSUQpIHtcbiAgICAgICAgbGV0IHNlcmllc0l0ZW0gPSB0aGlzLmNvbXBvc2VTZXJpZXMoc3ViY2VsbCk7XG4gICAgICAgIHNlcmllcy5wdXNoKHNlcmllc0l0ZW0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZXJpZXM7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBtYXAgZnJvbSBIaWdoTWFwcyBtYXAgY29sbGVjdGlvblxuICAgKiBAcGFyYW0gc291cmNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgc3RhdGljIGxvYWRNYXAoc291cmNlKXtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KT0+e1xuICAgICAgalF1ZXJ5LmdldFNjcmlwdCgnaHR0cHM6Ly9jb2RlLmhpZ2hjaGFydHMuY29tL21hcGRhdGEvJyArIHNvdXJjZSArICcuanMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlc29sdmUoSGlnaGNoYXJ0cy5tYXBzW3NvdXJjZV0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0UHJpbWFyeVZhbHVlKGxldmVsLHZhbHVlQ29sdW1uKXtcbiAgICByZXR1cm4gbGV2ZWwuX2RhdGFbdmFsdWVDb2x1bW5dLnZhbHVlO1xuICB9XG5cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNpbmdsZSBzZXJpZXMgZGF0YSBmb3IgSGlnaE1hcCBzZXJpZXMgb3B0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZXZlbCAtIGEgbGV2ZWwgaW4gaGllcmFyY2h5XG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBnZXRTZXJpZXNEYXRhKGxldmVsKXtcbiAgICBsZXQgZHJpbGxkb3duID0gbGV2ZWwuc3ViY2VsbHMgPyBsZXZlbC50ZXh0IDogbnVsbDtcbiAgICBpZiAodHlwZW9mIGxldmVsLm1hcElEID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIGRyaWxsZG93bjogZHJpbGxkb3duLFxuICAgICAgICBjb2RlOiBsZXZlbC5tYXBJRCxcbiAgICAgICAgdmFsdWU6IERyaWxsZG93bk1hcC5nZXRQcmltYXJ5VmFsdWUobGV2ZWwsdGhpcy52YWx1ZUNvbHVtbiksXG4gICAgICAgIGRhdGE6IGxldmVsLl9kYXRhLFxuICAgICAgICAvL2NvbG9yOiBEcmlsbGRvd25NYXAuY29tcHV0ZUNvbG9yKHRoaXMuY29sb3JGbixEcmlsbGRvd25NYXAuZ2V0UHJpbWFyeVZhbHVlKGxldmVsLHRoaXMudmFsdWVDb2x1bW4pLGxldmVsLnRhcmdldClcbiAgICAgIH1dXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGxldmVsLm1hcElEKSl7XG4gICAgICByZXR1cm4gbGV2ZWwubWFwSUQubWFwKG1hcElEPT4ge1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZHJpbGxkb3duOiBkcmlsbGRvd24sXG4gICAgICAgICAgY29kZTogbWFwSUQsXG4gICAgICAgICAgdmFsdWU6IERyaWxsZG93bk1hcC5nZXRQcmltYXJ5VmFsdWUobGV2ZWwsdGhpcy52YWx1ZUNvbHVtbiksXG4gICAgICAgICAgZGF0YTogbGV2ZWwuX2RhdGEsXG4gICAgICAgICAgLy9jb2xvcjogRHJpbGxkb3duTWFwLmNvbXB1dGVDb2xvcih0aGlzLmNvbG9yRm4sRHJpbGxkb3duTWFwLmdldFByaW1hcnlWYWx1ZShsZXZlbCx0aGlzLnZhbHVlQ29sdW1uKSxsZXZlbC50YXJnZXQpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIGVsZW1lbnQgaXMgY29ycnVwdGVkXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBgY29sb3JGbmAgcGFzc2VkIGJ5IHVzZXIgdG8gY29tcHV0ZSBjb2xvciBieSBwYXNzaW5nIGB2YWx1ZWAgYW5kIGB0YXJnZXRgIHRvIGl0XG4gICAqICovXG4gIHN0YXRpYyBjb21wdXRlQ29sb3IoY29sb3JGbiwgdmFsdWUsIHRhcmdldCl7XG4gICAgaWYoY29sb3JGbil7XG4gICAgICByZXR1cm4gY29sb3JGbih2YWx1ZSwgdGFyZ2V0KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBpY2sgYSBjb2xvciBmb3IgbWFwcG9pbnRcbiAgICogQHBhcmFtIHZhbFxuICAgKiBAcGFyYW0gZGF0YUNsYXNzZXNcbiAgICogQHJldHVybnMge1N0cmluZ30gcG9pbnQgY29sb3JcbiAgICovXG4gIHN0YXRpYyBnZXRDb2xvcih2YWwsIGRhdGFDbGFzc2VzKXtcbiAgICBsZXQgY29sb3I7XG4gICAgZGF0YUNsYXNzZXMuZm9yRWFjaChkYXRhQ2xhc3MgPT57XG4gICAgICBpZih2YWwgPj0gZGF0YUNsYXNzLmZyb20gJiYgdmFsIDwgZGF0YUNsYXNzLnRvKSB7XG4gICAgICAgIGNvbG9yID0gZGF0YUNsYXNzLmNvbG9yO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzaW5nbGUgbWFwcG9pbnQgc2VyaWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdWJjZWxsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBEYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFydFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBzZXJpZXMgZm9yIG1hcCBwb2ludHNcbiAgICogKi9cbiAgZ2V0Q29vcmRpbmF0ZVNlcmllcyhzdWJjZWxsLG1hcERhdGEsY2hhcnQpe1xuICAgIGNoYXJ0Lm1hcFRyYW5zZm9ybXMgPSBtYXBEYXRhID8gIG1hcERhdGFbXCJoYy10cmFuc2Zvcm1cIl0gOiBIaWdoY2hhcnRzLm1hcHNbXCJjdXN0b20vd29ybGQtaGlnaHJlczJcIl1bXCJoYy10cmFuc2Zvcm1cIl07XG4gICAgbGV0IHBvcyA9IGNoYXJ0LmZyb21MYXRMb25Ub1BvaW50KHsgbGF0OiBzdWJjZWxsLmNvb3JkaW5hdGVzWzBdLCBsb246IHN1YmNlbGwuY29vcmRpbmF0ZXNbMV0gfSk7XG4gICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgIHR5cGU6IFwibWFwcG9pbnRcIiwgLy8gb3IgXCJtYXBidWJibGUsXG4gICAgICBuYW1lOiBzdWJjZWxsLnRleHQsXG4gICAgICBtYXJrZXI6IHtcbiAgICAgICAgbGluZUNvbG9yOiBcImJsYWNrXCIsXG4gICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgcmFkaXVzOiA0LFxuICAgICAgICBzeW1ib2w6IFwiY2lyY2xlXCIsXG4gICAgICB9LFxuICAgICAgZGF0YTogW3tcbiAgICAgICAgY29sb3I6IERyaWxsZG93bk1hcC5nZXRDb2xvcihzdWJjZWxsLnZhbHVlLCB0aGlzLmNvbmZpZy5jb2xvckF4aXMuZGF0YUNsYXNzZXMpLFxuICAgICAgICBuYW1lOiBzdWJjZWxsLnRleHQsXG4gICAgICAgIHZhbHVlOiBzdWJjZWxsLnZhbHVlLFxuICAgICAgICB4OiBwb3MueCxcbiAgICAgICAgeTogcG9zLnlcbiAgICAgIH1dXG4gICAgfTtcbiAgICBpZih0aGlzLm1hcHBvaW50Q2FsbGJhY2spe1xuICAgICAgY29uZmlnLmV2ZW50cyA9IHtcbiAgICAgICAgY2xpY2s6IHRoaXMubWFwcG9pbnRDYWxsYmFja1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29uZmlnXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNpbmdsZSBzZXJpZXMgaXRlbSBmb3IgSGlnaG1hcHMgc2VyaWVzIG9wdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gc3ViY2VsbCAtIGEgc3ViY2VsbFxuICAgKiBAcGFyYW0gbWFwRGF0YVxuICAgKiBAcGFyYW0gY2hhcnRcbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBzZXJpZXNcbiAgICovXG4gIGNvbXBvc2VTZXJpZXMoc3ViY2VsbCxtYXBEYXRhLGNoYXJ0KXtcbiAgICBpZighc3ViY2VsbC5jb29yZGluYXRlcykge1xuICAgICAgbWFwRGF0YSA9IG1hcERhdGEgPyBIaWdoY2hhcnRzLmdlb2pzb24oRHJpbGxkb3duTWFwLmNyZWF0ZUN1c3RvbUdlb0pTT04obWFwRGF0YSwgc3ViY2VsbC5tYXBJRCwgc3ViY2VsbC50ZXh0KSkgOiBIaWdoY2hhcnRzLmdlb2pzb24oRHJpbGxkb3duTWFwLmNyZWF0ZUN1c3RvbUdlb0pTT04oSGlnaGNoYXJ0cy5tYXBzWydjdXN0b20vd29ybGQtaGlnaHJlczInXSwgc3ViY2VsbC5tYXBJRCwgc3ViY2VsbC50ZXh0KSk7XG4gICAgICBpZiAoc3ViY2VsbC5tYXBJRCkge1xuICAgICAgICBsZXQgdGFyZ2V0ID0gc3ViY2VsbC50YXJnZXQ7XG4gICAgICAgIGlmKCF0YXJnZXQgfHwgdGFyZ2V0ID09IG51bGwpe1xuICAgICAgICAgIHRhcmdldCA9IHRoaXMuaGllcmFyY2h5WzBdLnRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IHN1YmNlbGwudGV4dCxcbiAgICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgICBlbmFibGVkOsKgdHJ1ZSxcbiAgICAgICAgICAgIGZvcm1hdHRlcjrCoGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIGlmwqAodGhpcy5zZXJpZXMuZGF0YVswXS5uYW1lwqA9PcKgdGhpcy5wb2ludC5uYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmllcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAvKnRvb2x0aXA6IHtcbiAgICAgICAgICAgcG9pbnRGb3JtYXQ6ICdOUFMgOiB7cG9pbnQudmFsdWV9J1xuICAgICAgICAgICB9LCovXG4gICAgICAgICAgY29sb3I6RHJpbGxkb3duTWFwLmNvbXB1dGVDb2xvcih0aGlzLmNvbG9yRm4sRHJpbGxkb3duTWFwLmdldFByaW1hcnlWYWx1ZShzdWJjZWxsLHRoaXMudmFsdWVDb2x1bW4pLHRhcmdldCksXG4gICAgICAgICAgYWxsQXJlYXM6IGZhbHNlLFxuICAgICAgICAgIHBhcmVudDogc3ViY2VsbC5wYXJlbnQudGV4dCxcbiAgICAgICAgICBtYXBEYXRhLFxuICAgICAgICAgIGpvaW5CeTogWydoYy1rZXknLCAnY29kZSddLFxuICAgICAgICAgIGRhdGE6IHRoaXMuZ2V0U2VyaWVzRGF0YShzdWJjZWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcmllcyhzdWJjZWxsLG1hcERhdGEsY2hhcnQpfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldCBzdWJjZWxsIGJ5IHRleHQgcmF0aGVyIHRoYW4gYnkgaWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGN1ckxWTCAtIGN1cnJlbnQgbGV2ZWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBuYW1lIG9mIHRoZSBzdWJjZWxsIHdlJ3JlIGxvb2tpbmcgZm9yXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYSBzdWJjZWxsIHdoaWNoIGhhcyB0aGF0IG5hbWVcbiAgICogKi9cbiAgc3RhdGljIGdldExldmVsQnlOYW1lKGN1ckxWTCxuYW1lKXtcbiAgICByZXR1cm4gY3VyTFZMLnN1YmNlbGxzLmZpbHRlcihlbCA9PiBlbC50ZXh0ID09IG5hbWUpWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgeW91ciBtYXAgdmlldyBhZnRlciBkcmlsbGRvd24gY2xpY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IGN1ckxWTFxuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhcnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGUgLSBkcmlsbGRvd24gZXZlbnQgb2JqZWN0XG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgY3VyTFZMXG4gICAqL1xuICB1cGRhdGVNYXAoY3VyTFZMLCBjaGFydCwgZSl7XG4gICAgLy9jdXJMVkwgPSBjdXJMVkwuc3ViY2VsbHMuZmlsdGVyKCBlbCA9PiBlbC50ZXh0ID09IGUucG9pbnQuc2VyaWVzLm5hbWUpWzBdO1xuICAgIGlmKGN1ckxWTCAmJiBjdXJMVkwubWFwTmFtZSl7Ly8gaWYgd2UgaGF2ZSBhbm90aGVyIG1hcCB0byBsb2FkXG4gICAgICBsZXQgbWFwID0gRHJpbGxkb3duTWFwLmxvYWRNYXAoY3VyTFZMLm1hcE5hbWUpO1xuICAgICAgbWFwLnRoZW4obWFwRGF0YT0+e1xuICAgICAgICB0aGlzLmFkZFNlcmllcyhjdXJMVkwsY2hhcnQsZSxtYXBEYXRhKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmKGN1ckxWTCAmJiAhY3VyTFZMLm1hcE5hbWUpe1xuICAgICAgdGhpcy5hZGRTZXJpZXMoY3VyTFZMLGNoYXJ0LGUpO1xuICAgIH1cbiAgICAvL3JldHVybiBjdXJMVkw7XG4gIH1cblxuICAvKipcbiAgICogQ29tcG9zZXMgYSBzZXJpZXMgZm9yIHlvdXIgSGlnaE1hcHMgb3B0aW9ucyBjb25maWdcbiAgICogQHBhcmFtIHtPYmplY3R9IGN1ckxWTFxuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhcnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGUgLSBkcmlsbGRvd24gZXZlbnQgb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBEYXRhIC0gbWFwRGF0YSBnZW9KU09OXG4gICAqL1xuICBhZGRTZXJpZXMoY3VyTFZMLGNoYXJ0LGUsbWFwRGF0YSl7XG4gICAgaWYgKGN1ckxWTC5zdWJjZWxscyl7IC8vIGlmIGl0J3MgYW4gZW5kIHBvaW50XG4gICAgICBpZihjdXJMVkwuc3ViY2VsbHNbMF0uY29vcmRpbmF0ZXMpe1xuICAgICAgICBsZXQgc2VyaWVzSXRlbSA9IHRoaXMuY29tcG9zZVNlcmllcyhjdXJMVkwsbWFwRGF0YSwgY2hhcnQpO1xuICAgICAgICBzZXJpZXNJdGVtLmRhdGEuZm9yRWFjaChkYXRhSXRlbSA9PiB7XG4gICAgICAgICAgZGF0YUl0ZW0uZHJpbGxkb3duID0gbnVsbDtcbiAgICAgICAgICBkYXRhSXRlbS52YWx1ZSA9IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIGNoYXJ0LmFkZFNpbmdsZVNlcmllc0FzRHJpbGxkb3duKGUucG9pbnQsIHNlcmllc0l0ZW0pO1xuICAgICAgfVxuICAgICAgY3VyTFZMLnN1YmNlbGxzLmZvckVhY2goc3ViY2VsbCA9PiB7XG4gICAgICAgIGlmKCFzdWJjZWxsLm1hcElEICYmICFzdWJjZWxsLmNvb3JkaW5hdGVzKSByZXR1cm47XG5cbiAgICAgICAgbGV0IHNlcmllc0l0ZW0gPSB0aGlzLmNvbXBvc2VTZXJpZXMoc3ViY2VsbCxtYXBEYXRhLCBjaGFydCk7XG4gICAgICAgIGNoYXJ0LmFkZFNpbmdsZVNlcmllc0FzRHJpbGxkb3duKGUucG9pbnQsIHNlcmllc0l0ZW0pO1xuICAgICAgfSk7XG4gICAgICBjaGFydC5hcHBseURyaWxsZG93bigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgc2VyaWVzSXRlbSA9IHRoaXMuY29tcG9zZVNlcmllcyhjdXJMVkwsIG1hcERhdGEsIGNoYXJ0KTtcbiAgICAgIHNlcmllc0l0ZW0uZGF0YS5tYXAoZGF0YUl0ZW0gPT4ge1xuICAgICAgICBkYXRhSXRlbS5kcmlsbGRvd24gPSBudWxsO1xuICAgICAgICBkYXRhSXRlbS52YWx1ZSA9IG51bGxcbiAgICAgIH0pO1xuICAgICAgY2hhcnQuYWRkU2VyaWVzQXNEcmlsbGRvd24oZS5wb2ludCwgc2VyaWVzSXRlbSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBjaGFydCBzdWJ0aXRsZSByZXR1cm5pbmcgcmVnaW9uIGFuZCBtYWluIHZhbHVlXG4gICAqICovXG4gIGdldCBzdWJ0aXRsZSgpe1xuICAgIC8vcmV0dXJuIGAke3RoaXMuY3VyTFZMLl9kYXRhWzBdLnRpdGxlfTogJHt0aGlzLmN1ckxWTC5fZGF0YVswXS52YWx1ZX08YnI+ICR7dGhpcy5jdXJMVkwuX2RhdGFbdGhpcy52YWx1ZUNvbHVtbl0udGl0bGV9OiAke3RoaXMuY3VyTFZMLl9kYXRhW3RoaXMudmFsdWVDb2x1bW5dLnZhbHVlfWBcbiAgICByZXR1cm4gdGhpcy5jdXJMVkwuX2RhdGEubWFwKChpdGVtKT0+e1xuICAgICAgcmV0dXJuIGA8c3BhbiBjbGFzcz1cInRvb2x0aXAtbGV2ZWwtbGFiZWxcIj4ke2l0ZW0udGl0bGV9Ojwvc3Bhbj48c3BhbiBjbGFzcz1cInRvb2x0aXAtbGV2ZWwtdmFsdWVcIj4gJHtpdGVtLnZhbHVlfTwvc3Bhbj5gXG4gICAgfSkuam9pbihcIjxiciAvPlwiKVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHNlcmlhbGl6ZWQgZGF0YXNldCBmb3IgYSB0b29sdGlwXG4gICAqICovXG4gIGdldFRvb2x0aXAoKXtcbiAgICBsZXQgZGF0YSA9IHRoaXMuY3VyTFZMLl9kYXRhO1xuICAgIHJldHVybiBkYXRhLm1hcCgoaXRlbSxpbmRleCk9PmA8c3BhbiBjbGFzcz1cInRvb2x0aXAtbGV2ZWwtbGFiZWxcIj4ke2l0ZW0udGl0bGV9Ojwvc3Bhbj48c3BhbiBjbGFzcz1cInRvb2x0aXAtbGV2ZWwtdmFsdWVcIj4ge3BvaW50LmRhdGEuJHtpbmRleH0udmFsdWV9PC9zcGFuPmApLmpvaW4oXCI8YnIgLz5cIilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gaGllcmFyY2h5XG4gICAqIEBwYXJhbSBjb250YWluZXJJRFxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKi9cbiAgZHJhd01hcChyb3doZWFkZXJzLCBjb250YWluZXJJRCwgaW5pdE1hcCwgb3B0aW9ucyl7XG4gICAgdGhpcy5jdXJMVkwgPSB0aGlzLmZsYXRIaWVyYXJjaHlbcm93aGVhZGVyc1swXV07XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBjb25maWcgPSB7XG4gICAgICBsYW5nOiB7XG4gICAgICAgIGRyaWxsVXBUZXh0OiAnPCB0byB7c2VyaWVzLnBhcmVudH0nXG4gICAgICB9LFxuICAgICAgdG9vbHRpcDoge1xuICAgICAgICBwb2ludEZvcm1hdDogc2VsZi5nZXRUb29sdGlwKClcbiAgICAgIH0sXG4gICAgICB0aXRsZToge1xuICAgICAgICB0ZXh0OiAnJ1xuICAgICAgfSxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICB9LFxuICAgICAgcGxvdE9wdGlvbnM6e1xuICAgICAgICBzZXJpZXM6IHtcbiAgICAgICAgICBzdGF0ZXM6e1xuICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgIGFuaW1hdGlvbjrCoGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwb2ludDoge1xuICAgICAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICAgIG1vdXNlT3ZlcjrCoGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWVzLmRhdGEuZm9yRWFjaChcbiAgICAgICAgICAgICAgICAgIGVsID0+IGVsLnNldFN0YXRlKFwiaG92ZXJcIilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1vdXNlT3V0OsKgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJpZXMuZGF0YS5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICAgZWwgPT4gZWwuc2V0U3RhdGUoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1hcE5hdmlnYXRpb246IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgYnV0dG9uczp7XG4gICAgICAgICAgem9vbUluOntcbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246XCJib3R0b21cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgem9vbU91dDp7XG4gICAgICAgICAgICB2ZXJ0aWNhbEFsaWduOlwiYm90dG9tXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzdWJ0aXRsZTp7XG4gICAgICAgIGFsaWduOiAncmlnaHQnLFxuICAgICAgICB0ZXh0OiBzZWxmLnN1YnRpdGxlLFxuICAgICAgICBmbG9hdGluZzp0cnVlXG4gICAgICB9LFxuICAgICAgZHJpbGxkb3duOntcbiAgICAgICAgZHJpbGxVcEJ1dHRvbjoge1xuICAgICAgICAgIHBvc2l0aW9uOntcbiAgICAgICAgICAgIGFsaWduOlwibGVmdFwiLFxuICAgICAgICAgICAgeTowXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWxhdGl2ZVRvOidzcGFjaW5nQm94J1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2hhcnQ6e1xuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICBkcmlsbGRvd246IGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgLy90aGlzID09IGNoYXJ0IHJlZmVyZW5jZTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coQ2lyY3VsYXJKU09OLnBhcnNlKENpcmN1bGFySlNPTi5zdHJpbmdpZnkoZS5wb2ludCkpKTtcbiAgICAgICAgICAgIGxldCBjaGFydCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgc2VsZi5jdXJMVkwgPSBEcmlsbGRvd25NYXAuZ2V0TGV2ZWxCeU5hbWUoc2VsZi5jdXJMVkwsZS5wb2ludC5zZXJpZXMubmFtZSk7XG4gICAgICAgICAgICBsZXQgY3VyTFZMID0gc2VsZi5jdXJMVkw7XG4gICAgICAgICAgICBpZihjdXJMVkwpe1xuICAgICAgICAgICAgICBjaGFydC5zaG93TG9hZGluZygnZmV0Y2hpbmcgZGF0YScpO1xuICAgICAgICAgICAgICBsZXQgdGFibGUgPSBBc3luY0hpZXJhcmNoeVRhYmxlLmZldGNoQ2hpbGRUYWJsZShjdXJMVkwuaWQsIGN1ckxWTC5wYXJlbnQ/Y3VyTFZMLnBhcmVudC5pZDpudWxsLCBzZWxmLnRhYmxlSUQsIHNlbGYucGFnZVN0YXRlSWQpXG4gICAgICAgICAgICAgICAgLnRoZW4odGFibGU9PntcbiAgICAgICAgICAgICAgICAgIC8vIHBhcnNlIGRhdGEgbG9hZGVkIGZyb20gdGFibGVcbiAgICAgICAgICAgICAgICAgIERyaWxsZG93bk1hcC5wYXJzZVRhYmxlRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTp0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZVJvd3M6MCxcbiAgICAgICAgICAgICAgICAgICAgcm93aGVhZGVyczpjdXJMVkwuc3ViY2VsbHMubWFwKGx2bD0+bHZsLmlkKSxcbiAgICAgICAgICAgICAgICAgICAgZmxhdEhpZXJhcmNoeTpzZWxmLmZsYXRIaWVyYXJjaHlcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVNYXAoY3VyTFZMLCBjaGFydCwgZSk7XG4gICAgICAgICAgICAgICAgICBjaGFydC5zdWJ0aXRsZS51cGRhdGUoe3RleHQ6IHNlbGYuc3VidGl0bGV9KTtcbiAgICAgICAgICAgICAgICAgIGNoYXJ0LmhpZGVMb2FkaW5nKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkcmlsbHVwYWxsOiBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgIHNlbGYuY3VyTFZMID0gc2VsZi5jdXJMVkwucGFyZW50O1xuICAgICAgICAgICAgaWYgKHNlbGYuY3VyTFZMKXtcbiAgICAgICAgICAgICAgZS50YXJnZXQuc3VidGl0bGUudXBkYXRlKHt0ZXh0OiBzZWxmLnN1YnRpdGxlfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2VyaWVzOiBzZWxmLmluaXRNYXAoc2VsZi5jdXJMVkwsW3tcbiAgICAgICAgc2hvd0luTGVnZW5kOmZhbHNlLFxuICAgICAgICBtYXBEYXRhOiBIaWdoY2hhcnRzLm1hcHNbaW5pdE1hcF1cbiAgICAgIH1dKVxuICAgIH07XG5cbiAgICBjb25maWcgPSBSZXBvcnRhbEJhc2UubWl4aW4oY29uZmlnLG9wdGlvbnMpO1xuICAgIEhpZ2hjaGFydHMubWFwQ2hhcnQoIGNvbnRhaW5lcklELCBjb25maWcpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERyaWxsZG93bk1hcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9EcmlsbGRvd25NYXAuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 14 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Created by IvanP on 26.12.2016.\n */\nvar MapHierarchy = function () {\n  function MapHierarchy(hierarchy, normals, normalsSeparator) {\n    _classCallCheck(this, MapHierarchy);\n\n    //this.aHierarchy = hierarchy;\n    this.flatHierarchy = hierarchy;\n    this.hierarchy = this.constructor.processHierarchy(this.flatHierarchy, normals, normalsSeparator);\n    this.constructor.addMapIDsToHierarchyLevel(this.hierarchy);\n  }\n\n  /**\n   * Processes hierarchy array by assigning parent-child relations and returning those that don't have a parent\n   * @param {Object} flatHierarchy - a flat hierarchy object with ids as keys\n   * @param {Object} [normals={}] - an object where keys myst coincide with column ids (thus be identical to keys in `item`). `normals` doesn't require for all keys from `item` to be present, only those that need to be normalised to a different type\n   * @param {String} [separator=','] - a separator array items are serialized with, by default it's a comma (`,`)\n   * */\n\n\n  _createClass(MapHierarchy, null, [{\n    key: 'processHierarchy',\n    value: function processHierarchy(flatHierarchy) {\n      var normals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var separator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ',';\n\n      var orphans = [],\n          toNormalize = Object.keys(normals).length > 0;\n      for (var key in flatHierarchy) {\n        var item = flatHierarchy[key];\n        if (toNormalize) MapHierarchy.normalize(item, normals);\n\n        // map item to parent\n        if (item.parent && item.parent != null && item.parent.length > 0) {\n          item.parent = flatHierarchy[item.parent];\n          item.parent.subcells = item.parent.subcells || [];\n          //TODO: delete this when value is in place\n          //item.value = Math.random()*100;\n\n          item.parent.subcells.push(item);\n        } else {\n          orphans.push(item);\n        }\n      }\n      return orphans;\n    }\n  }, {\n    key: 'composeFlatHierarchy',\n    value: function composeFlatHierarchy(hierarchy, normals) {\n      var o = {};\n      var toNormalize = normals.keys().length > 0;\n      hierarchy.forEach(function (item) {\n        if (toNormalize) MapHierarchy.normalize(item, normals);\n        o[item.id] = item;\n      });\n      return o;\n    }\n\n    /**\n     * normalizes a string value to a certain format.\n     * - `arrayString` - normalizes comma-separated items to an Array of Strings, i.e \"haha\", \"lala\" would be [\"haha\", \"lala\"]\n     * - `arrayNumber` - normalizes comma-separated items to an Array of Floats, i.e \"-13.41\", \"48.66\" would be [-13.41, 48.66]\n     * - `string` - returns the string as is\n     * - `number` - parses the string as a Float\n     * - `boolean` - parses the string as a Boolean, case insensitive\n     *\n     * @param {Object} item - item to match contents against `normals`\n     * @param {Object} [normals={}] - an object where keys myst coincide with column ids (thus be identical to keys in `item`). `normals` doesn't require for all keys from `item` to be present, only those that need to be normalised to a different type\n     * @param {String} [separator=','] - a separator array items are serialized with, by default it's a comma (`,`)\n     * */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(item) {\n      var normals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var separator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ',';\n\n      var parser = {\n        stringArray: function stringArray(val) {\n          return val.split(separator);\n        },\n        numberArray: function numberArray(val) {\n          return val.split(separator).map(function (i) {\n            return parseFloat(i);\n          });\n        },\n        string: function string(val) {\n          return val.trim();\n        },\n        number: function number(val) {\n          return val != null && !isNaN(parseFloat(val)) ? parseFloat(val) : null;\n        },\n        boolean: function boolean(val) {\n          return val.toLowerCase() == \"true\" || val == \"1\";\n        }\n      };\n      for (var normal in normals) {\n        if (item[normal]) {\n          // property exists in object\n          if (item[normal].length > 0) {\n            item[normal] = parser[normals[normal]](item[normal]);\n          } else {\n            delete item[normal];\n          }\n        }\n      }\n    }\n\n    /**\n     * Updates initial hierarchy\n     * @param hierarchy\n     * @param parent - hierarchy level parent\n     */\n\n  }, {\n    key: 'addMapIDsToHierarchyLevel',\n    value: function addMapIDsToHierarchyLevel(hierarchy) {\n      var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      hierarchy.forEach(function (subcell) {\n        //subcell.parent = parent;\n        //subcell.value = Math.random()*100;\n        if (subcell.parent && subcell.parent != null && subcell.parent.mapName) {\n          subcell.mapName = subcell.parent.mapName;\n        }\n        if (subcell.subcells) {\n          MapHierarchy.addMapIDsToHierarchyLevel(subcell.subcells, subcell);\n        }\n        if (subcell.parent && subcell.mapID && !subcell.parent.mapName) {\n          if (!subcell.parent.mapID) subcell.parent.mapID = [];\n          subcell.parent.mapID = subcell.parent.mapID.concat(subcell.mapID);\n        }\n      });\n    }\n  }]);\n\n  return MapHierarchy;\n}();\n\nexports.default = MapHierarchy;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFwLWhpZXJhcmNoeS5qcz80NWFhIl0sIm5hbWVzIjpbIk1hcEhpZXJhcmNoeSIsImhpZXJhcmNoeSIsIm5vcm1hbHMiLCJub3JtYWxzU2VwYXJhdG9yIiwiZmxhdEhpZXJhcmNoeSIsImNvbnN0cnVjdG9yIiwicHJvY2Vzc0hpZXJhcmNoeSIsImFkZE1hcElEc1RvSGllcmFyY2h5TGV2ZWwiLCJzZXBhcmF0b3IiLCJvcnBoYW5zIiwidG9Ob3JtYWxpemUiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwia2V5IiwiaXRlbSIsIm5vcm1hbGl6ZSIsInBhcmVudCIsInN1YmNlbGxzIiwicHVzaCIsIm8iLCJmb3JFYWNoIiwiaWQiLCJwYXJzZXIiLCJzdHJpbmdBcnJheSIsInZhbCIsInNwbGl0IiwibnVtYmVyQXJyYXkiLCJtYXAiLCJwYXJzZUZsb2F0IiwiaSIsInN0cmluZyIsInRyaW0iLCJudW1iZXIiLCJpc05hTiIsImJvb2xlYW4iLCJ0b0xvd2VyQ2FzZSIsIm5vcm1hbCIsInN1YmNlbGwiLCJtYXBOYW1lIiwibWFwSUQiLCJjb25jYXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7O0lBR01BLFk7QUFDSix3QkFBWUMsU0FBWixFQUFzQkMsT0FBdEIsRUFBOEJDLGdCQUE5QixFQUErQztBQUFBOztBQUM3QztBQUNBLFNBQUtDLGFBQUwsR0FBcUJILFNBQXJCO0FBQ0EsU0FBS0EsU0FBTCxHQUFpQixLQUFLSSxXQUFMLENBQWlCQyxnQkFBakIsQ0FBa0MsS0FBS0YsYUFBdkMsRUFBcURGLE9BQXJELEVBQTZEQyxnQkFBN0QsQ0FBakI7QUFDQSxTQUFLRSxXQUFMLENBQWlCRSx5QkFBakIsQ0FBMkMsS0FBS04sU0FBaEQ7QUFDRDs7QUFFRDs7Ozs7Ozs7OztxQ0FNd0JHLGEsRUFBdUM7QUFBQSxVQUF6QkYsT0FBeUIsdUVBQWpCLEVBQWlCO0FBQUEsVUFBZE0sU0FBYyx1RUFBSixHQUFJOztBQUM3RCxVQUFJQyxVQUFVLEVBQWQ7QUFBQSxVQUNJQyxjQUFjQyxPQUFPQyxJQUFQLENBQVlWLE9BQVosRUFBcUJXLE1BQXJCLEdBQTRCLENBRDlDO0FBRUEsV0FBSSxJQUFJQyxHQUFSLElBQWVWLGFBQWYsRUFBNkI7QUFDM0IsWUFBSVcsT0FBT1gsY0FBY1UsR0FBZCxDQUFYO0FBQ0EsWUFBR0osV0FBSCxFQUFlVixhQUFhZ0IsU0FBYixDQUF1QkQsSUFBdkIsRUFBNEJiLE9BQTVCOztBQUVmO0FBQ0EsWUFBR2EsS0FBS0UsTUFBTCxJQUFlRixLQUFLRSxNQUFMLElBQWEsSUFBNUIsSUFBb0NGLEtBQUtFLE1BQUwsQ0FBWUosTUFBWixHQUFtQixDQUExRCxFQUE0RDtBQUMxREUsZUFBS0UsTUFBTCxHQUFjYixjQUFjVyxLQUFLRSxNQUFuQixDQUFkO0FBQ0FGLGVBQUtFLE1BQUwsQ0FBWUMsUUFBWixHQUF1QkgsS0FBS0UsTUFBTCxDQUFZQyxRQUFaLElBQXdCLEVBQS9DO0FBQ0E7QUFDQTs7QUFFQUgsZUFBS0UsTUFBTCxDQUFZQyxRQUFaLENBQXFCQyxJQUFyQixDQUEwQkosSUFBMUI7QUFDRCxTQVBELE1BT087QUFDTE4sa0JBQVFVLElBQVIsQ0FBYUosSUFBYjtBQUNEO0FBQ0Y7QUFDRCxhQUFPTixPQUFQO0FBQ0Q7Ozt5Q0FFMkJSLFMsRUFBVUMsTyxFQUFRO0FBQzVDLFVBQUlrQixJQUFFLEVBQU47QUFDQSxVQUFJVixjQUFjUixRQUFRVSxJQUFSLEdBQWVDLE1BQWYsR0FBc0IsQ0FBeEM7QUFDQVosZ0JBQVVvQixPQUFWLENBQ0UsZ0JBQU07QUFDSixZQUFHWCxXQUFILEVBQWVWLGFBQWFnQixTQUFiLENBQXVCRCxJQUF2QixFQUE0QmIsT0FBNUI7QUFDZmtCLFVBQUVMLEtBQUtPLEVBQVAsSUFBV1AsSUFBWDtBQUNELE9BSkg7QUFLQSxhQUFPSyxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs4QkFZaUJMLEksRUFBOEI7QUFBQSxVQUF6QmIsT0FBeUIsdUVBQWpCLEVBQWlCO0FBQUEsVUFBZE0sU0FBYyx1RUFBSixHQUFJOztBQUM3QyxVQUFJZSxTQUFTO0FBQ1hDLHFCQUFhO0FBQUEsaUJBQU9DLElBQUlDLEtBQUosQ0FBVWxCLFNBQVYsQ0FBUDtBQUFBLFNBREY7QUFFWG1CLHFCQUFhO0FBQUEsaUJBQU9GLElBQUlDLEtBQUosQ0FBVWxCLFNBQVYsRUFBcUJvQixHQUFyQixDQUF5QjtBQUFBLG1CQUFHQyxXQUFXQyxDQUFYLENBQUg7QUFBQSxXQUF6QixDQUFQO0FBQUEsU0FGRjtBQUdYQyxnQkFBUTtBQUFBLGlCQUFPTixJQUFJTyxJQUFKLEVBQVA7QUFBQSxTQUhHO0FBSVhDLGdCQUFRO0FBQUEsaUJBQU9SLE9BQUssSUFBTCxJQUFhLENBQUNTLE1BQU1MLFdBQVdKLEdBQVgsQ0FBTixDQUFkLEdBQXNDSSxXQUFXSixHQUFYLENBQXRDLEdBQXVELElBQTlEO0FBQUEsU0FKRztBQUtYVSxpQkFBUztBQUFBLGlCQUFPVixJQUFJVyxXQUFKLE1BQW1CLE1BQW5CLElBQTZCWCxPQUFLLEdBQXpDO0FBQUE7QUFMRSxPQUFiO0FBT0EsV0FBSSxJQUFJWSxNQUFSLElBQWtCbkMsT0FBbEIsRUFBMEI7QUFDeEIsWUFBR2EsS0FBS3NCLE1BQUwsQ0FBSCxFQUFnQjtBQUFDO0FBQ2YsY0FBR3RCLEtBQUtzQixNQUFMLEVBQWF4QixNQUFiLEdBQW9CLENBQXZCLEVBQXlCO0FBQ3ZCRSxpQkFBS3NCLE1BQUwsSUFBZWQsT0FBT3JCLFFBQVFtQyxNQUFSLENBQVAsRUFBd0J0QixLQUFLc0IsTUFBTCxDQUF4QixDQUFmO0FBQ0QsV0FGRCxNQUVPO0FBQ0wsbUJBQU90QixLQUFLc0IsTUFBTCxDQUFQO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBR0Q7Ozs7Ozs7OzhDQUtpQ3BDLFMsRUFBMEI7QUFBQSxVQUFmZ0IsTUFBZSx1RUFBTixJQUFNOztBQUN6RGhCLGdCQUFVb0IsT0FBVixDQUFrQixtQkFBVztBQUMzQjtBQUNBO0FBQ0EsWUFBR2lCLFFBQVFyQixNQUFSLElBQWtCcUIsUUFBUXJCLE1BQVIsSUFBZ0IsSUFBbEMsSUFBMENxQixRQUFRckIsTUFBUixDQUFlc0IsT0FBNUQsRUFBb0U7QUFDbEVELGtCQUFRQyxPQUFSLEdBQWtCRCxRQUFRckIsTUFBUixDQUFlc0IsT0FBakM7QUFDRDtBQUNELFlBQUlELFFBQVFwQixRQUFaLEVBQXNCO0FBQ3BCbEIsdUJBQWFPLHlCQUFiLENBQXVDK0IsUUFBUXBCLFFBQS9DLEVBQXlEb0IsT0FBekQ7QUFDRDtBQUNELFlBQUdBLFFBQVFyQixNQUFSLElBQWtCcUIsUUFBUUUsS0FBMUIsSUFBbUMsQ0FBQ0YsUUFBUXJCLE1BQVIsQ0FBZXNCLE9BQXRELEVBQThEO0FBQzVELGNBQUcsQ0FBQ0QsUUFBUXJCLE1BQVIsQ0FBZXVCLEtBQW5CLEVBQ0VGLFFBQVFyQixNQUFSLENBQWV1QixLQUFmLEdBQXVCLEVBQXZCO0FBQ0ZGLGtCQUFRckIsTUFBUixDQUFldUIsS0FBZixHQUF1QkYsUUFBUXJCLE1BQVIsQ0FBZXVCLEtBQWYsQ0FBcUJDLE1BQXJCLENBQTRCSCxRQUFRRSxLQUFwQyxDQUF2QjtBQUNEO0FBQ0YsT0FkRDtBQWVEOzs7Ozs7a0JBR1l4QyxZIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDcmVhdGVkIGJ5IEl2YW5QIG9uIDI2LjEyLjIwMTYuXG4gKi9cbmNsYXNzIE1hcEhpZXJhcmNoeSB7XG4gIGNvbnN0cnVjdG9yKGhpZXJhcmNoeSxub3JtYWxzLG5vcm1hbHNTZXBhcmF0b3Ipe1xuICAgIC8vdGhpcy5hSGllcmFyY2h5ID0gaGllcmFyY2h5O1xuICAgIHRoaXMuZmxhdEhpZXJhcmNoeSA9IGhpZXJhcmNoeTtcbiAgICB0aGlzLmhpZXJhcmNoeSA9IHRoaXMuY29uc3RydWN0b3IucHJvY2Vzc0hpZXJhcmNoeSh0aGlzLmZsYXRIaWVyYXJjaHksbm9ybWFscyxub3JtYWxzU2VwYXJhdG9yKTtcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmFkZE1hcElEc1RvSGllcmFyY2h5TGV2ZWwodGhpcy5oaWVyYXJjaHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBoaWVyYXJjaHkgYXJyYXkgYnkgYXNzaWduaW5nIHBhcmVudC1jaGlsZCByZWxhdGlvbnMgYW5kIHJldHVybmluZyB0aG9zZSB0aGF0IGRvbid0IGhhdmUgYSBwYXJlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGZsYXRIaWVyYXJjaHkgLSBhIGZsYXQgaGllcmFyY2h5IG9iamVjdCB3aXRoIGlkcyBhcyBrZXlzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbbm9ybWFscz17fV0gLSBhbiBvYmplY3Qgd2hlcmUga2V5cyBteXN0IGNvaW5jaWRlIHdpdGggY29sdW1uIGlkcyAodGh1cyBiZSBpZGVudGljYWwgdG8ga2V5cyBpbiBgaXRlbWApLiBgbm9ybWFsc2AgZG9lc24ndCByZXF1aXJlIGZvciBhbGwga2V5cyBmcm9tIGBpdGVtYCB0byBiZSBwcmVzZW50LCBvbmx5IHRob3NlIHRoYXQgbmVlZCB0byBiZSBub3JtYWxpc2VkIHRvIGEgZGlmZmVyZW50IHR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzZXBhcmF0b3I9JywnXSAtIGEgc2VwYXJhdG9yIGFycmF5IGl0ZW1zIGFyZSBzZXJpYWxpemVkIHdpdGgsIGJ5IGRlZmF1bHQgaXQncyBhIGNvbW1hIChgLGApXG4gICAqICovXG4gIHN0YXRpYyBwcm9jZXNzSGllcmFyY2h5KGZsYXRIaWVyYXJjaHksbm9ybWFscz17fSxzZXBhcmF0b3I9JywnKXtcbiAgICBsZXQgb3JwaGFucyA9IFtdLFxuICAgICAgICB0b05vcm1hbGl6ZSA9IE9iamVjdC5rZXlzKG5vcm1hbHMpLmxlbmd0aD4wO1xuICAgIGZvcihsZXQga2V5IGluIGZsYXRIaWVyYXJjaHkpe1xuICAgICAgbGV0IGl0ZW0gPSBmbGF0SGllcmFyY2h5W2tleV07XG4gICAgICBpZih0b05vcm1hbGl6ZSlNYXBIaWVyYXJjaHkubm9ybWFsaXplKGl0ZW0sbm9ybWFscyk7XG5cbiAgICAgIC8vIG1hcCBpdGVtIHRvIHBhcmVudFxuICAgICAgaWYoaXRlbS5wYXJlbnQgJiYgaXRlbS5wYXJlbnQhPW51bGwgJiYgaXRlbS5wYXJlbnQubGVuZ3RoPjApe1xuICAgICAgICBpdGVtLnBhcmVudCA9IGZsYXRIaWVyYXJjaHlbaXRlbS5wYXJlbnRdO1xuICAgICAgICBpdGVtLnBhcmVudC5zdWJjZWxscyA9IGl0ZW0ucGFyZW50LnN1YmNlbGxzIHx8IFtdO1xuICAgICAgICAvL1RPRE86IGRlbGV0ZSB0aGlzIHdoZW4gdmFsdWUgaXMgaW4gcGxhY2VcbiAgICAgICAgLy9pdGVtLnZhbHVlID0gTWF0aC5yYW5kb20oKSoxMDA7XG5cbiAgICAgICAgaXRlbS5wYXJlbnQuc3ViY2VsbHMucHVzaChpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ycGhhbnMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9ycGhhbnNcbiAgfVxuXG4gIHN0YXRpYyBjb21wb3NlRmxhdEhpZXJhcmNoeShoaWVyYXJjaHksbm9ybWFscyl7XG4gICAgbGV0IG89e307XG4gICAgbGV0IHRvTm9ybWFsaXplID0gbm9ybWFscy5rZXlzKCkubGVuZ3RoPjA7XG4gICAgaGllcmFyY2h5LmZvckVhY2goXG4gICAgICBpdGVtPT57XG4gICAgICAgIGlmKHRvTm9ybWFsaXplKU1hcEhpZXJhcmNoeS5ub3JtYWxpemUoaXRlbSxub3JtYWxzKTtcbiAgICAgICAgb1tpdGVtLmlkXT1pdGVtO1xuICAgICAgfSk7XG4gICAgcmV0dXJuIG87XG4gIH1cblxuICAvKipcbiAgICogbm9ybWFsaXplcyBhIHN0cmluZyB2YWx1ZSB0byBhIGNlcnRhaW4gZm9ybWF0LlxuICAgKiAtIGBhcnJheVN0cmluZ2AgLSBub3JtYWxpemVzIGNvbW1hLXNlcGFyYXRlZCBpdGVtcyB0byBhbiBBcnJheSBvZiBTdHJpbmdzLCBpLmUgXCJoYWhhXCIsIFwibGFsYVwiIHdvdWxkIGJlIFtcImhhaGFcIiwgXCJsYWxhXCJdXG4gICAqIC0gYGFycmF5TnVtYmVyYCAtIG5vcm1hbGl6ZXMgY29tbWEtc2VwYXJhdGVkIGl0ZW1zIHRvIGFuIEFycmF5IG9mIEZsb2F0cywgaS5lIFwiLTEzLjQxXCIsIFwiNDguNjZcIiB3b3VsZCBiZSBbLTEzLjQxLCA0OC42Nl1cbiAgICogLSBgc3RyaW5nYCAtIHJldHVybnMgdGhlIHN0cmluZyBhcyBpc1xuICAgKiAtIGBudW1iZXJgIC0gcGFyc2VzIHRoZSBzdHJpbmcgYXMgYSBGbG9hdFxuICAgKiAtIGBib29sZWFuYCAtIHBhcnNlcyB0aGUgc3RyaW5nIGFzIGEgQm9vbGVhbiwgY2FzZSBpbnNlbnNpdGl2ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSAtIGl0ZW0gdG8gbWF0Y2ggY29udGVudHMgYWdhaW5zdCBgbm9ybWFsc2BcbiAgICogQHBhcmFtIHtPYmplY3R9IFtub3JtYWxzPXt9XSAtIGFuIG9iamVjdCB3aGVyZSBrZXlzIG15c3QgY29pbmNpZGUgd2l0aCBjb2x1bW4gaWRzICh0aHVzIGJlIGlkZW50aWNhbCB0byBrZXlzIGluIGBpdGVtYCkuIGBub3JtYWxzYCBkb2Vzbid0IHJlcXVpcmUgZm9yIGFsbCBrZXlzIGZyb20gYGl0ZW1gIHRvIGJlIHByZXNlbnQsIG9ubHkgdGhvc2UgdGhhdCBuZWVkIHRvIGJlIG5vcm1hbGlzZWQgdG8gYSBkaWZmZXJlbnQgdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlcGFyYXRvcj0nLCddIC0gYSBzZXBhcmF0b3IgYXJyYXkgaXRlbXMgYXJlIHNlcmlhbGl6ZWQgd2l0aCwgYnkgZGVmYXVsdCBpdCdzIGEgY29tbWEgKGAsYClcbiAgICogKi9cbiAgc3RhdGljIG5vcm1hbGl6ZShpdGVtLG5vcm1hbHM9e30sc2VwYXJhdG9yPScsJyl7XG4gICAgbGV0IHBhcnNlciA9IHtcbiAgICAgIHN0cmluZ0FycmF5OiB2YWwgPT4gdmFsLnNwbGl0KHNlcGFyYXRvciksXG4gICAgICBudW1iZXJBcnJheTogdmFsID0+IHZhbC5zcGxpdChzZXBhcmF0b3IpLm1hcChpPT5wYXJzZUZsb2F0KGkpKSxcbiAgICAgIHN0cmluZzogdmFsID0+IHZhbC50cmltKCksXG4gICAgICBudW1iZXI6IHZhbCA9PiB2YWwhPW51bGwgJiYgIWlzTmFOKHBhcnNlRmxvYXQodmFsKSk/IHBhcnNlRmxvYXQodmFsKTogbnVsbCxcbiAgICAgIGJvb2xlYW46IHZhbCA9PiB2YWwudG9Mb3dlckNhc2UoKT09XCJ0cnVlXCIgfHwgdmFsPT1cIjFcIlxuICAgIH07XG4gICAgZm9yKGxldCBub3JtYWwgaW4gbm9ybWFscyl7XG4gICAgICBpZihpdGVtW25vcm1hbF0pey8vIHByb3BlcnR5IGV4aXN0cyBpbiBvYmplY3RcbiAgICAgICAgaWYoaXRlbVtub3JtYWxdLmxlbmd0aD4wKXtcbiAgICAgICAgICBpdGVtW25vcm1hbF0gPSBwYXJzZXJbbm9ybWFsc1tub3JtYWxdXShpdGVtW25vcm1hbF0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGl0ZW1bbm9ybWFsXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogVXBkYXRlcyBpbml0aWFsIGhpZXJhcmNoeVxuICAgKiBAcGFyYW0gaGllcmFyY2h5XG4gICAqIEBwYXJhbSBwYXJlbnQgLSBoaWVyYXJjaHkgbGV2ZWwgcGFyZW50XG4gICAqL1xuICBzdGF0aWMgYWRkTWFwSURzVG9IaWVyYXJjaHlMZXZlbChoaWVyYXJjaHksIHBhcmVudCA9IG51bGwpIHtcbiAgICBoaWVyYXJjaHkuZm9yRWFjaChzdWJjZWxsID0+IHtcbiAgICAgIC8vc3ViY2VsbC5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAvL3N1YmNlbGwudmFsdWUgPSBNYXRoLnJhbmRvbSgpKjEwMDtcbiAgICAgIGlmKHN1YmNlbGwucGFyZW50ICYmIHN1YmNlbGwucGFyZW50IT1udWxsICYmIHN1YmNlbGwucGFyZW50Lm1hcE5hbWUpe1xuICAgICAgICBzdWJjZWxsLm1hcE5hbWUgPSBzdWJjZWxsLnBhcmVudC5tYXBOYW1lO1xuICAgICAgfVxuICAgICAgaWYgKHN1YmNlbGwuc3ViY2VsbHMpIHtcbiAgICAgICAgTWFwSGllcmFyY2h5LmFkZE1hcElEc1RvSGllcmFyY2h5TGV2ZWwoc3ViY2VsbC5zdWJjZWxscywgc3ViY2VsbCk7XG4gICAgICB9XG4gICAgICBpZihzdWJjZWxsLnBhcmVudCAmJiBzdWJjZWxsLm1hcElEICYmICFzdWJjZWxsLnBhcmVudC5tYXBOYW1lKXtcbiAgICAgICAgaWYoIXN1YmNlbGwucGFyZW50Lm1hcElEKVxuICAgICAgICAgIHN1YmNlbGwucGFyZW50Lm1hcElEID0gW107XG4gICAgICAgIHN1YmNlbGwucGFyZW50Lm1hcElEID0gc3ViY2VsbC5wYXJlbnQubWFwSUQuY29uY2F0KHN1YmNlbGwubWFwSUQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn1cbmV4cG9ydCBkZWZhdWx0IE1hcEhpZXJhcmNoeVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21hcC1oaWVyYXJjaHkuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 15 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItYWdncmVnYXRlZC10YWJsZS9zcmMvYWdncmVnYXRlZC10YWJsZS5jc3M/Y2QxNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ItYWdncmVnYXRlZC10YWJsZS9zcmMvYWdncmVnYXRlZC10YWJsZS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 16 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Itc29ydC10YWJsZS9zcmMvc29ydC10YWJsZS1zdHlsZXMuY3NzP2JmYzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yLXNvcnQtdGFibGUvc3JjL3NvcnQtdGFibGUtc3R5bGVzLmNzc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 17 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItdGFibGUtZmxvYXRpbmctaGVhZGVyL3NyYy90YWJsZS1mbG9hdGluZy1oZWFkZXItc3R5bGVzLmNzcz8zNWE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vci10YWJsZS1mbG9hdGluZy1oZWFkZXIvc3JjL3RhYmxlLWZsb2F0aW5nLWhlYWRlci1zdHlsZXMuY3NzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 18 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZHJpbGxkb3duLW1hcC5jc3M/ZjM4YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZHJpbGxkb3duLW1hcC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }
/******/ ]);