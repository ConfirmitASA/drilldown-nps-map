/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _DrilldownMap = __webpack_require__(2);\n\nvar _DrilldownMap2 = _interopRequireDefault(_DrilldownMap);\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nwindow.Reportal = window.Reportal || {};\n_rReportalBase2.default.mixin(window.Reportal, {\n  DrilldownMap: _DrilldownMap2.default\n});\n\nexports.default = Reportal;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz8zNDc5Il0sIm5hbWVzIjpbIndpbmRvdyIsIlJlcG9ydGFsIiwibWl4aW4iLCJEcmlsbGRvd25NYXAiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBQSxPQUFPQyxRQUFQLEdBQWtCRCxPQUFPQyxRQUFQLElBQW1CLEVBQXJDO0FBQ0Esd0JBQWFDLEtBQWIsQ0FBbUJGLE9BQU9DLFFBQTFCLEVBQW1DO0FBQ2pDRTtBQURpQyxDQUFuQzs7a0JBSWVGLFEiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IERyaWxsZG93bk1hcCBmcm9tIFwiLi9EcmlsbGRvd25NYXBcIjtcbmltcG9ydCBSZXBvcnRhbEJhc2UgZnJvbSBcInItcmVwb3J0YWwtYmFzZVwiO1xuXG53aW5kb3cuUmVwb3J0YWwgPSB3aW5kb3cuUmVwb3J0YWwgfHwge31cblJlcG9ydGFsQmFzZS5taXhpbih3aW5kb3cuUmVwb3J0YWwse1xuICBEcmlsbGRvd25NYXBcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBSZXBvcnRhbFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21haW4uanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ReportalBase = function () {\n  function ReportalBase() {\n    _classCallCheck(this, ReportalBase);\n  }\n\n  _createClass(ReportalBase, null, [{\n    key: 'mixin',\n\n\n    /**\r\n     * Copies props from a source object to a target object.\r\n     *\r\n     * Note, this method uses a simple `for...in` strategy for enumerating\r\n     * properties.  To ensure only `ownProperties` are copied from source\r\n     * to target and that accessor implementations are copied, use `extend`.\r\n     *\r\n     * @method mixin\r\n     * @param {Object} target Target object to copy properties to.\r\n     * @param {Object} source Source object to copy properties from.\r\n     * @return {Object} Target object that was passed as first argument.\r\n     */\n    value: function mixin(target, source) {\n      for (var i in source) {\n        target[i] = source[i];\n      }\n      return target;\n    }\n  }, {\n    key: '_logger',\n    value: function _logger(level, args) {\n      // accept ['foo', 'bar'] and [['foo', 'bar']]\n      if (args.length === 1 && Array.isArray(args[0])) {\n        args = args[0];\n      }\n      // only accept logging functions\n      switch (level) {\n        case 'log':\n        case 'warn':\n        case 'error':\n          console[level].apply(console, args);\n          break;\n      }\n    }\n  }, {\n    key: '_log',\n    value: function _log() {\n      var args = Array.prototype.slice.call(arguments, 0);\n      this._logger('log', args);\n    }\n  }, {\n    key: '_warn',\n    value: function _warn() {\n      var args = Array.prototype.slice.call(arguments, 0);\n      this._logger('warn', args);\n    }\n  }, {\n    key: '_error',\n    value: function _error() {\n      var args = Array.prototype.slice.call(arguments, 0);\n      this._logger('error', args);\n    }\n\n    /**\r\n     * Creates a named event with `name`\r\n     * @param {String} name - name of the event\r\n     * @return {Event} Returns a created event\r\n     * */\n\n  }, {\n    key: 'newEvent',\n    value: function newEvent(name) {\n      var event = document.createEvent('Event');\n      event.initEvent(name, true, true);\n      return event;\n    }\n\n    /**\r\n     * Inspects if the current string might be converted to number and renders it as number. If string length is 0, returns `null`. If none applies returns the string as is.\r\n     * @param {String} str - value of the cell if not HTML contents\r\n     * @return {Number|null|String}\r\n     * */\n\n  }, {\n    key: 'isNumber',\n    value: function isNumber(str) {\n      if (!isNaN(parseFloat(str))) {\n        str = str.replace(/,/i, ''); // remove unnecessary comma as a delimiter for thousands from data.\n        return parseFloat(str);\n      } else if (str.length == 0) {\n        return null;\n      } else {\n        return str;\n      }\n    }\n\n    /**\r\n     * Creates an XHR wrapped in a Promise\r\n     * @param {!String} URL - url to send a `GET` request to\r\n     * @return {Promise} Returns a then-able promise with `XMLHttpRequest.responseText`\r\n     * */\n\n  }, {\n    key: 'promiseRequest',\n    value: function promiseRequest(URL) {\n      return new Promise(function (resolve, reject) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', URL, true);\n        xhr.onload = function () {\n          xhr.status == 200 ? resolve(xhr.responseText) : reject(Error(xhr.status + ': ' + xhr.statusText));\n        };\n        xhr.onerror = function () {\n          reject(Error(\"Network Error\"));\n        };\n        xhr.send();\n      });\n    }\n\n    /**\r\n     * Gets a variable listed in query string\r\n     * @param {!String} variable - variable name to get value for\r\n     * @param {String=} [query=window.location.search.substring(1)] - the query string to search variable for in\r\n     * @return {String} Returns value for the variable\r\n     * */\n\n  }, {\n    key: 'getQueryVariable',\n    value: function getQueryVariable(variable) {\n      var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.location.search.substring(1);\n\n      var vars = query.split(\"&\");\n      for (var i = 0; i < vars.length; i++) {\n        var pair = vars[i].split(\"=\");\n        if (pair[0].toLowerCase() == variable.toLowerCase()) {\n          return pair[1];\n        }\n      }\n      return null;\n    }\n  }]);\n\n  return ReportalBase;\n}();\n\nexports.default = ReportalBase;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ItcmVwb3J0YWwtYmFzZS9zcmMvcmVwb3J0YWwtYmFzZS5qcz9kYTM1Il0sIm5hbWVzIjpbIlJlcG9ydGFsQmFzZSIsInRhcmdldCIsInNvdXJjZSIsImkiLCJsZXZlbCIsImFyZ3MiLCJsZW5ndGgiLCJBcnJheSIsImlzQXJyYXkiLCJjb25zb2xlIiwiYXBwbHkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJhcmd1bWVudHMiLCJfbG9nZ2VyIiwibmFtZSIsImV2ZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsInN0ciIsImlzTmFOIiwicGFyc2VGbG9hdCIsInJlcGxhY2UiLCJVUkwiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsIm9ubG9hZCIsInN0YXR1cyIsInJlc3BvbnNlVGV4dCIsIkVycm9yIiwic3RhdHVzVGV4dCIsIm9uZXJyb3IiLCJzZW5kIiwidmFyaWFibGUiLCJxdWVyeSIsIndpbmRvdyIsImxvY2F0aW9uIiwic2VhcmNoIiwic3Vic3RyaW5nIiwidmFycyIsInNwbGl0IiwicGFpciIsInRvTG93ZXJDYXNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0lBQU1BLFk7Ozs7Ozs7OztBQUVKOzs7Ozs7Ozs7Ozs7MEJBWWFDLE0sRUFBUUMsTSxFQUFRO0FBQzNCLFdBQUssSUFBSUMsQ0FBVCxJQUFjRCxNQUFkLEVBQXNCO0FBQ3BCRCxlQUFPRSxDQUFQLElBQVlELE9BQU9DLENBQVAsQ0FBWjtBQUNEO0FBQ0QsYUFBT0YsTUFBUDtBQUNEOzs7NEJBRWNHLEssRUFBT0MsSSxFQUFNO0FBQzFCO0FBQ0EsVUFBSUEsS0FBS0MsTUFBTCxLQUFnQixDQUFoQixJQUFxQkMsTUFBTUMsT0FBTixDQUFjSCxLQUFLLENBQUwsQ0FBZCxDQUF6QixFQUFpRDtBQUMvQ0EsZUFBT0EsS0FBSyxDQUFMLENBQVA7QUFDRDtBQUNEO0FBQ0Es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Ozs7a0JBR1kvQyxZIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBSZXBvcnRhbEJhc2Uge1xyXG5cclxuICAvKipcclxuICAgKiBDb3BpZXMgcHJvcHMgZnJvbSBhIHNvdXJjZSBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogTm90ZSwgdGhpcyBtZXRob2QgdXNlcyBhIHNpbXBsZSBgZm9yLi4uaW5gIHN0cmF0ZWd5IGZvciBlbnVtZXJhdGluZ1xyXG4gICAqIHByb3BlcnRpZXMuICBUbyBlbnN1cmUgb25seSBgb3duUHJvcGVydGllc2AgYXJlIGNvcGllZCBmcm9tIHNvdXJjZVxyXG4gICAqIHRvIHRhcmdldCBhbmQgdGhhdCBhY2Nlc3NvciBpbXBsZW1lbnRhdGlvbnMgYXJlIGNvcGllZCwgdXNlIGBleHRlbmRgLlxyXG4gICAqXHJcbiAgICogQG1ldGhvZCBtaXhpblxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGFyZ2V0IG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBTb3VyY2Ugb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxyXG4gICAqIEByZXR1cm4ge09iamVjdH0gVGFyZ2V0IG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgYXMgZmlyc3QgYXJndW1lbnQuXHJcbiAgICovXHJcbiAgc3RhdGljIG1peGluKHRhcmdldCwgc291cmNlKSB7XHJcbiAgICBmb3IgKHZhciBpIGluIHNvdXJjZSkge1xyXG4gICAgICB0YXJnZXRbaV0gPSBzb3VyY2VbaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIF9sb2dnZXIobGV2ZWwsIGFyZ3MpIHtcclxuICAgIC8vIGFjY2VwdCBbJ2ZvbycsICdiYXInXSBhbmQgW1snZm9vJywgJ2JhciddXVxyXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcclxuICAgICAgYXJncyA9IGFyZ3NbMF07XHJcbiAgICB9XHJcbiAgICAvLyBvbmx5IGFjY2VwdCBsb2dnaW5nIGZ1bmN0aW9uc1xyXG4gICAgc3dpdGNoKGxldmVsKSB7XHJcbiAgICAgIGNhc2UgJ2xvZyc6XHJcbiAgICAgIGNhc2UgJ3dhcm4nOlxyXG4gICAgICBjYXNlICdlcnJvcic6XHJcbiAgICAgICAgY29uc29sZVtsZXZlbF0uYXBwbHkoY29uc29sZSwgYXJncyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgX2xvZygpIHtcclxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcclxuICAgIHRoaXMuX2xvZ2dlcignbG9nJywgYXJncyk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgX3dhcm4oKSB7XHJcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XHJcbiAgICB0aGlzLl9sb2dnZXIoJ3dhcm4nLCBhcmdzKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBfZXJyb3IoKSB7XHJcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XHJcbiAgICB0aGlzLl9sb2dnZXIoJ2Vycm9yJywgYXJncyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmFtZWQgZXZlbnQgd2l0aCBgbmFtZWBcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICogQHJldHVybiB7RXZlbnR9IFJldHVybnMgYSBjcmVhdGVkIGV2ZW50XHJcbiAgICogKi9cclxuICBzdGF0aWMgbmV3RXZlbnQobmFtZSl7XHJcbiAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxuICAgIGV2ZW50LmluaXRFdmVudChuYW1lLCB0cnVlLCB0cnVlKTtcclxuICAgIHJldHVybiBldmVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluc3BlY3RzIGlmIHRoZSBjdXJyZW50IHN0cmluZyBtaWdodCBiZSBjb252ZXJ0ZWQgdG8gbnVtYmVyIGFuZCByZW5kZXJzIGl0IGFzIG51bWJlci4gSWYgc3RyaW5nIGxlbmd0aCBpcyAwLCByZXR1cm5zIGBudWxsYC4gSWYgbm9uZSBhcHBsaWVzIHJldHVybnMgdGhlIHN0cmluZyBhcyBpcy5cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gdmFsdWUgb2YgdGhlIGNlbGwgaWYgbm90IEhUTUwgY29udGVudHNcclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ8bnVsbHxTdHJpbmd9XHJcbiAgICogKi9cclxuICBzdGF0aWMgaXNOdW1iZXIoc3RyKXtcclxuICAgIGlmKCFpc05hTihwYXJzZUZsb2F0KHN0cikpKXtcclxuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLywvaSwnJyk7Ly8gcmVtb3ZlIHVubmVjZXNzYXJ5IGNvbW1hIGFzIGEgZGVsaW1pdGVyIGZvciB0aG91c2FuZHMgZnJvbSBkYXRhLlxyXG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIpO1xyXG4gICAgfSBlbHNlIGlmKHN0ci5sZW5ndGg9PTApe3JldHVybiBudWxsfSBlbHNlIHtyZXR1cm4gc3RyfVxyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gWEhSIHdyYXBwZWQgaW4gYSBQcm9taXNlXHJcbiAgICogQHBhcmFtIHshU3RyaW5nfSBVUkwgLSB1cmwgdG8gc2VuZCBhIGBHRVRgIHJlcXVlc3QgdG9cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXR1cm5zIGEgdGhlbi1hYmxlIHByb21pc2Ugd2l0aCBgWE1MSHR0cFJlcXVlc3QucmVzcG9uc2VUZXh0YFxyXG4gICAqICovXHJcbiAgc3RhdGljIHByb21pc2VSZXF1ZXN0KFVSTCl7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KT0+e1xyXG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgIHhoci5vcGVuKCdHRVQnLCBVUkwsIHRydWUpO1xyXG4gICAgICB4aHIub25sb2FkID0gKCk9Pnt4aHIuc3RhdHVzID09IDIwMD9yZXNvbHZlKHhoci5yZXNwb25zZVRleHQpOnJlamVjdChFcnJvcihgJHt4aHIuc3RhdHVzfTogJHt4aHIuc3RhdHVzVGV4dH1gKSk7fVxyXG4gICAgICB4aHIub25lcnJvciA9ICgpPT57cmVqZWN0KEVycm9yKFwiTmV0d29yayBFcnJvclwiKSk7fVxyXG4gICAgICB4aHIuc2VuZCgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGEgdmFyaWFibGUgbGlzdGVkIGluIHF1ZXJ5IHN0cmluZ1xyXG4gICAqIEBwYXJhbSB7IVN0cmluZ30gdmFyaWFibGUgLSB2YXJpYWJsZSBuYW1lIHRvIGdldCB2YWx1ZSBmb3JcclxuICAgKiBAcGFyYW0ge1N0cmluZz19IFtxdWVyeT13aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKV0gLSB0aGUgcXVlcnkgc3RyaW5nIHRvIHNlYXJjaCB2YXJpYWJsZSBmb3IgaW5cclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFJldHVybnMgdmFsdWUgZm9yIHRoZSB2YXJpYWJsZVxyXG4gICAqICovXHJcbiAgc3RhdGljIGdldFF1ZXJ5VmFyaWFibGUodmFyaWFibGUscXVlcnk9d2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpe1xyXG4gICAgdmFyIHZhcnMgPSBxdWVyeS5zcGxpdChcIiZcIik7XHJcbiAgICBmb3IgKHZhciBpPTA7aTx2YXJzLmxlbmd0aDtpKyspIHtcclxuICAgICAgdmFyIHBhaXIgPSB2YXJzW2ldLnNwbGl0KFwiPVwiKTtcclxuICAgICAgaWYoKHBhaXJbMF0pLnRvTG93ZXJDYXNlKCkgPT0gdmFyaWFibGUudG9Mb3dlckNhc2UoKSl7cmV0dXJuIHBhaXJbMV07fVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxufVxyXG5leHBvcnQgZGVmYXVsdCBSZXBvcnRhbEJhc2VcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yLXJlcG9ydGFsLWJhc2Uvc3JjL3JlcG9ydGFsLWJhc2UuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _rReportalBase = __webpack_require__(1);\n\nvar _rReportalBase2 = _interopRequireDefault(_rReportalBase);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DrilldownMap = function () {\n  function DrilldownMap() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        hierarchy = _ref.hierarchy,\n        containerID = _ref.containerID,\n        mappointCallback = _ref.mappointCallback,\n        _ref$dataClasses = _ref.dataClasses,\n        dataClasses = _ref$dataClasses === undefined ? [{\n      from: 80,\n      to: 100,\n      color: '#8bc34a',\n      name: 'Promoter'\n    }, {\n      from: 60,\n      to: 80,\n      color: '#ffc107',\n      name: 'Passive'\n    }, {\n      from: 0,\n      to: 60,\n      color: '#f44336',\n      name: 'Detractor'\n    }] : _ref$dataClasses,\n        _ref$options = _ref.options,\n        options = _ref$options === undefined ? {} : _ref$options;\n\n    _classCallCheck(this, DrilldownMap);\n\n    if (mappointCallback) {\n      if (typeof mappointCallback == 'function') {\n        this.mappointCallback = mappointCallback;\n      } else {\n        throw new TypeError(\"mappointCallback must be a function\");\n      }\n    }\n\n    var config = _rReportalBase2.default.mixin(options, { colorAxis: { dataClasses: dataClasses } });\n    if ((typeof Highcharts === 'undefined' ? 'undefined' : _typeof(Highcharts)) == undefined) {\n      throw new Error('Highcharts must be declared. Probably they are missing');\n    };\n    if (_typeof(Highcharts.maps) == undefined) {\n      throw new Error('HighMaps must be loaded. Probably they are missing');\n    };\n\n    this.constructor.addMapIDsToHierarchyLevel(hierarchy);\n    this.drawMap(hierarchy, containerID, config);\n  }\n\n  _createClass(DrilldownMap, [{\n    key: 'initMap',\n\n\n    /**\n     * @param {Object} curLVL - current level in hierarchy\n     * @param {Array} [series=[]] - series\n     * */\n    value: function initMap(curLVL) {\n      var _this = this;\n\n      var series = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      curLVL.subcells.forEach(function (subcell) {\n        if (subcell.mapID) {\n          var seriesItem = _this.composeSeries(subcell);\n          series.push(seriesItem);\n        }\n      });\n      return series;\n    }\n  }, {\n    key: 'getCoordinateSeries',\n\n\n    /**\n     * Returns series for map points\n     * */\n    value: function getCoordinateSeries(subcell, mapData, chart) {\n      chart.mapTransforms = mapData ? mapData[\"hc-transform\"] : Highcharts.maps[\"custom/world-highres2\"][\"hc-transform\"];\n      var pos = chart.fromLatLonToPoint({ lat: subcell.coordinates[0], lon: subcell.coordinates[1] });\n      var config = {\n        type: \"mappoint\", // or mapbubble\n        name: subcell.text,\n        marker: {\n          lineColor: \"black\",\n          lineWidth: 1,\n          radius: 4,\n          symbol: \"circle\"\n        },\n        data: [{\n          color: DrilldownMap.getColor(subcell.value),\n          name: subcell.text,\n          value: subcell.value,\n          x: pos.x,\n          y: pos.y\n        }]\n      };\n      if (this.mappointCallback) {\n        config.events = {\n          click: this.mappointCallback\n        };\n      }\n      return config;\n    }\n  }, {\n    key: 'composeSeries',\n    value: function composeSeries(subcell, mapData, chart) {\n      if (!subcell.coordinates) {\n        mapData = mapData ? Highcharts.geojson(DrilldownMap.createCustomGeoJSON(mapData, subcell.mapID, subcell.text)) : Highcharts.geojson(DrilldownMap.createCustomGeoJSON(Highcharts.maps['custom/world-highres2'], subcell.mapID, subcell.text));\n        if (subcell.mapID) {\n          return {\n            name: subcell.text,\n            tooltip: {\n              pointFormat: 'NPS : {point.value}'\n            },\n            allAreas: false,\n            parent: subcell.parent.text,\n            mapData: mapData,\n            joinBy: ['hc-key', 'code'],\n            data: DrilldownMap.getSeriesData(subcell)\n          };\n        }\n      } else {\n        return this.getCoordinateSeries(subcell, mapData, chart);\n      }\n    }\n  }, {\n    key: 'updateMap',\n    value: function updateMap(curLVL, chart, e) {\n      var _this2 = this;\n\n      curLVL = curLVL.subcells.filter(function (el) {\n        return el.text == e.point.series.name;\n      })[0];\n      if (curLVL && curLVL.map) {\n        // if we have another map to load\n        var map = DrilldownMap.loadMap(curLVL.map);\n        map.then(function (mapData) {\n          _this2.addSeries(curLVL, chart, e, mapData);\n        });\n      } else if (curLVL && !curLVL.map) {\n        this.addSeries(curLVL, chart, e);\n      }\n      return curLVL;\n    }\n  }, {\n    key: 'addSeries',\n    value: function addSeries(curLVL, chart, e, mapData) {\n      var _this3 = this;\n\n      if (curLVL.subcells && curLVL.isGlobal) {\n        if (!curLVL.subcells[0].isGlobal) {\n          var a = this.composeSeries(curLVL, mapData, chart);\n          a.data.map(function (el) {\n            el.drilldown = null, el.value = null;\n          });\n          chart.addSingleSeriesAsDrilldown(e.point, a);\n        }\n        curLVL.subcells.forEach(function (el) {\n          if (!el.mapID && !el.coordinates) return;\n          var a = _this3.composeSeries(el, mapData, chart);\n          chart.addSingleSeriesAsDrilldown(e.point, a);\n        });\n        chart.applyDrilldown();\n      } else {\n        var _a = this.composeSeries(curLVL, mapData, chart);\n        _a.data.map(function (el) {\n          el.drilldown = null, el.value = null;\n        });\n        chart.addSeriesAsDrilldown(e.point, _a);\n      }\n    }\n  }, {\n    key: 'drawMap',\n    value: function drawMap(hierarchy, containerID, options) {\n      var curLVL = hierarchy[0];\n      var self = this;\n      var config = {\n        lang: {\n          drillUpText: 'Back to {series.parent}'\n        },\n        tooltip: {\n          pointFormat: 'NPS : {point.value}'\n        },\n        title: {\n          text: 'Drilldown map'\n        },\n        legend: {\n          enabled: false\n        },\n        mapNavigation: {\n          enabled: true\n        },\n        subtitle: {\n          align: 'right',\n          text: 'Current level: ' + curLVL.text\n        },\n        chart: {\n          events: {\n            drilldown: this.drilldown.call(this, curLVL),\n            drillupall: function drillupall(e) {\n              curLVL = curLVL.parent;\n              this.subtitle.update({ text: 'Current level: ' + curLVL.text });\n            }\n          }\n        },\n        series: this.initMap(curLVL, [{\n          mapData: Highcharts.maps[\"custom/world-highres2\"]\n        }])\n      };\n      config = _rReportalBase2.default.mixin(config, options);\n      Highcharts.mapChart(containerID, config);\n    }\n  }, {\n    key: 'drilldown',\n    value: function drilldown(e, curLVL) {\n      console.log(e);\n      var chart = e.target;\n      curLVL = this.updateMap(curLVL, chart, e);\n      chart.subtitle.update({ text: 'Current region: ' + curLVL.text + '<br> Region NPS: ' + curLVL.value });\n    }\n  }], [{\n    key: 'createCustomGeoJSON',\n    value: function createCustomGeoJSON(mapData, countriesList, mapName) {\n\n      var geojson = {\n        title: \"\",\n        version: \"0.1.0\",\n        type: \"FeatureCollection\",\n        copyright: \"Copyright (c) 2015 Highsoft AS, Based on data from Natural Earth\",\n        copyrightShort: \"Natural Earth\",\n        copyrightUrl: \"http://www.naturalearthdata.com\",\n        crs: {\n          type: \"name\",\n          properties: {\n            name: \"urn:ogc:def:crs:EPSG:54003\"\n          }\n        },\n        \"hc-transform\": {\n          default: {\n            crs: \"+proj=mill +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +R_A +datum=WGS84 +units=m +no_defs\",\n            scale: 1.72182781654e-05,\n            jsonres: 15.5,\n            jsonmarginX: -999,\n            jsonmarginY: 9851.0,\n            xoffset: -19495356.3693,\n            yoffset: 12635908.1982\n          }\n        },\n        features: DrilldownMap.getFeatures(countriesList, mapData) //[[]]\n      };\n\n      geojson.title = mapName;\n      return geojson;\n    }\n  }, {\n    key: 'getFeatures',\n    value: function getFeatures(countriesList, mapData) {\n      var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"hc-key\";\n\n      if (typeof countriesList === 'string') {\n        return mapData.features.filter(function (feature) {\n          return feature.properties[key] === countriesList;\n        });\n      } else if (Array.isArray(countriesList)) {\n        return mapData.features.filter(function (feature) {\n          return countriesList.indexOf(feature.properties[key]) != -1;\n        });\n      }\n    }\n  }, {\n    key: 'addMapIDsToHierarchyLevel',\n    value: function addMapIDsToHierarchyLevel(hierarchy) {\n      var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      hierarchy.forEach(function (subcell) {\n        subcell.parent = parent;\n        subcell.value = Math.random() * 100;\n        if (subcell.parent && subcell.parent != null && subcell.parent.map) {\n          subcell.map = subcell.parent.map;\n        }\n        if (subcell.subcells) {\n          DrilldownMap.addMapIDsToHierarchyLevel(subcell.subcells, subcell);\n        }\n        if (subcell.parent && subcell.mapID && !subcell.parent.map) {\n          if (!subcell.parent.mapID) subcell.parent.mapID = [];\n          subcell.parent.mapID = subcell.parent.mapID.concat(subcell.mapID);\n        }\n      });\n    }\n  }, {\n    key: 'loadMap',\n    value: function loadMap(source) {\n      return new Promise(function (resolve, reject) {\n        jQuery.getScript('https://code.highcharts.com/mapdata/' + source + '.js', function () {\n          resolve(Highcharts.maps[source]);\n        });\n      });\n    }\n\n    /**\n     * @param {Object} level - a level in hierarchy\n     * */\n\n  }, {\n    key: 'getSeriesData',\n    value: function getSeriesData(level) {\n      var drilldown = level.subcells ? level.text : null;\n      if (typeof level.mapID === 'string') {\n        return [{\n          'drilldown': drilldown,\n          'code': level.mapID,\n          'value': level.value\n        }];\n      } else if (Array.isArray(level.mapID)) {\n        return level.mapID.map(function (id) {\n          return {\n            'drilldown': drilldown,\n            'code': id,\n            'value': level.value\n          };\n        });\n      } else {\n        throw new Error(\"Data element is corrupted\");\n      }\n    }\n  }, {\n    key: 'getColor',\n    value: function getColor(val) {\n      if (val < 60) return '#f44336';else if (val < 80) return '#ffc107';else return '#8bc34a';\n    }\n  }]);\n\n  return DrilldownMap;\n}();\n\nexports.default = DrilldownMap;\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvRHJpbGxkb3duTWFwLmpzP2UwMjkiXSwibmFtZXMiOlsiRHJpbGxkb3duTWFwIiwiaGllcmFyY2h5IiwiY29udGFpbmVySUQiLCJtYXBwb2ludENhbGxiYWNrIiwiZGF0YUNsYXNzZXMiLCJmcm9tIiwidG8iLCJjb2xvciIsIm5hbWUiLCJvcHRpb25zIiwiVHlwZUVycm9yIiwiY29uZmlnIiwibWl4aW4iLCJjb2xvckF4aXMiLCJIaWdoY2hhcnRzIiwidW5kZWZpbmVkIiwiRXJyb3IiLCJtYXBzIiwiY29uc3RydWN0b3IiLCJhZGRNYXBJRHNUb0hpZXJhcmNoeUxldmVsIiwiZHJhd01hcCIsImN1ckxWTCIsInNlcmllcyIsInN1YmNlbGxzIiwiZm9yRWFjaCIsInN1YmNlbGwiLCJtYXBJRCIsInNlcmllc0l0ZW0iLCJjb21wb3NlU2VyaWVzIiwicHVzaCIsIm1hcERhdGEiLCJjaGFydCIsIm1hcFRyYW5zZm9ybXMiLCJwb3MiLCJmcm9tTGF0TG9uVG9Qb2ludCIsImxhdCIsImNvb3JkaW5hdGVzIiwibG9uIiwidHlwZSIsInRleHQiLCJtYXJrZXIiLCJsaW5lQ29sb3IiLCJsaW5lV2lkdGgiLCJyYWRpdXMiLCJzeW1ib2wiLCJkYXRhIiwiZ2V0Q29sb3IiLCJ2YWx1ZSIsIngiLCJ5IiwiZXZlbnRzIiwiY2xpY2siLCJnZW9qc29uIiwiY3JlYXRlQ3VzdG9tR2VvSlNPTiIsInRvb2x0aXAiLCJwb2ludEZvcm1hdCIsImFsbEFyZWFzIiwicGFyZW50Iiwiam9pbkJ5IiwiZ2V0U2VyaWVzRGF0YSIsImdldENvb3JkaW5hdGVTZXJpZXMiLCJlIiwiZmlsdGVyIiwiZWwiLCJwb2ludCIsIm1hcCIsImxvYWRNYXAiLCJ0aGVuIiwiYWRkU2VyaWVzIiwiaXNHbG9iYWwiLCJhIiwiZHJpbGxkb3duIiwiYWRkU2luZ2xlU2VyaWVzQXNEcmlsbGRvd24iLCJhcHBseURyaWxsZG93biIsImFkZFNlcmllc0FzRHJpbGxkb3duIiwic2VsZiIsImxhbmciLCJkcmlsbFVwVGV4dCIsInRpdGxlIiwibGVnZW5kIiwiZW5hYmxlZCIsIm1hcE5hdmlnYXRpb24iLCJzdWJ0aXRsZSIsImFsaWduIiwiY2FsbCIsImRyaWxsdXBhbGwiLCJ1cGRhdGUiLCJpbml0TWFwIiwibWFwQ2hhcnQiLCJjb25zb2xlIiwibG9nIiwidGFyZ2V0IiwidXBkYXRlTWFwIiwiY291bnRyaWVzTGlzdCIsIm1hcE5hbWUiLCJ2ZXJzaW9uIiwiY29weXJpZ2h0IiwiY29weXJpZ2h0U2hvcnQiLCJjb3B5cmlnaHRVcmwiLCJjcnMiLCJwcm9wZXJ0aWVzIiwiZGVmYXVsdCIsInNjYWxlIiwianNvbnJlcyIsImpzb25tYXJnaW5YIiwianNvbm1hcmdpblkiLCJ4b2Zmc2V0IiwieW9mZnNldCIsImZlYXR1cmVzIiwiZ2V0RmVhdHVyZXMiLCJrZXkiLCJmZWF0dXJlIiwiQXJyYXkiLCJpc0FycmF5IiwiaW5kZXhPZiIsIk1hdGgiLCJyYW5kb20iLCJjb25jYXQiLCJzb3VyY2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImpRdWVyeSIsImdldFNjcmlwdCIsImxldmVsIiwiaWQiLCJ2YWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7SUFDTUEsWTtBQUNKLDBCQWVtQjtBQUFBLG1GQUFILEVBQUc7QUFBQSxRQWZOQyxTQWVNLFFBZk5BLFNBZU07QUFBQSxRQWZLQyxXQWVMLFFBZktBLFdBZUw7QUFBQSxRQWZrQkMsZ0JBZWxCLFFBZmtCQSxnQkFlbEI7QUFBQSxnQ0Fmb0NDLFdBZXBDO0FBQUEsUUFmb0NBLFdBZXBDLG9DQWZrRCxDQUFDO0FBQ3BFQyxZQUFNLEVBRDhEO0FBRXBFQyxVQUFJLEdBRmdFO0FBR3BFQyxhQUFPLFNBSDZEO0FBSXBFQyxZQUFNO0FBSjhELEtBQUQsRUFLbkU7QUFDQUgsWUFBTSxFQUROO0FBRUFDLFVBQUksRUFGSjtBQUdBQyxhQUFPLFNBSFA7QUFJQUMsWUFBTTtBQUpOLEtBTG1FLEVBVW5FO0FBQ0FILFlBQU0sQ0FETjtB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LEVBQ0gsT0FBTyxTQUFQLENBREcsS0FHSCxPQUFPLFNBQVA7QUFDSDs7Ozs7O2tCQXNJWTlILFkiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZXBvcnRhbEJhc2UgZnJvbSBcInItcmVwb3J0YWwtYmFzZVwiO1xuY2xhc3MgRHJpbGxkb3duTWFwIHtcbiAgY29uc3RydWN0b3Ioe2hpZXJhcmNoeSwgY29udGFpbmVySUQsIG1hcHBvaW50Q2FsbGJhY2ssIGRhdGFDbGFzc2VzID0gW3tcbiAgICBmcm9tOiA4MCxcbiAgICB0bzogMTAwLFxuICAgIGNvbG9yOiAnIzhiYzM0YScsXG4gICAgbmFtZTogJ1Byb21vdGVyJ1xuICB9LHtcbiAgICBmcm9tOiA2MCxcbiAgICB0bzogODAsXG4gICAgY29sb3I6ICcjZmZjMTA3JyxcbiAgICBuYW1lOiAnUGFzc2l2ZSdcbiAgfSx7XG4gICAgZnJvbTogMCxcbiAgICB0bzogNjAsXG4gICAgY29sb3I6ICcjZjQ0MzM2JyxcbiAgICBuYW1lOiAnRGV0cmFjdG9yJ1xuICB9XSwgb3B0aW9ucz17fX09e30pe1xuXG4gICAgaWYobWFwcG9pbnRDYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBtYXBwb2ludENhbGxiYWNrID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5tYXBwb2ludENhbGxiYWNrID0gbWFwcG9pbnRDYWxsYmFja1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm1hcHBvaW50Q2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGNvbmZpZyA9IFJlcG9ydGFsQmFzZS5taXhpbihvcHRpb25zLCB7Y29sb3JBeGlzOntkYXRhQ2xhc3Nlc319KTtcbiAgICBpZih0eXBlb2YgSGlnaGNoYXJ0cyA9PSB1bmRlZmluZWQpe3Rocm93IG5ldyBFcnJvcignSGlnaGNoYXJ0cyBtdXN0IGJlIGRlY2xhcmVkLiBQcm9iYWJseSB0aGV5IGFyZSBtaXNzaW5nJyl9O1xuICAgIGlmKHR5cGVvZiBIaWdoY2hhcnRzLm1hcHMgPT0gdW5kZWZpbmVkKXt0aHJvdyBuZXcgRXJyb3IoJ0hpZ2hNYXBzIG11c3QgYmUgbG9hZGVkLiBQcm9iYWJseSB0aGV5IGFyZSBtaXNzaW5nJyl9O1xuXG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5hZGRNYXBJRHNUb0hpZXJhcmNoeUxldmVsKGhpZXJhcmNoeSk7XG4gICAgdGhpcy5kcmF3TWFwKGhpZXJhcmNoeSwgY29udGFpbmVySUQsIGNvbmZpZyk7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlQ3VzdG9tR2VvSlNPTihtYXBEYXRhLCBjb3VudHJpZXNMaXN0LCBtYXBOYW1lKSB7XG5cbiAgICBsZXQgZ2VvanNvbiA9IHtcbiAgICAgIHRpdGxlOlwiXCIsXG4gICAgICB2ZXJzaW9uOlwiMC4xLjBcIixcbiAgICAgIHR5cGU6XCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICAgICAgY29weXJpZ2h0OlwiQ29weXJpZ2h0IChjKSAyMDE1IEhpZ2hzb2Z0IEFTLCBCYXNlZCBvbiBkYXRhIGZyb20gTmF0dXJhbCBFYXJ0aFwiLFxuICAgICAgY29weXJpZ2h0U2hvcnQ6XCJOYXR1cmFsIEVhcnRoXCIsXG4gICAgICBjb3B5cmlnaHRVcmw6XCJodHRwOi8vd3d3Lm5hdHVyYWxlYXJ0aGRhdGEuY29tXCIsXG4gICAgICBjcnM6e1xuICAgICAgICB0eXBlOlwibmFtZVwiLFxuICAgICAgICBwcm9wZXJ0aWVzOntcbiAgICAgICAgICBuYW1lOlwidXJuOm9nYzpkZWY6Y3JzOkVQU0c6NTQwMDNcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJoYy10cmFuc2Zvcm1cIjp7XG4gICAgICAgIGRlZmF1bHQ6e1xuICAgICAgICAgIGNyczpcIitwcm9qPW1pbGwgK2xhdF8wPTAgK2xvbl8wPTAgK3hfMD0wICt5XzA9MCArUl9BICtkYXR1bT1XR1M4NCArdW5pdHM9bSArbm9fZGVmc1wiLFxuICAgICAgICAgIHNjYWxlOjEuNzIxODI3ODE2NTRlLTA1LFxuICAgICAgICAgIGpzb25yZXM6MTUuNSxcbiAgICAgICAgICBqc29ubWFyZ2luWDotOTk5LFxuICAgICAgICAgIGpzb25tYXJnaW5ZOjk4NTEuMCxcbiAgICAgICAgICB4b2Zmc2V0Oi0xOTQ5NTM1Ni4zNjkzLFxuICAgICAgICAgIHlvZmZzZXQ6MTI2MzU5MDguMTk4MlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmVhdHVyZXM6IERyaWxsZG93bk1hcC5nZXRGZWF0dXJlcyhjb3VudHJpZXNMaXN0LG1hcERhdGEpLy9bW11dXG4gICAgfTtcblxuICAgIGdlb2pzb24udGl0bGUgPSBtYXBOYW1lO1xuICAgIHJldHVybiBnZW9qc29uO1xuICB9XG5cbiAgc3RhdGljIGdldEZlYXR1cmVzKGNvdW50cmllc0xpc3QsbWFwRGF0YSxrZXk9XCJoYy1rZXlcIil7XG4gICAgaWYgKHR5cGVvZiBjb3VudHJpZXNMaXN0ID09PSAnc3RyaW5nJyl7XG4gICAgICByZXR1cm4gbWFwRGF0YS5mZWF0dXJlcy5maWx0ZXIoZmVhdHVyZSA9PiBmZWF0dXJlLnByb3BlcnRpZXNba2V5XSA9PT0gY291bnRyaWVzTGlzdCk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvdW50cmllc0xpc3QpKXtcbiAgICAgIHJldHVybiBtYXBEYXRhLmZlYXR1cmVzLmZpbHRlcihmZWF0dXJlID0+IGNvdW50cmllc0xpc3QuaW5kZXhPZihmZWF0dXJlLnByb3BlcnRpZXNba2V5XSkhPS0xKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY3VyTFZMIC0gY3VycmVudCBsZXZlbCBpbiBoaWVyYXJjaHlcbiAgICogQHBhcmFtIHtBcnJheX0gW3Nlcmllcz1bXV0gLSBzZXJpZXNcbiAgICogKi9cbiAgIGluaXRNYXAoY3VyTFZMLCBzZXJpZXMgPSBbXSl7XG4gICAgY3VyTFZMLnN1YmNlbGxzLmZvckVhY2goIHN1YmNlbGwgPT4ge1xuICAgICAgaWYgKHN1YmNlbGwubWFwSUQpIHtcbiAgICAgICAgbGV0IHNlcmllc0l0ZW0gPSB0aGlzLmNvbXBvc2VTZXJpZXMoc3ViY2VsbCk7XG4gICAgICAgIHNlcmllcy5wdXNoKHNlcmllc0l0ZW0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZXJpZXM7XG4gIH1cblxuICBzdGF0aWMgYWRkTWFwSURzVG9IaWVyYXJjaHlMZXZlbChoaWVyYXJjaHksIHBhcmVudCA9IG51bGwpIHtcbiAgICBoaWVyYXJjaHkuZm9yRWFjaChzdWJjZWxsID0+IHtcbiAgICAgIHN1YmNlbGwucGFyZW50ID0gcGFyZW50O1xuICAgICAgc3ViY2VsbC52YWx1ZSA9IE1hdGgucmFuZG9tKCkqMTAwO1xuICAgICAgaWYoc3ViY2VsbC5wYXJlbnQgJiYgc3ViY2VsbC5wYXJlbnQhPW51bGwgJiYgc3ViY2VsbC5wYXJlbnQubWFwKXtcbiAgICAgICAgc3ViY2VsbC5tYXAgPSBzdWJjZWxsLnBhcmVudC5tYXA7XG4gICAgICB9XG4gICAgICBpZiAoc3ViY2VsbC5zdWJjZWxscykge1xuICAgICAgICBEcmlsbGRvd25NYXAuYWRkTWFwSURzVG9IaWVyYXJjaHlMZXZlbChzdWJjZWxsLnN1YmNlbGxzLCBzdWJjZWxsKTtcbiAgICAgIH1cbiAgICAgIGlmKHN1YmNlbGwucGFyZW50ICYmIHN1YmNlbGwubWFwSUQgJiYgIXN1YmNlbGwucGFyZW50Lm1hcCl7XG4gICAgICAgIGlmKCFzdWJjZWxsLnBhcmVudC5tYXBJRClcbiAgICAgICAgICBzdWJjZWxsLnBhcmVudC5tYXBJRCA9IFtdO1xuICAgICAgICBzdWJjZWxsLnBhcmVudC5tYXBJRCA9IHN1YmNlbGwucGFyZW50Lm1hcElELmNvbmNhdChzdWJjZWxsLm1hcElEKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBsb2FkTWFwKHNvdXJjZSl7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9PntcbiAgICAgIGpRdWVyeS5nZXRTY3JpcHQoJ2h0dHBzOi8vY29kZS5oaWdoY2hhcnRzLmNvbS9tYXBkYXRhLycgKyBzb3VyY2UgKyAnLmpzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXNvbHZlKEhpZ2hjaGFydHMubWFwc1tzb3VyY2VdKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZXZlbCAtIGEgbGV2ZWwgaW4gaGllcmFyY2h5XG4gICAqICovXG4gIHN0YXRpYyBnZXRTZXJpZXNEYXRhKGxldmVsKXtcbiAgICBsZXQgZHJpbGxkb3duID0gbGV2ZWwuc3ViY2VsbHMgPyBsZXZlbC50ZXh0IDogbnVsbDtcbiAgICBpZiAodHlwZW9mIGxldmVsLm1hcElEID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgICdkcmlsbGRvd24nOiBkcmlsbGRvd24sXG4gICAgICAgICdjb2RlJzogbGV2ZWwubWFwSUQsXG4gICAgICAgICd2YWx1ZSc6IGxldmVsLnZhbHVlXG4gICAgICB9XVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShsZXZlbC5tYXBJRCkpe1xuICAgICAgcmV0dXJuIGxldmVsLm1hcElELm1hcChpZD0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAnZHJpbGxkb3duJzogZHJpbGxkb3duLFxuICAgICAgICAgICdjb2RlJzogaWQsXG4gICAgICAgICAgJ3ZhbHVlJzogbGV2ZWwudmFsdWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgZWxlbWVudCBpcyBjb3JydXB0ZWRcIik7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXRDb2xvcih2YWwpe1xuICAgIGlmICh2YWwgPCA2MClcbiAgICAgIHJldHVybiAnI2Y0NDMzNic7XG4gICAgZWxzZSBpZiAodmFsIDwgODApXG4gICAgICByZXR1cm4gJyNmZmMxMDcnO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiAnIzhiYzM0YSc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzZXJpZXMgZm9yIG1hcCBwb2ludHNcbiAgICogKi9cbiAgZ2V0Q29vcmRpbmF0ZVNlcmllcyhzdWJjZWxsLG1hcERhdGEsY2hhcnQpe1xuICAgIGNoYXJ0Lm1hcFRyYW5zZm9ybXMgPSBtYXBEYXRhID8gIG1hcERhdGFbXCJoYy10cmFuc2Zvcm1cIl0gOiBIaWdoY2hhcnRzLm1hcHNbXCJjdXN0b20vd29ybGQtaGlnaHJlczJcIl1bXCJoYy10cmFuc2Zvcm1cIl07XG4gICAgbGV0IHBvcyA9IGNoYXJ0LmZyb21MYXRMb25Ub1BvaW50KHsgbGF0OiBzdWJjZWxsLmNvb3JkaW5hdGVzWzBdLCBsb246IHN1YmNlbGwuY29vcmRpbmF0ZXNbMV0gfSk7XG4gICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgIHR5cGU6IFwibWFwcG9pbnRcIiwgLy8gb3IgbWFwYnViYmxlXG4gICAgICBuYW1lOiBzdWJjZWxsLnRleHQsXG4gICAgICBtYXJrZXI6IHtcbiAgICAgICAgbGluZUNvbG9yOiBcImJsYWNrXCIsXG4gICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgcmFkaXVzOiA0LFxuICAgICAgICBzeW1ib2w6IFwiY2lyY2xlXCIsXG4gICAgICB9LFxuICAgICAgZGF0YTogW3tcbiAgICAgICAgY29sb3I6IERyaWxsZG93bk1hcC5nZXRDb2xvcihzdWJjZWxsLnZhbHVlKSxcbiAgICAgICAgbmFtZTogc3ViY2VsbC50ZXh0LFxuICAgICAgICB2YWx1ZTogc3ViY2VsbC52YWx1ZSxcbiAgICAgICAgeDogcG9zLngsXG4gICAgICAgIHk6IHBvcy55XG4gICAgICB9XVxuICAgIH07XG4gICAgaWYodGhpcy5tYXBwb2ludENhbGxiYWNrKXtcbiAgICAgIGNvbmZpZy5ldmVudHMgPSB7XG4gICAgICAgIGNsaWNrOiB0aGlzLm1hcHBvaW50Q2FsbGJhY2tcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgY29tcG9zZVNlcmllcyhzdWJjZWxsLG1hcERhdGEsY2hhcnQpe1xuICAgIGlmKCFzdWJjZWxsLmNvb3JkaW5hdGVzKSB7XG4gICAgICBtYXBEYXRhID0gbWFwRGF0YSA/IEhpZ2hjaGFydHMuZ2VvanNvbihEcmlsbGRvd25NYXAuY3JlYXRlQ3VzdG9tR2VvSlNPTihtYXBEYXRhLCBzdWJjZWxsLm1hcElELCBzdWJjZWxsLnRleHQpKSA6IEhpZ2hjaGFydHMuZ2VvanNvbihEcmlsbGRvd25NYXAuY3JlYXRlQ3VzdG9tR2VvSlNPTihIaWdoY2hhcnRzLm1hcHNbJ2N1c3RvbS93b3JsZC1oaWdocmVzMiddLCBzdWJjZWxsLm1hcElELCBzdWJjZWxsLnRleHQpKTtcbiAgICAgIGlmIChzdWJjZWxsLm1hcElEKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogc3ViY2VsbC50ZXh0LFxuICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIHBvaW50Rm9ybWF0OiAnTlBTIDoge3BvaW50LnZhbHVlfSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFsbEFyZWFzOiBmYWxzZSxcbiAgICAgICAgICBwYXJlbnQ6IHN1YmNlbGwucGFyZW50LnRleHQsXG4gICAgICAgICAgbWFwRGF0YSxcbiAgICAgICAgICBqb2luQnk6IFsnaGMta2V5JywgJ2NvZGUnXSxcbiAgICAgICAgICBkYXRhOiBEcmlsbGRvd25NYXAuZ2V0U2VyaWVzRGF0YShzdWJjZWxsKSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge3JldHVybiB0aGlzLmdldENvb3JkaW5hdGVTZXJpZXMoc3ViY2VsbCxtYXBEYXRhLGNoYXJ0KX1cbiAgfVxuXG4gIHVwZGF0ZU1hcChjdXJMVkwsIGNoYXJ0LCBlKXtcbiAgICBjdXJMVkwgPSBjdXJMVkwuc3ViY2VsbHMuZmlsdGVyKCBlbCA9PiBlbC50ZXh0ID09IGUucG9pbnQuc2VyaWVzLm5hbWUpWzBdO1xuICAgIGlmKGN1ckxWTCAmJiBjdXJMVkwubWFwKXsvLyBpZiB3ZSBoYXZlIGFub3RoZXIgbWFwIHRvIGxvYWRcbiAgICAgIGxldCBtYXAgPSBEcmlsbGRvd25NYXAubG9hZE1hcChjdXJMVkwubWFwKTtcbiAgICAgIG1hcC50aGVuKG1hcERhdGE9PntcbiAgICAgICAgdGhpcy5hZGRTZXJpZXMoY3VyTFZMLGNoYXJ0LGUsbWFwRGF0YSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZihjdXJMVkwgJiYgIWN1ckxWTC5tYXApe1xuICAgICAgdGhpcy5hZGRTZXJpZXMoY3VyTFZMLGNoYXJ0LGUpO1xuICAgIH1cbiAgICByZXR1cm4gY3VyTFZMO1xuICB9XG5cbiAgIGFkZFNlcmllcyhjdXJMVkwsY2hhcnQsZSxtYXBEYXRhKXtcbiAgICBpZiAoY3VyTFZMLnN1YmNlbGxzICYmIGN1ckxWTC5pc0dsb2JhbCkge1xuICAgICAgaWYoIWN1ckxWTC5zdWJjZWxsc1swXS5pc0dsb2JhbCl7XG4gICAgICAgIGxldCBhID0gdGhpcy5jb21wb3NlU2VyaWVzKGN1ckxWTCxtYXBEYXRhLCBjaGFydCk7XG4gICAgICAgIGEuZGF0YS5tYXAoZWwgPT4ge2VsLmRyaWxsZG93biA9IG51bGwsIGVsLnZhbHVlID0gbnVsbH0pO1xuICAgICAgICBjaGFydC5hZGRTaW5nbGVTZXJpZXNBc0RyaWxsZG93bihlLnBvaW50LCBhKTtcbiAgICAgIH1cbiAgICAgIGN1ckxWTC5zdWJjZWxscy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgaWYoIWVsLm1hcElEICYmICFlbC5jb29yZGluYXRlcylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBhID0gdGhpcy5jb21wb3NlU2VyaWVzKGVsLG1hcERhdGEsIGNoYXJ0KTtcbiAgICAgICAgY2hhcnQuYWRkU2luZ2xlU2VyaWVzQXNEcmlsbGRvd24oZS5wb2ludCwgYSk7XG4gICAgICB9KTtcbiAgICAgIGNoYXJ0LmFwcGx5RHJpbGxkb3duKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBhID0gdGhpcy5jb21wb3NlU2VyaWVzKGN1ckxWTCwgbWFwRGF0YSwgY2hhcnQpO1xuICAgICAgYS5kYXRhLm1hcChlbCA9PiB7ZWwuZHJpbGxkb3duID0gbnVsbCwgZWwudmFsdWUgPSBudWxsfSk7XG4gICAgICBjaGFydC5hZGRTZXJpZXNBc0RyaWxsZG93bihlLnBvaW50LCBhKTtcbiAgICB9XG4gIH1cblxuICBkcmF3TWFwKGhpZXJhcmNoeSwgY29udGFpbmVySUQsIG9wdGlvbnMpe1xuICAgIGxldCBjdXJMVkwgPSBoaWVyYXJjaHlbMF07XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBjb25maWcgPSB7XG4gICAgICBsYW5nOiB7XG4gICAgICAgIGRyaWxsVXBUZXh0OiAnQmFjayB0byB7c2VyaWVzLnBhcmVudH0nXG4gICAgICB9LFxuICAgICAgdG9vbHRpcDoge1xuICAgICAgICBwb2ludEZvcm1hdDogJ05QUyA6IHtwb2ludC52YWx1ZX0nXG4gICAgICB9LFxuICAgICAgdGl0bGU6IHtcbiAgICAgICAgdGV4dDogJ0RyaWxsZG93biBtYXAnXG4gICAgICB9LFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgbWFwTmF2aWdhdGlvbjoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIHN1YnRpdGxlOntcbiAgICAgICAgYWxpZ246ICdyaWdodCcsXG4gICAgICAgIHRleHQ6IGBDdXJyZW50IGxldmVsOiAke2N1ckxWTC50ZXh0fWBcbiAgICAgIH0sXG4gICAgICBjaGFydDp7XG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIGRyaWxsZG93bjogdGhpcy5kcmlsbGRvd24uY2FsbCh0aGlzLGN1ckxWTCksXG4gICAgICAgICAgZHJpbGx1cGFsbDogZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICBjdXJMVkwgPSBjdXJMVkwucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5zdWJ0aXRsZS51cGRhdGUoe3RleHQ6IGBDdXJyZW50IGxldmVsOiAke2N1ckxWTC50ZXh0fWB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXJpZXM6IHRoaXMuaW5pdE1hcChjdXJMVkwsW3tcbiAgICAgICAgbWFwRGF0YTogSGlnaGNoYXJ0cy5tYXBzW1wiY3VzdG9tL3dvcmxkLWhpZ2hyZXMyXCJdXG4gICAgICB9XSlcbiAgICB9O1xuICAgIGNvbmZpZyA9IFJlcG9ydGFsQmFzZS5taXhpbihjb25maWcsb3B0aW9ucyk7XG4gICAgSGlnaGNoYXJ0cy5tYXBDaGFydCggY29udGFpbmVySUQsIGNvbmZpZyk7XG4gIH1cblxuICBkcmlsbGRvd24oZSxjdXJMVkwpe1xuICAgIGNvbnNvbGUubG9nKGUpO1xuICAgIGxldCBjaGFydCA9IGUudGFyZ2V0O1xuICAgIGN1ckxWTCA9IHRoaXMudXBkYXRlTWFwKGN1ckxWTCwgY2hhcnQsIGUpO1xuICAgIGNoYXJ0LnN1YnRpdGxlLnVwZGF0ZSh7dGV4dDogYEN1cnJlbnQgcmVnaW9uOiAke2N1ckxWTC50ZXh0fTxicj4gUmVnaW9uIE5QUzogJHtjdXJMVkwudmFsdWV9YH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERyaWxsZG93bk1hcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9EcmlsbGRvd25NYXAuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ]);